/*
	Copyright (c) 2004-2016, The JS Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

(function(
	userConfig,
	defaultConfig
){
	// summary:
	//		This is the "source loader" and is the entry point for Dojo during development. You may also load Dojo with
	//		any AMD-compliant loader via the package main module dojo/main.
	// description:
	//		This is the "source loader" for Dojo. It provides an AMD-compliant loader that can be configured
	//		to operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded
	//		IAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package
	//		via the package main module dojo/main and this loader is not required; see dojo/package.json for details.
	//
	//		In order to keep compatibility with the v1.x line, this loader includes additional machinery that enables
	//		the dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed
	//		via the has.js API and statically removed via the build system.
	//
	//		This loader includes sniffing machinery to determine the environment; the following environments are supported:
	//
	//		- browser
	//		- node.js
	//		- rhino
	//
	//		This is the so-called "source loader". As such, it includes many optional features that may be discarded by
	//		building a customized version with the build system.

	// Design and Implementation Notes
	//
	// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.
	//
	// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)
	// loader that can be configured to operate in either synchronous or asynchronous modes.
	//
	// Since this machinery implements a loader, it does not have the luxury of using a load system and/or
	// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:
	//
	//	 1. Small library for use implementing the loader.
	//	 2. Define the has.js API; this is used throughout the loader to bracket features.
	//	 3. Define the node.js and rhino sniffs and sniff.
	//	 4. Define the loader's data.
	//	 5. Define the configuration machinery.
	//	 6. Define the script element sniffing machinery and sniff for configuration data.
	//	 7. Configure the loader IAW the provided user, default, and sniffing data.
	//	 8. Define the global require function.
	//	 9. Define the module resolution machinery.
	//	10. Define the module and plugin module definition machinery
	//	11. Define the script injection machinery.
	//	12. Define the window load detection.
	//	13. Define the logging API.
	//	14. Define the tracing API.
	//	16. Define the AMD define function.
	//	17. Define the dojo v1.x provide/require machinery--so called "legacy" modes.
	//	18. Publish global variables.
	//
	// Language and Acronyms and Idioms
	//
	// moduleId: a CJS module identifier, (used for public APIs)
	// mid: moduleId (used internally)
	// packageId: a package identifier (used for public APIs)
	// pid: packageId (used internally); the implied system or default package has pid===""
	// pack: package is used internally to reference a package object (since javascript has reserved words including "package")
	// prid: plugin resource identifier
	// The integer constant 1 is used in place of true and 0 in place of false.
	//
	// The "foreign-loader" has condition is defined if another loader is being used (e.g. webpack) and this code is only
	// needed for resolving module identifiers based on the config.  In this case, only the functions require.toUrl and 
	// require.toAbsMid are supported.  The require and define functions are not supported.

	// define global
	var globalObject = (function(){
		if (typeof global !== 'undefined' && typeof global !== 'function') {
			// global spec defines a reference to the global object called 'global'
			// https://github.com/tc39/proposal-global
			// `global` is also defined in NodeJS
			return global;
		}
		else if (typeof window !== 'undefined') {
			// window is defined in browsers
			return window;
		}
		else if (typeof self !== 'undefined') {
			// self is defined in WebWorkers
			return self;
		}
		return this;
	})();

	// define a minimal library to help build the loader
	var noop = function(){
		},

		isEmpty = function(it){
			for(var p in it){
				return 0;
			}
			return 1;
		},

		toString = {}.toString,

		isFunction = function(it){
			return toString.call(it) == "[object Function]";
		},

		isString = function(it){
			return toString.call(it) == "[object String]";
		},

		isArray = function(it){
			return toString.call(it) == "[object Array]";
		},

		forEach = function(vector, callback){
			if(vector){
				for(var i = 0; i < vector.length;){
					callback(vector[i++]);
				}
			}
		},

		mix = function(dest, src){
			for(var p in src){
				dest[p] = src[p];
			}
			return dest;
		},

		makeError = function(error, info){
			return mix(new Error(error), {src:"dojoLoader", info:info});
		},

		uidSeed = 1,

		uid = function(){
			// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.
			return "_" + uidSeed++;
		},

		// FIXME: how to doc window.require() api

		// this will be the global require function; define it immediately so we can start hanging things off of it
		req = function(
			config,		  //(object, optional) hash of configuration properties
			dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback
			callback	  //(function, optional) lambda expression to apply to module values implied by dependencies
		){
			return contextRequire(config, dependencies, callback, 0, req);
		},

		// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout
		global = globalObject,

		doc = global.document,

		element = doc && doc.createElement("DiV"),

		has = req.has = function(name){
			return isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];
		},

		hasCache = has.cache = defaultConfig.hasCache;

	if (isFunction(userConfig)) {
		userConfig = userConfig(globalObject);
	}

	has.add = function(name, test, now, force){
		(hasCache[name]===undefined || force) && (hasCache[name] = test);
		return now && has(name);
	};

	 0 && has.add("host-node", userConfig.has && "host-node" in userConfig.has ?
		userConfig.has["host-node"] :
		(typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
	if( 0 ){
		// fixup the default config for node.js environment
		require("./_base/configNode.js").config(defaultConfig);
		// remember node's require (with respect to baseUrl==dojo's root)
		defaultConfig.loaderPatch.nodeRequire = require;
	}

	 0 && has.add("host-rhino", userConfig.has && "host-rhino" in userConfig.has ?
		userConfig.has["host-rhino"] :
		(typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
	if( 0 ){
		// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...
		for(var baseUrl = userConfig.baseUrl || ".", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){
			arg = (rhinoArgs[i++] + "").split("=");
			if(arg[0] == "baseUrl"){
				baseUrl = arg[1];
				break;
			}
		}
		load(baseUrl + "/_base/configRhino.js");
		rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);
	}

	has.add("host-webworker", ((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope)));
	if(has("host-webworker")){
		mix(defaultConfig.hasCache, {
			"host-browser": 0,
			"dom": 0,
			"dojo-dom-ready-api": 0,
			"dojo-sniff": 0,
			"dojo-inject-api": 1,
			"host-webworker": 1,
			"dojo-guarantee-console": 0 // console is immutable in FF30+, see https://bugs.dojotoolkit.org/ticket/18100
		});

		defaultConfig.loaderPatch = {
			injectUrl: function(url, callback){
				// TODO:
				//		This is not async, nor can it be in Webworkers.  It could be made better by passing
				//		the entire require array into importScripts at.  This way the scripts are loaded in
				//		async mode; even if the callbacks are ran in sync.  It is not a major issue as webworkers
				//		tend to be long running where initial startup is not a major factor.

				try{
					importScripts(url);
					callback();
				}catch(e){
					console.info("failed to load resource (" + url + ")");
					console.error(e);
				}
			}
		};
	}

	// userConfig has tests override defaultConfig has tests; do this after the environment detection because
	// the environment detection usually sets some has feature values in the hasCache.
	for(var p in userConfig.has){
		has.add(p, userConfig.has[p], 0, 1);
	}

	//
	// define the loader data
	//

	// the loader will use these like symbols if the loader has the traceApi; otherwise
	// define magic numbers so that modules can be provided as part of defaultConfig
	var requested = 1,
		arrived = 2,
		nonmodule = 3,
		executing = 4,
		executed = 5;

	if( false ){
		// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code
		requested = "requested";
		arrived = "arrived";
		nonmodule = "not-a-module";
		executing = "executing";
		executed = "executed";
	}

	var legacyMode = 0,
		sync = "sync",
		xd = "xd",
		syncExecStack = [],
		dojoRequirePlugin = 0,
		checkDojoRequirePlugin = noop,
		transformToAmd = noop,
		getXhr;
	if( false ){
		req.isXdUrl = noop;

		req.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){
			// the first dojo/_base/loader loaded gets to define these variables; they are designed to work
			// in the presence of zero to many mapped dojo/_base/loaders
			if(!dojoRequirePlugin){
				dojoRequirePlugin = dojoRequirePlugin_;
				checkDojoRequirePlugin = checkDojoRequirePlugin_;
				transformToAmd = transformToAmd_;
			}

			return {
				sync:sync,
				requested:requested,
				arrived:arrived,
				nonmodule:nonmodule,
				executing:executing,
				executed:executed,
				syncExecStack:syncExecStack,
				modules:modules,
				execQ:execQ,
				getModule:getModule,
				injectModule:injectModule,
				setArrived:setArrived,
				signal:signal,
				finishExec:finishExec,
				execModule:execModule,
				dojoRequirePlugin:dojoRequirePlugin,
				getLegacyMode:function(){return legacyMode;},
				guardCheckComplete:guardCheckComplete
			};
		};

		if( 1  || has("host-webworker")){
			// in legacy sync mode, the loader needs a minimal XHR library

			var locationProtocol = location.protocol,
				locationHost = location.host;
			req.isXdUrl = function(url){
				if(/^\./.test(url)){
					// begins with a dot is always relative to page URL; therefore not xdomain
					return false;
				}
				if(/^\/\//.test(url)){
					// for v1.6- backcompat, url starting with // indicates xdomain
					return true;
				}
				// get protocol and host
				// \/+ takes care of the typical file protocol that looks like file:///drive/path/to/file
				// locationHost is falsy if file protocol => if locationProtocol matches and is "file:", || will return false
				var match = url.match(/^([^\/\:]+\:)\/+([^\/]+)/);
				return match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));
			};


			// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config
			 false && has.add("dojo-xhr-factory", 1);
			has.add("dojo-force-activex-xhr",  1  && !doc.addEventListener && window.location.protocol == "file:");
			has.add("native-xhr", typeof XMLHttpRequest != "undefined");
			if(has("native-xhr") && !has("dojo-force-activex-xhr")){
				getXhr = function(){
					return new XMLHttpRequest();
				};
			}else{
				// if in the browser an old IE; find an xhr
				for(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){
					try{
						progid = XMLHTTP_PROGIDS[i++];
						if(new ActiveXObject(progid)){
							// this progid works; therefore, use it from now on
							break;
						}
					}catch(e){
						// squelch; we're just trying to find a good ActiveX progid
						// if they all fail, then progid ends up as the last attempt and that will signal the error
						// the first time the client actually tries to exec an xhr
					}
				}
				getXhr = function(){
					return new ActiveXObject(progid);
				};
			}
			req.getXhr = getXhr;

			has.add("dojo-gettext-api", 1);
			req.getText = function(url, async, onLoad){
				var xhr = getXhr();
				xhr.open('GET', fixupUrl(url), false);
				xhr.send(null);
				if(xhr.status == 200 || (!location.host && !xhr.status)){
					if(onLoad){
						onLoad(xhr.responseText, async);
					}
				}else{
					throw makeError("xhrFailed", xhr.status);
				}
				return xhr.responseText;
			};
		}
	}else{
		req.async = 1;
	}

	//
	// loader eval
	//
	var eval_ =  has("csp-restrictions") ?
		// noop eval if there are csp restrictions
		function(){} :
		// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution
		new Function('return eval(arguments[0]);');

	req.eval =
		function(text, hint){
			return eval_(text + "\r\n//# sourceURL=" + hint);
		};

	//
	// loader micro events API
	//
	var listenerQueues = {},
		error = "error",
		signal = req.signal = function(type, args){
			var queue = listenerQueues[type];
			// notice we run a copy of the queue; this allows listeners to add/remove
			// other listeners without affecting this particular signal
			forEach(queue && queue.slice(0), function(listener){
				listener.apply(null, isArray(args) ? args : [args]);
			});
		},
		on = req.on = function(type, listener){
			// notice a queue is not created until a client actually connects
			var queue = listenerQueues[type] || (listenerQueues[type] = []);
			queue.push(listener);
			return {
				remove:function(){
					for(var i = 0; i<queue.length; i++){
						if(queue[i]===listener){
							queue.splice(i, 1);
							return;
						}
					}
				}
			};
		};

	// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded
	// lexical variables hold key loader data structures to help with minification; these may be completely,
	// one-time initialized by defaultConfig for optimized/built versions
	var
		aliases
			// a vector of pairs of [regexs or string, replacement] => (alias, actual)
			= [],

		paths
			// CommonJS paths
			= {},

		pathsMapProg
			// list of (from-path, to-path, regex, length) derived from paths;
			// a "program" to apply paths; see computeMapProg
			= [],

		packs
			// a map from packageId to package configuration object; see fixupPackageInfo
			= {},

		map = req.map
			// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map
			= {},

		mapProgs
			// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value
			= [],

		modules
			// A hash:(mid) --> (module-object) the module namespace
			//
			// pid: the package identifier to which the module belongs (e.g., "dojo"); "" indicates the system or default package
			// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., "dojo/io/script")
			// url: the URL from which the module was retrieved
			// pack: the package object of the package to which the module belongs
			// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed
			// deps: the dependency vector for this module (vector of modules objects)
			// def: the factory for this module
			// result: the result of the running the factory for this module
			// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define
			// load: plugin load function; applicable only for plugins
			//
			// Modules go through several phases in creation:
			//
			// 1. Requested: some other module's definition or a require application contained the requested module in
			//	  its dependency vector or executing code explicitly demands a module via req.require.
			//
			// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL
			//
			// 3. Loaded: the resource injected in [2] has been evaluated.
			//
			// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some
			//	  resources may just contain a bundle of code and never formally define a module via define
			//
			// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.
			= {},

		cacheBust
			// query string to append to module URLs to bust browser cache
			= "",

		cache
			// hash:(mid | url)-->(function | string)
			//
			// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or
			// url --> string. The url key is distinguished from the mid key by always containing the prefix "url:". url keys as provided
			// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided
			// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.
			//
			// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given
			// by any mappings *iff* the config.cache was received as part of a module resource request.
			//
			// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules
			// to retrieve cached items that may have arrived consequent to another namespace.
			//
			 = {},

		urlKeyPrefix
			// the prefix to prepend to a URL key in the cache.
			= "url:",

		pendingCacheInsert
			// hash:(mid)-->(function)
			//
			// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are
			// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another
			// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending
			// cache for the local configuration, possibly relocating modules.
			 = {},

		dojoSniffConfig
			// map of configuration variables
			// give the data-dojo-config as sniffed from the document (if any)
			= {},

		insertPointSibling
			// the nodes used to locate where scripts are injected into the document
			= 0;

	if( 1 ){
		if (!has("foreign-loader")) {
			var consumePendingCacheInsert = function(referenceModule, clear){
					clear = clear !== false;
					var p, item, match, now, m;
					for(p in pendingCacheInsert){
						item = pendingCacheInsert[p];
						match = p.match(/^url\:(.+)/);
						if(match){
							cache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;
						}else if(p=="*now"){
							now = item;
						}else if(p!="*noref"){
							m = getModuleInfo(p, referenceModule, true);
							cache[m.mid] = cache[urlKeyPrefix + m.url] = item;
						}
					}
					if(now){
						now(createRequire(referenceModule));
					}
					if(clear){
						pendingCacheInsert = {};
					}
				};
		}
		var escapeString = function(s){
				return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(c){ return "\\" + c; });
			},

			computeMapProg = function(map, dest){
				// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of
				// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-
				// of-map-key. The regex looks for the map-key followed by either "/" or end-of-string at the beginning
				// of a the search source. Notice the map-value is irrelevant to the algorithm
				dest.splice(0, dest.length);
				for(var p in map){
					dest.push([
						p,
						map[p],
						new RegExp("^" + escapeString(p) + "(\/|$)"),
						p.length]);
				}
				dest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });
				return dest;
			},

			computeAliases = function(config, dest){
				forEach(config, function(pair){
					// take a fixed-up copy...
					dest.push([isString(pair[0]) ? new RegExp("^" + escapeString(pair[0]) + "$") : pair[0], pair[1]]);
				});
			},


			fixupPackageInfo = function(packageInfo){
				// calculate the precise (name, location, main, mappings) for a package
				var name = packageInfo.name;
				if(!name){
					// packageInfo must be a string that gives the name
					name = packageInfo;
					packageInfo = {name:name};
				}
				packageInfo = mix({main:"main"}, packageInfo);
				packageInfo.location = packageInfo.location ? packageInfo.location : name;

				// packageMap is deprecated in favor of AMD map
				if(packageInfo.packageMap){
					map[name] = packageInfo.packageMap;
				}

				if(!packageInfo.main.indexOf("./")){
					packageInfo.main = packageInfo.main.substring(2);
				}

				// now that we've got a fully-resolved package object, push it into the configuration
				packs[name] = packageInfo;
			},

			delayedModuleConfig
				// module config cannot be consumed until the loader is completely initialized; therefore, all
				// module config detected during booting is memorized and applied at the end of loader initialization
				// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but
				// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete
				= [],


			config = function(config, booting, referenceModule){
				for(var p in config){
					if(p=="waitSeconds"){
						req.waitms = (config[p] || 0) * 1000;
					}
					if(p=="cacheBust"){
						cacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + "") : "";
					}
					if(p=="baseUrl" || p=="combo"){
						req[p] = config[p];
					}
					if( false  && p=="async"){
						// falsy or "sync" => legacy sync loader
						// "xd" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)
						// "legacyAsync" => permanently in "xd" by choice
						// "debugAtAllCosts" => trying to load everything via script injection (not implemented)
						// otherwise, must be truthy => AMD
						// legacyMode: sync | legacyAsync | xd | false
						var mode = config[p];
						req.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));
						req.async = !legacyMode;
					}
					if(config[p]!==hasCache){
						// accumulate raw config info for client apps which can use this to pass their own config
						req.rawConfig[p] = config[p];
						p!="has" && has.add("config-"+p, config[p], 0, booting);
					}
				}

				// make sure baseUrl exists
				if(!req.baseUrl){
					req.baseUrl = "./";
				}
				// make sure baseUrl ends with a slash
				if(!/\/$/.test(req.baseUrl)){
					req.baseUrl += "/";
				}

				// now do the special work for has, packages, packagePaths, paths, aliases, and cache

				for(p in config.has){
					has.add(p, config.has[p], 0, booting);
				}

				// for each package found in any packages config item, augment the packs map owned by the loader
				forEach(config.packages, fixupPackageInfo);

				// for each packagePath found in any packagePaths config item, augment the packageConfig
				// packagePaths is deprecated; remove in 2.0
				for(var baseUrl in config.packagePaths){
					forEach(config.packagePaths[baseUrl], function(packageInfo){
						var location = baseUrl + "/" + packageInfo;
						if(isString(packageInfo)){
							packageInfo = {name:packageInfo};
						}
						packageInfo.location = location;
						fixupPackageInfo(packageInfo);
					});
				}

				// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable
				// is published (see dojo-publish-privates), the published variable will always hold a valid value.

				// this must come after all package processing since package processing may mutate map
				computeMapProg(mix(map, config.map), mapProgs);
				forEach(mapProgs, function(item){
					item[1] = computeMapProg(item[1], []);
					if(item[0]=="*"){
						mapProgs.star = item;
					}
				});

				// push in any paths and recompute the internal pathmap
				computeMapProg(mix(paths, config.paths), pathsMapProg);

				// aliases
				computeAliases(config.aliases, aliases);

				if (!has("foreign-loader")) {
					if(booting){
						delayedModuleConfig.push({config:config.config});
					}else{
						for(p in config.config){
							var module = getModule(p, referenceModule);
							module.config = mix(module.config || {}, config.config[p]);
						}
					}

					// push in any new cache values
					if(config.cache){
						consumePendingCacheInsert();
						pendingCacheInsert = config.cache;
						//inject now all depencies so cache is available for mapped module
						consumePendingCacheInsert(0, !!config.cache["*noref"]);
					}
				}
				signal("config", [config, req.rawConfig]);
			};

		//
		// execute the various sniffs; userConfig can override and value
		//

		if(has("dojo-cdn") ||  1 ){
			// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.
			// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the
			// dojo location on CDN deployments and baseUrl when either/both of these are not provided
			// explicitly in the config data; this is the 1.6- behavior.

			var scripts = doc.getElementsByTagName("script"),
				i = 0,
				script, dojoDir, src, match;
			while(i < scripts.length){
				script = scripts[i++];
				if((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)dojo\.js(\W|$)/i))){
					// sniff dojoDir and baseUrl
					dojoDir = match[3] || "";
					defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff configuration on attribute in script element
				if((src = (script.getAttribute("data-dojo-config") || script.getAttribute("djConfig")))){
					dojoSniffConfig = req.eval("({ " + src + " })", "data-dojo-config");

					// remember an insertPointSibling
					insertPointSibling = script;
				}

				// sniff requirejs attribute
				if( 0 ){
					if((src = script.getAttribute("data-main"))){
						dojoSniffConfig.deps = dojoSniffConfig.deps || [src];
					}
				}
			}
		}

		if( false ){
			// pass down doh.testConfig from parent as if it were a data-dojo-config
			try{
				if(window.parent != window && window.parent.require){
					var doh = window.parent.require("doh");
					doh && mix(dojoSniffConfig, doh.testConfig);
				}
			}catch(e){}
		}

		// configure the loader; let the user override defaults
		req.rawConfig = {};
		config(defaultConfig, 1);

		// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides
		if(has("dojo-cdn")){
			packs.dojo.location = dojoDir;
			if(dojoDir){
				dojoDir += "/";
			}
			packs.dijit.location = dojoDir + "../dijit/";
			packs.dojox.location = dojoDir + "../dojox/";
		}

		config(userConfig, 1);
		config(dojoSniffConfig, 1);

	}else{
		// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application
		paths = defaultConfig.paths;
		pathsMapProg = defaultConfig.pathsMapProg;
		packs = defaultConfig.packs;
		aliases = defaultConfig.aliases;
		mapProgs = defaultConfig.mapProgs;
		modules = defaultConfig.modules;
		cache = defaultConfig.cache;
		cacheBust = defaultConfig.cacheBust;

		// remember the default config for other processes (e.g., dojo/config)
		req.rawConfig = defaultConfig;
	}


	if (!has("foreign-loader")) {
		if( 0 ){
			req.combo = req.combo || {add:noop};
			var comboPending = 0,
				combosPending = [],
				comboPendingTimer = null;
		}
		

		// build the loader machinery iaw configuration, including has feature tests
		var injectDependencies = function(module){
				// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies
				guardCheckComplete(function(){
					forEach(module.deps, injectModule);
					if( 0  && comboPending && !comboPendingTimer){
						comboPendingTimer = setTimeout(function() {
							comboPending = 0;
							comboPendingTimer = null;
							req.combo.done(function(mids, url) {
								var onLoadCallback= function(){
									// defQ is a vector of module definitions 1-to-1, onto mids
									runDefQ(0, mids);
									checkComplete();
								};
								combosPending.push(mids);
								injectingModule = mids;
								req.injectUrl(url, onLoadCallback, mids);
								injectingModule = 0;
							}, req);
						}, 0);
					}
				});
			},

			contextRequire = function(a1, a2, a3, referenceModule, contextRequire){
				var module, syntheticMid;
				if(isString(a1)){
					// signature is (moduleId)
					module = getModule(a1, referenceModule, true);
					if(module && module.executed){
						return module.result;
					}
					throw makeError("undefinedModule", a1);
				}
				if(!isArray(a1)){
					// a1 is a configuration
					config(a1, 0, referenceModule);

					// juggle args; (a2, a3) may be (dependencies, callback)
					a1 = a2;
					a2 = a3;
				}
				if(isArray(a1)){
					// signature is (requestList [,callback])
					if(!a1.length){
						a2 && a2();
					}else{
						syntheticMid = "require*" + uid();

						// resolve the request list with respect to the reference module
						for(var mid, deps = [], i = 0; i < a1.length;){
							mid = a1[i++];
							deps.push(getModule(mid, referenceModule));
						}

						// construct a synthetic module to control execution of the requestList, and, optionally, callback
						module = mix(makeModuleInfo("", syntheticMid, 0, ""), {
							injected: arrived,
							deps: deps,
							def: a2 || noop,
							require: referenceModule ? referenceModule.require : req,
							gc: 1 //garbage collect
						});
						modules[module.mid] = module;

						// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies
						injectDependencies(module);

						// try to immediately execute
						// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe
						// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.
						// ...but *always* insist on immediate in synch mode
						var strict = checkCompleteGuard && legacyMode!=sync;
						guardCheckComplete(function(){
							execModule(module, strict);
						});
						if(!module.executed){
							// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ
							execQ.push(module);
						}
						checkComplete();
					}
				}
				return contextRequire;
			},

			createRequire = function(module){
				if(!module){
					return req;
				}
				var result = module.require;
				if(!result){
					result = function(a1, a2, a3){
						return contextRequire(a1, a2, a3, module, result);
					};
					module.require = mix(result, req);
					result.module = module;
					result.toUrl = function(name){
						return toUrl(name, module);
					};
					result.toAbsMid = function(mid){
						return toAbsMid(mid, module);
					};
					if( 0 ){
						result.undef = function(mid){
							req.undef(mid, module);
						};
					}
					if( false ){
						result.syncLoadNls = function(mid){
							var nlsModuleInfo = getModuleInfo(mid, module),
								nlsModule = modules[nlsModuleInfo.mid];
							if(!nlsModule || !nlsModule.executed){
								cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
								if(cached){
									evalModuleText(cached);
									nlsModule = modules[nlsModuleInfo.mid];
								}
							}
							return nlsModule && nlsModule.executed && nlsModule.result;
						};
					}

				}
				return result;
			},

		  execQ =
				// The list of modules that need to be evaluated.
				[],

			defQ =
				// The queue of define arguments sent to loader.
				[],

			waiting =
				// The set of modules upon which the loader is waiting for definition to arrive
				{},

			setRequested = function(module){
				module.injected = requested;
				waiting[module.mid] = 1;
				if(module.url){
					waiting[module.url] = module.pack || 1;
				}
				startTimer();
			},

			setArrived = function(module){
				module.injected = arrived;
				delete waiting[module.mid];
				if(module.url){
					delete waiting[module.url];
				}
				if(isEmpty(waiting)){
					clearTimer();
					 false  && legacyMode==xd && (legacyMode = sync);
				}
			},

			execComplete = req.idle =
				// says the loader has completed (or not) its work
				function(){
					return !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;
				};
	}

	var runMapProg = function(targetMid, map){
			// search for targetMid in map; return the map item if found; falsy otherwise
			if(map){
			for(var i = 0; i < map.length; i++){
				if(map[i][2].test(targetMid)){
					return map[i];
				}
			}
			}
			return 0;
		},

		compactPath = function(path){
			var result = [],
				segment, lastSegment;
			path = path.replace(/\\/g, '/').split('/');
			while(path.length){
				segment = path.shift();
				if(segment==".." && result.length && lastSegment!=".."){
					result.pop();
					lastSegment = result[result.length - 1];
				}else if(segment!="."){
					result.push(lastSegment= segment);
				} // else ignore "."
			}
			return result.join("/");
		},

		makeModuleInfo = function(pid, mid, pack, url){
			if( false ){
				var xd= req.isXdUrl(url);
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};
			}else{
				return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};
			}
		},

		getModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){
			// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)
			// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader
			var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
			requestedMid = mid;
			isRelative = /^\./.test(mid);
			if(/(^\/)|(\:)|(\.js$)/.test(mid) || (isRelative && !referenceModule)){
				// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page
				// whatever it is, it's not a module but just a URL of some sort
				// note: pid===0 indicates the routine is returning an unmodified mid

				return makeModuleInfo(0, mid, 0, mid);
			}else{
				// relative module ids are relative to the referenceModule; get rid of any dots
				mid = compactPath(isRelative ? (referenceModule.mid + "/../" + mid) : mid);
				if(/^\./.test(mid)){
					throw makeError("irrationalPath", mid);
				}
				// at this point, mid is an absolute mid

				// map the mid
				if(!fromPendingCache && !isRelative && mapProgs.star){
					mapItem = runMapProg(mid, mapProgs.star[1]);
				}
				if(!mapItem && referenceModule){
					mapItem = runMapProg(referenceModule.mid, mapProgs);
					mapItem = mapItem && runMapProg(mid, mapItem[1]);
				}

				if(mapItem){
					mid = mapItem[1] + mid.substring(mapItem[3]);
					}

				match = mid.match(/^([^\/]+)(\/(.+))?$/);
				pid = match ? match[1] : "";
				if((pack = packs[pid])){
					mid = pid + "/" + (midInPackage = (match[3] || pack.main));
				}else{
					pid = "";
				}

				// search aliases
				var candidateLength = 0,
					candidate = 0;
				forEach(aliases, function(pair){
					var match = mid.match(pair[0]);
					if(match && match.length>candidateLength){
						candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];
					}
				});
				if(candidate){
					return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);
				}

				result = modules[mid];
				if(result){
					return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
				}
			}
			// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the
			// fully resolved (i.e., all relative indicators and package mapping resolved) module id

			// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid
			mapItem = runMapProg(mid, pathsMapProg);
			if(mapItem){
				url = mapItem[1] + mid.substring(mapItem[3]);
			}else if(pid){
				url = (pack.location.slice(-1) === '/' ? pack.location.slice(0, -1) : pack.location) + "/" + midInPackage;
			}else if(has("config-tlmSiblingOfDojo")){
				url = "../" + mid;
			}else{
				url = mid;
			}
			// if result is not absolute, add baseUrl
			if(!(/(^\/)|(\:)/.test(url))){
				url = baseUrl + url;
			}
			url += ".js";
			return makeModuleInfo(pid, mid, pack, compactPath(url));
		},

		getModuleInfo = function(mid, referenceModule, fromPendingCache){
			return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);
		};

	if (!has("foreign-loader")) {
		var resolvePluginResourceId = function(plugin, prid, referenceModule){
				return plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);
			},

			dynamicPluginUidGenerator = 0,

			getModule = function(mid, referenceModule, immediate){
				// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule
				var match, plugin, prid, result;
				match = mid.match(/^(.+?)\!(.*)$/);
				if(match){
					// name was <plugin-module>!<plugin-resource-id>
					plugin = getModule(match[1], referenceModule, immediate);

					if( false  && legacyMode == sync && !plugin.executed){
						injectModule(plugin);
						if(plugin.injected===arrived && !plugin.executed){
							guardCheckComplete(function(){
								execModule(plugin);
							});
						}
						if(plugin.executed){
							promoteModuleToPlugin(plugin);
						}else{
							// we are in xdomain mode for some reason
							execQ.unshift(plugin);
						}
					}



					if(plugin.executed === executed && !plugin.load){
						// executed the module not knowing it was a plugin
						promoteModuleToPlugin(plugin);
					}

					// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise
					if(plugin.load){
						prid = resolvePluginResourceId(plugin, match[2], referenceModule);
						mid = (plugin.mid + "!" + (plugin.dynamic ? ++dynamicPluginUidGenerator + "!" : "") + prid);
					}else{
						prid = match[2];
						mid = plugin.mid + "!" + (++dynamicPluginUidGenerator) + "!waitingForPlugin";
					}
					result = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};
				}else{
					result = getModuleInfo(mid, referenceModule);
				}
				return modules[result.mid] || (!immediate && (modules[result.mid] = result));
			};
	}

	var toAbsMid = req.toAbsMid = function(mid, referenceModule){
			return getModuleInfo(mid, referenceModule).mid;
		},

		toUrl = req.toUrl = function(name, referenceModule){
			var moduleInfo = getModuleInfo(name+"/x", referenceModule),
				url= moduleInfo.url;
			return fixupUrl(moduleInfo.pid===0 ?
				// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases
				name :
				// "/x.js" since getModuleInfo automatically appends ".js" and we appended "/x" to make name look like a module id
				url.substring(0, url.length-5)
			);
		};

	if (!has("foreign-loader")) {
		var nonModuleProps = {
				injected: arrived,
				executed: executed,
				def: nonmodule,
				result: nonmodule
			},

			makeCjs = function(mid){
				return modules[mid] = mix({mid:mid}, nonModuleProps);
			},

			cjsRequireModule = makeCjs("require"),
			cjsExportsModule = makeCjs("exports"),
			cjsModuleModule = makeCjs("module"),

			runFactory = function(module, args){
				req.trace("loader-run-factory", [module.mid]);
				var factory = module.def,
					result;
				 false  && syncExecStack.unshift(module);
				if(has("config-dojo-loader-catches")){
					try{
						result= isFunction(factory) ? factory.apply(null, args) : factory;
					}catch(e){
						signal(error, module.result = makeError("factoryThrew", [module, e]));
					}
				}else{
					result= isFunction(factory) ? factory.apply(null, args) : factory;
				}
				module.result = result===undefined && module.cjs ? module.cjs.exports : result;
				 false  && syncExecStack.shift(module);
			},

			abortExec = {},

			defOrder = 0,

			promoteModuleToPlugin = function(pluginModule){
				var plugin = pluginModule.result;
				pluginModule.dynamic = plugin.dynamic;
				pluginModule.normalize = plugin.normalize;
				pluginModule.load = plugin.load;
				return pluginModule;
			},

			resolvePluginLoadQ = function(plugin){
				// plugins is a newly executed module that has a loadQ waiting to run

				// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid
				// recall the original mid was created before the plugin was on board and therefore it was impossible to
				// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change
				var map = {};
				forEach(plugin.loadQ, function(pseudoPluginResource){
					// manufacture and insert the real module in modules
					var prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),
						mid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + "!" + prid),
						pluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});
					if(!modules[mid] || !modules[mid].injected /*for require.undef*/){
						// create a new (the real) plugin resource and inject it normally now that the plugin is on board
						injectPlugin(modules[mid] = pluginResource);
					} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin

					// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)
					// mark is as arrived and delete it from modules; the real module was requested above
					map[pseudoPluginResource.mid] = modules[mid];
					setArrived(pseudoPluginResource);
					delete modules[pseudoPluginResource.mid];
				});
				plugin.loadQ = 0;

				// step2: replace all references to any placeholder modules with real modules
				var substituteModules = function(module){
					for(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){
						replacement = map[deps[i].mid];
						if(replacement){
							deps[i] = replacement;
						}
					}
				};
				for(var p in modules){
					substituteModules(modules[p]);
				}
				forEach(execQ, substituteModules);
			},

			finishExec = function(module){
				req.trace("loader-finish-exec", [module.mid]);
				module.executed = executed;
				module.defOrder = defOrder++;
				 false  && forEach(module.provides, function(cb){ cb(); });
				if(module.loadQ){
					// the module was a plugin
					promoteModuleToPlugin(module);
					resolvePluginLoadQ(module);
				}
				// remove all occurrences of this module from the execQ
				for(i = 0; i < execQ.length;){
					if(execQ[i] === module){
						execQ.splice(i, 1);
					}else{
						i++;
					}
				}
				// delete references to synthetic modules
				if (/^require\*/.test(module.mid)) {
					delete modules[module.mid];
				}
			},

			circleTrace = [],

			execModule = function(module, strict){
				// run the dependency vector, then run the factory for module
				if(module.executed === executing){
					req.trace("loader-circular-dependency", [circleTrace.concat(module.mid).join("->")]);
					return (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);
				}
				// at this point the module is either not executed or fully executed


				if(!module.executed){
					if(!module.def){
						return abortExec;
					}
					var mid = module.mid,
						deps = module.deps || [],
						arg, argResult,
						args = [],
						i = 0;

					if( false ){
						circleTrace.push(mid);
						req.trace("loader-exec-module", ["exec", circleTrace.length, mid]);
					}

					// for circular dependencies, assume the first module encountered was executed OK
					// modules that circularly depend on a module that has not run its factory will get
					// the pre-made cjs.exports===module.result. They can take a reference to this object and/or
					// add properties to it. When the module finally runs its factory, the factory can
					// read/write/replace this object. Notice that so long as the object isn't replaced, any
					// reference taken earlier while walking the deps list is still valid.
					module.executed = executing;
					while((arg = deps[i++])){
						argResult = ((arg === cjsRequireModule) ? createRequire(module) :
										((arg === cjsExportsModule) ? module.cjs.exports :
											((arg === cjsModuleModule) ? module.cjs :
												execModule(arg, strict))));
						if(argResult === abortExec){
							module.executed = 0;
							req.trace("loader-exec-module", ["abort", mid]);
							 false  && circleTrace.pop();
							return abortExec;
						}
						args.push(argResult);
					}
					runFactory(module, args);
					finishExec(module);
					 false  && circleTrace.pop();
				}
				// at this point the module is guaranteed fully executed

				return module.result;
			},


			checkCompleteGuard = 0,

			guardCheckComplete = function(proc){
				try{
					checkCompleteGuard++;
					proc();
				}catch(e){
					// https://bugs.dojotoolkit.org/ticket/16617
					throw e;
				}finally{
					checkCompleteGuard--;
				}
				if(execComplete()){
					signal("idle", []);
				}
			},

			checkComplete = function(){
				// keep going through the execQ as long as at least one factory is executed
				// plugins, recursion, cached modules all make for many execution path possibilities
				if(checkCompleteGuard){
					return;
				}
				guardCheckComplete(function(){
					checkDojoRequirePlugin();
					for(var currentDefOrder, module, i = 0; i < execQ.length;){
						currentDefOrder = defOrder;
						module = execQ[i];
						execModule(module);
						if(currentDefOrder!=defOrder){
							// defOrder was bumped one or more times indicating something was executed (note, this indicates
							// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)
							checkDojoRequirePlugin();
							i = 0;
						}else{
							// nothing happened; check the next module in the exec queue
							i++;
						}
					}
				});
			};
	}

	var fixupUrl= typeof userConfig.fixupUrl == "function" ? userConfig.fixupUrl : function(url){
			url += ""; // make sure url is a Javascript string (some paths may be a Java string)
			return url + (cacheBust ? ((/\?/.test(url) ? "&" : "?") + cacheBust) : "");
		};



	if( 0 ){
		req.undef = function(moduleId, referenceModule){
			// In order to reload a module, it must be undefined (this routine) and then re-requested.
			// This is useful for testing frameworks (at least).
			var module = getModule(moduleId, referenceModule);
			setArrived(module);
			mix(module, {def:0, executed:0, injected:0, node:0, load:0});
		};
	}

	if( 1 ){
		if(has("dojo-loader-eval-hint-url")===undefined){
			has.add("dojo-loader-eval-hint-url", 1);
		}

		var injectPlugin = function(
				module
			){
				// injects the plugin module given by module; may have to inject the plugin itself
				var plugin = module.plugin;

				if(plugin.executed === executed && !plugin.load){
					// executed the module not knowing it was a plugin
					promoteModuleToPlugin(plugin);
				}

				var onLoad = function(def){
						module.result = def;
						setArrived(module);
						finishExec(module);
						checkComplete();
					};

				if(plugin.load){
					plugin.load(module.prid, module.req, onLoad);
				}else if(plugin.loadQ){
					plugin.loadQ.push(module);
				}else{
					// the unshift instead of push is important: we don't want plugins to execute as
					// dependencies of some other module because this may cause circles when the plugin
					// loadQ is run; also, generally, we want plugins to run early since they may load
					// several other modules and therefore can potentially unblock many modules
					plugin.loadQ = [module];
					execQ.unshift(plugin);
					injectModule(plugin);
				}
			},

			// for IE, injecting a module may result in a recursive execution if the module is in the cache

			cached = 0,

			injectingModule = 0,

			injectingCachedModule = 0,

			evalModuleText = function(text, module){
				// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit
				if(has("config-stripStrict")){
					text = text.replace(/(["'])use strict\1/g, '');
				}
				injectingCachedModule = 1;
				if(has("config-dojo-loader-catches")){
					try{
						if(text===cached){
							cached.call(null);
						}else{
							req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
						}
					}catch(e){
						signal(error, makeError("evalModuleThrew", module));
					}
				}else{
					if(text===cached){
						cached.call(null);
					}else{
						req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
					}
				}
				injectingCachedModule = 0;
			},

			injectModule = function(module){
				// Inject the module. In the browser environment, this means appending a script element into
				// the document; in other environments, it means loading a file.
				//
				// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.

				var mid = module.mid,
					url = module.url;
				if(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){
					return;
				}
				setRequested(module);

				if( 0 ){
					var viaCombo = 0;
					if(module.plugin && module.plugin.isCombo){
						// a combo plugin; therefore, must be handled by combo service
						// the prid should have already been converted to a URL (if required by the plugin) during
						// the normalize process; in any event, there is no way for the loader to know how to
						// to the conversion; therefore the third argument is zero
						req.combo.add(module.plugin.mid, module.prid, 0, req);
						viaCombo = 1;
					}else if(!module.plugin){
						viaCombo = req.combo.add(0, module.mid, module.url, req);
					}
					if(viaCombo){
						comboPending= 1;
						return;
					}
				}

				if(module.plugin){
					injectPlugin(module);
					return;
				} // else a normal module (not a plugin)


				var onLoadCallback = function(){
					runDefQ(module);
					if(module.injected !== arrived){
						// the script that contained the module arrived and has been executed yet
						// nothing was added to the defQ (so it wasn't an AMD module) and the module
						// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);
						// therefore, it must not have been a module; adjust state accordingly
						if(has("dojo-enforceDefine")){
							signal(error, makeError("noDefine", module));
							return;
						}
						setArrived(module);
						mix(module, nonModuleProps);
						req.trace("loader-define-nonmodule", [module.url]);
					}

					if( false  && legacyMode){
						// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;
						// but, if xd loading, then don't call checkComplete until out of the current sync traversal
						// in order to preserve order of execution of the dojo.required modules
						!syncExecStack.length && checkComplete();
					}else{
						checkComplete();
					}
				};
				cached = cache[mid] || cache[urlKeyPrefix + module.url];
				if(cached){
					req.trace("loader-inject", ["cache", module.mid, url]);
					evalModuleText(cached, module);
					onLoadCallback();
					return;
				}
				if( false  && legacyMode){
					if(module.isXd){
						// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}
						legacyMode==sync && (legacyMode = xd);
						// fall through and load via script injection
					}else if(module.isAmd && legacyMode!=sync){
						// fall through and load via script injection
					}else{
						// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain
						var xhrCallback = function(text){
							if(legacyMode==sync){
								// the top of syncExecStack gives the current synchronously executing module; the loader needs
								// to know this if it has to switch to async loading in the middle of evaluating a legacy module
								// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain
								// (using unshift/shift because there is no back() methods for Javascript arrays)
								syncExecStack.unshift(module);
								evalModuleText(text, module);
								syncExecStack.shift();

								// maybe the module was an AMD module
								runDefQ(module);

								// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing
								if(!module.cjs){
									setArrived(module);
									finishExec(module);
								}

								if(module.finish){
									// while synchronously evaluating this module, dojo.require was applied referencing a module
									// that had to be loaded async; therefore, the loader stopped answering all dojo.require
									// requests so they could be answered completely in the correct sequence; module.finish gives
									// the list of dojo.requires that must be re-applied once all target modules are available;
									// make a synthetic module to execute the dojo.require's in the correct order

									// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module
									// TODO: can we just leave the module.finish...what's it hurting?
									var finishMid = mid + "*finish",
										finish = module.finish;
									delete module.finish;

									def(finishMid, ["dojo", ("dojo/require!" + finish.join(",")).replace(/\./g, "/")], function(dojo){
										forEach(finish, function(mid){ dojo.require(mid); });
									});
									// unshift, not push, which causes the current traversal to be reattempted from the top
									execQ.unshift(getModule(finishMid));
								}
								onLoadCallback();
							}else{
								text = transformToAmd(module, text);
								if(text){
									evalModuleText(text, module);
									onLoadCallback();
								}else{
									// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected
									// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)
									injectingModule = module;
									req.injectUrl(fixupUrl(url), onLoadCallback, module);
									injectingModule = 0;
								}
							}
						};

						req.trace("loader-inject", ["xhr", module.mid, url, legacyMode!=sync]);
						if(has("config-dojo-loader-catches")){
							try{
								req.getText(url, legacyMode!=sync, xhrCallback);
							}catch(e){
								signal(error, makeError("xhrInjectFailed", [module, e]));
							}
						}else{
							req.getText(url, legacyMode!=sync, xhrCallback);
						}
						return;
					}
				} // else async mode or fell through in xdomain loading mode; either way, load by script injection
				req.trace("loader-inject", ["script", module.mid, url]);
				injectingModule = module;
				req.injectUrl(fixupUrl(url), onLoadCallback, module);
				injectingModule = 0;
			},

			defineModule = function(module, deps, def){
				req.trace("loader-define-module", [module.mid, deps]);

				if( 0  && module.plugin && module.plugin.isCombo){
					// the module is a plugin resource loaded by the combo service
					// note: check for module.plugin should be enough since normal plugin resources should
					// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders
					module.result = isFunction(def) ? def() : def;
					setArrived(module);
					finishExec(module);
					return module;
				}

				var mid = module.mid;
				if(module.injected === arrived){
					signal(error, makeError("multipleDefine", module));
					return module;
				}
				mix(module, {
					deps: deps,
					def: def,
					cjs: {
						id: module.mid,
						uri: module.url,
						exports: (module.result = {}),
						setExports: function(exports){
							module.cjs.exports = exports;
						},
						config:function(){
							return module.config;
						}
					}
				});

				// resolve deps with respect to this module
				for(var i = 0; deps[i]; i++){
					deps[i] = getModule(deps[i], module);
				}

				if( false  && legacyMode && !waiting[mid]){
					// the module showed up without being asked for; it was probably in a <script> element
					injectDependencies(module);
					execQ.push(module);
					checkComplete();
				}
				setArrived(module);

				if(!isFunction(def) && !deps.length){
					module.result = def;
					finishExec(module);
				}

				return module;
			},

			runDefQ = function(referenceModule, mids){
				// defQ is an array of [id, dependencies, factory]
				// mids (if any) is a vector of mids given by a combo service
				var definedModules = [],
					module, args;
				while(defQ.length){
					args = defQ.shift();
					mids && (args[0]= mids.shift());
					// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully
					// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue
					// TODO: what if no args[0] and no referenceModule
					module = (args[0] && getModule(args[0])) || referenceModule;
					definedModules.push([module, args[1], args[2]]);
				}
				consumePendingCacheInsert(referenceModule);
				forEach(definedModules, function(args){
					injectDependencies(defineModule.apply(null, args));
				});
			};
	}

	var timerId = 0,
		clearTimer = noop,
		startTimer = noop;
	if( 1 ){
		// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.
		clearTimer = function(){
			timerId && clearTimeout(timerId);
			timerId = 0;
		};

		startTimer = function(){
			clearTimer();
			if(req.waitms){
				timerId = global.setTimeout(function(){
					clearTimer();
					signal(error, makeError("timeout", waiting));
				}, req.waitms);
			}
		};
	}

	if ( 1 ) {
		// Test for IE's different way of signaling when scripts finish loading.  Note that according to
		// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the
		// IE specific code path even though it has an addEventListener() method.
		// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.
		// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()
		//  is defined in both those environments.
		has.add("ie-event-behavior", doc.attachEvent && typeof Windows === "undefined" &&
			(typeof opera === "undefined" || opera.toString() != "[object Opera]"));
	}

	if( 1  && ( 1  ||  1 )){
		var domOn = function(node, eventName, ieEventName, handler){
				// Add an event listener to a DOM node using the API appropriate for the current browser;
				// return a function that will disconnect the listener.
				if(!has("ie-event-behavior")){
					node.addEventListener(eventName, handler, false);
					return function(){
						node.removeEventListener(eventName, handler, false);
					};
				}else{
					node.attachEvent(ieEventName, handler);
					return function(){
						node.detachEvent(ieEventName, handler);
					};
				}
			},
			windowOnLoadListener = domOn(window, "load", "onload", function(){
				req.pageLoaded = 1;
				// https://bugs.dojotoolkit.org/ticket/16248
				try{
					doc.readyState!="complete" && (doc.readyState = "complete");
				}catch(e){
				}
				windowOnLoadListener();
			});

		if( 1 ){
			// if the loader is on the page, there must be at least one script element
			// getting its parent and then doing insertBefore solves the "Operation Aborted"
			// error in IE from appending to a node that isn't properly closed; see
			// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example
			// don't use scripts with type dojo/... since these may be removed; see #15809
			// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958
			var scripts = doc.getElementsByTagName("script"),
				i = 0,
				script;
			while(!insertPointSibling){
				if(!/^dojo/.test((script = scripts[i++]) && script.type)){
					insertPointSibling= script;
				}
			}

			req.injectUrl = function(url, callback, owner){
				// insert a script element to the insert-point element with src=url;
				// apply callback upon detecting the script has loaded.

				var node = owner.node = doc.createElement("script"),
					onLoad = function(e){
						e = e || window.event;
						var node = e.target || e.srcElement;
						if(e.type === "load" || /complete|loaded/.test(node.readyState)){
							loadDisconnector();
							errorDisconnector();
							callback && callback();
						}
					},
					loadDisconnector = domOn(node, "load", "onreadystatechange", onLoad),
					errorDisconnector = domOn(node, "error", "onerror", function(e){
						loadDisconnector();
						errorDisconnector();
						signal(error, makeError("scriptError: " + url, [url, e]));
					});

				node.type = "text/javascript";
				node.charset = "utf-8";
				node.src = url;
				insertPointSibling.parentNode.insertBefore(node, insertPointSibling);
				return node;
			};
		}
	}

	if( false ){
		req.log = function(){
			try{
				for(var i = 0; i < arguments.length; i++){
					console.log(arguments[i]);
				}
			}catch(e){}
		};
	}else{
		req.log = noop;
	}

	if( false ){
		var trace = req.trace = function(
			group,	// the trace group to which this application belongs
			args	// the contents of the trace
		){
			///
			// Tracing interface by group.
			//
			// Sends the contents of args to the console iff (req.trace.on && req.trace[group])

			if(trace.on && trace.group[group]){
				signal("trace", [group, args]);
				for(var arg, dump = [], text= "trace:" + group + (args.length ? (":" + args[0]) : ""), i= 1; i<args.length;){
					arg = args[i++];
					if(isString(arg)){
						text += ", " + arg;
					}else{
						dump.push(arg);
					}
				}
				req.log(text);
				dump.length && dump.push(".");
				req.log.apply(req, dump);
			}
		};
		mix(trace, {
			on:1,
			group:{},
			set:function(group, value){
				if(isString(group)){
					trace.group[group]= value;
				}else{
					mix(trace.group, group);
				}
			}
		});
		trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
		on("config", function(config){
			config.trace && trace.set(config.trace);
		});
	}else{
		req.trace = noop;
	}
	if (!has("foreign-loader")) {
		var def = function(
			mid,		  //(commonjs.moduleId, optional)
			dependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory
			factory		  //(any)
		){
			///
			// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.
			///
			//note
			// CommonJS factory scan courtesy of http://requirejs.org

			var arity = arguments.length,
				defaultDeps = ["require", "exports", "module"],
				// the predominate signature...
				args = [0, mid, dependencies];
			if(arity==1){
				args = [0, (isFunction(mid) ? defaultDeps : []), mid];
			}else if(arity==2 && isString(mid)){
				args = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];
			}else if(arity==3){
				args = [mid, dependencies, factory];
			}

			if( 0  && args[1]===defaultDeps){
				args[2].toString()
					.replace(/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg, "")
					.replace(/require\(["']([\w\!\-_\.\/]+)["']\)/g, function(match, dep){
					args[1].push(dep);
				});
			}

			req.trace("loader-define", args.slice(0, 2));
			var targetModule = args[0] && getModule(args[0]),
				module;
			if(targetModule && !waiting[targetModule.mid]){
				// given a mid that hasn't been requested; therefore, defined through means other than injecting
				// consequent to a require() or define() application; examples include defining modules on-the-fly
				// due to some code path or including a module in a script element. In any case,
				// there is no callback waiting to finish processing and nothing to trigger the defQ and the
				// dependencies are never requested; therefore, do it here.
				injectDependencies(defineModule(targetModule, args[1], args[2]));
			}else if(!has("ie-event-behavior") || ! 1  || injectingCachedModule){
				// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately
				// after script finishes being evaluated and the defQ can be run from that callback to detect the module id
				defQ.push(args);
			}else{
				// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,
				// in-order exec of onLoad with script eval (since it's IE) and must manually detect here
				targetModule = targetModule || injectingModule;
				if(!targetModule){
					for(mid in waiting){
						module = modules[mid];
						if(module && module.node && module.node.readyState === 'interactive'){
							targetModule = module;
							break;
						}
					}
					if( 0  && !targetModule){
						for(var i = 0; i<combosPending.length; i++){
							targetModule = combosPending[i];
							if(targetModule.node && targetModule.node.readyState === 'interactive'){
								break;
							}
							targetModule= 0;
						}
					}
				}
				if( 0  && isArray(targetModule)){
					injectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));
					if(!targetModule.length){
						combosPending.splice(i, 1);
					}
				}else if(targetModule){
					consumePendingCacheInsert(targetModule);
					injectDependencies(defineModule(targetModule, args[1], args[2]));
				}else{
					signal(error, makeError("ieDefineFailed", args[0]));
				}
				checkComplete();
			}
		};
		def.amd = {
			vendor:"dojotoolkit.org"
		};

		if( 0 ){
			req.def = def;
		}
	} else {
		var def = noop;
	}
	// allow config to override default implementation of named functions; this is useful for
	// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.
	// also useful for testing and monkey patching loader
	mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);

	// now that req is fully initialized and won't change, we can hook it up to the error signal
	on(error, function(arg){
		try{
			console.error(arg);
			if(arg instanceof Error){
				for(var p in arg){
					console.log(p + ":", arg[p]);
				}
				console.log(".");
			}
		}catch(e){}
	});

	// always publish these
	mix(req, {
		uid:uid,
		cache:cache,
		packs:packs
	});


	if( false ){
		mix(req, {
			// these may be interesting to look at when debugging
			paths:paths,
			aliases:aliases,
			modules:modules,
			legacyMode:legacyMode,
			execQ:execQ,
			defQ:defQ,
			waiting:waiting,

			// these are used for testing
			// TODO: move testing infrastructure to a different has feature
			packs:packs,
			mapProgs:mapProgs,
			pathsMapProg:pathsMapProg,
			listenerQueues:listenerQueues,

			// these are used by the builder (at least)
			computeMapProg:computeMapProg,
			computeAliases:computeAliases,
			runMapProg:runMapProg,
			compactPath:compactPath,
			getModuleInfo:getModuleInfo_
		});
	}

	// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are
	// *required* to define (as opposed to require, which is optional)
	if(global.define){
		if( false ){
			signal(error, makeError("defineAlreadyDefined", 0));
		}
		return;
	}else{
		global.define = def;
		global.require = req;
		if( 0 ){
			require = req;
		}
	}

	if( 0  && req.combo && req.combo.plugins){
		var plugins = req.combo.plugins,
			pluginName;
		for(pluginName in plugins){
			mix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:"executed", load:1});
		}
	}

	if( 1  && !has("foreign-loader")){
		forEach(delayedModuleConfig, function(c){ config(c); });
		var bootDeps = dojoSniffConfig.deps ||	userConfig.deps || defaultConfig.deps,
			bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
		req.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;
	}
	if(! 1 ){
		!req.async && req(["dojo"]);
		req.boot && req.apply(null, req.boot);
	}
})
(function(global){ return global.dojoConfig || global.djConfig || global.require || {}; }, {
		async:0,
		hasCache:{
				'config-selectorEngine':"lite",
				'config-tlmSiblingOfDojo':1,
				'dojo-built':1,
				'dojo-loader':1,
				dom:1,
				'host-browser':1
		},
		packages:[
				{
					 location:"../dojox",
					 name:"dojox"
				},
				{
					 location:"../dijit",
					 name:"dijit"
				},
				{
					 location:".",
					 name:"dojo"
				},
				{
					 location:"../com",
					 name:"com"
				}
		]
});require({cache:{
'dojo/_base/fx':function(){
define(["./kernel", "./config", /*===== "./declare", =====*/ "./lang", "../Evented", "./Color", "../aspect", "../sniff", "../dom", "../dom-style"],
	function(dojo, config, /*===== declare, =====*/ lang, Evented, Color, aspect, has, dom, style){
	// module:
	//		dojo/_base/fx
	// notes:
	//		Animation loosely package based on Dan Pupius' work, contributed under CLA; see
	//		http://pupius.co.uk/js/Toolkit.Drawing.js

	var _mixin = lang.mixin;

	// Module export
	var basefx = {
		// summary:
		//		This module defines the base dojo/_base/fx implementation.
	};

	var _Line = basefx._Line = function(/*int*/ start, /*int*/ end){
		// summary:
		//		Object used to generate values from a start value to an end value
		// start: int
		//		Beginning value for range
		// end: int
		//		Ending value for range
		this.start = start;
		this.end = end;
	};

	_Line.prototype.getValue = function(/*float*/ n){
		// summary:
		//		Returns the point on the line
		// n:
		//		a floating point number greater than 0 and less than 1
		return ((this.end - this.start) * n) + this.start; // Decimal
	};

	var Animation = basefx.Animation = function(args){
		// summary:
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states.
		// description:
		//		A generic animation class that fires callbacks into its handlers
		//		object at various states. Nearly all dojo animation functions
		//		return an instance of this method, usually without calling the
		//		.play() method beforehand. Therefore, you will likely need to
		//		call .play() on instances of `Animation` when one is
		//		returned.
		// args: Object
		//		The 'magic argument', mixing all the properties into this
		//		animation instance.

		_mixin(this, args);
		if(lang.isArray(this.curve)){
			this.curve = new _Line(this.curve[0], this.curve[1]);
		}

	};
	Animation.prototype = new Evented();

	lang.extend(Animation, {
		// duration: Integer
		//		The time in milliseconds the animation will take to run
		duration: 350,

	/*=====
		// curve: _Line|Array
		//		A two element array of start and end values, or a `_Line` instance to be
		//		used in the Animation.
		curve: null,

		// easing: Function?
		//		A Function to adjust the acceleration (or deceleration) of the progress
		//		across a _Line
		easing: null,
	=====*/

		// repeat: Integer?
		//		The number of times to loop the animation
		repeat: 0,

		// rate: Integer?
		//		the time in milliseconds to wait before advancing to next frame
		//		(used as a fps timer: 1000/rate = fps)
		rate: 20 /* 50 fps */,

	/*=====
		// delay: Integer?
		//		The time in milliseconds to wait before starting animation after it
		//		has been .play()'ed
		delay: null,

		// beforeBegin: Event?
		//		Synthetic event fired before a Animation begins playing (synchronous)
		beforeBegin: null,

		// onBegin: Event?
		//		Synthetic event fired as a Animation begins playing (useful?)
		onBegin: null,

		// onAnimate: Event?
		//		Synthetic event fired at each interval of the Animation
		onAnimate: null,

		// onEnd: Event?
		//		Synthetic event fired after the final frame of the Animation
		onEnd: null,

		// onPlay: Event?
		//		Synthetic event fired any time the Animation is play()'ed
		onPlay: null,

		// onPause: Event?
		//		Synthetic event fired when the Animation is paused
		onPause: null,

		// onStop: Event
		//		Synthetic event fires when the Animation is stopped
		onStop: null,

	=====*/

		_percent: 0,
		_startRepeatCount: 0,

		_getStep: function(){
			var _p = this._percent,
				_e = this.easing
			;
			return _e ? _e(_p) : _p;
		},
		_fire: function(/*Event*/ evt, /*Array?*/ args){
			// summary:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			// description:
			//		Convenience function.  Fire event "evt" and pass it the
			//		arguments specified in "args".
			//		Fires the callback in the scope of this Animation
			//		instance.
			// evt:
			//		The event to fire.
			// args:
			//		The arguments to pass to the event.
			var a = args||[];
			if(this[evt]){
				if(config.debugAtAllCosts){
					this[evt].apply(this, a);
				}else{
					try{
						this[evt].apply(this, a);
					}catch(e){
						// squelch and log because we shouldn't allow exceptions in
						// synthetic event handlers to cause the internal timer to run
						// amuck, potentially pegging the CPU. I'm not a fan of this
						// squelch, but hopefully logging will make it clear what's
						// going on
						console.error("exception in animation handler for:", evt);
						console.error(e);
					}
				}
			}
			return this; // Animation
		},

		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			// summary:
			//		Start the animation.
			// delay:
			//		How many milliseconds to delay before starting.
			// gotoStart:
			//		If true, starts the animation from the beginning; otherwise,
			//		starts it from its current position.
			// returns: Animation
			//		The instance to allow chaining.

			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(gotoStart){
				_t._stopTimer();
				_t._active = _t._paused = false;
				_t._percent = 0;
			}else if(_t._active && !_t._paused){
				return _t;
			}

			_t._fire("beforeBegin", [_t.node]);

			var de = delay || _t.delay,
				_p = lang.hitch(_t, "_play", gotoStart);

			if(de > 0){
				_t._delayTimer = setTimeout(_p, de);
				return _t;
			}
			_p();
			return _t;	// Animation
		},

		_play: function(gotoStart){
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._startTime = new Date().valueOf();
			if(_t._paused){
				_t._startTime -= _t.duration * _t._percent;
			}

			_t._active = true;
			_t._paused = false;
			var value = _t.curve.getValue(_t._getStep());
			if(!_t._percent){
				if(!_t._startRepeatCount){
					_t._startRepeatCount = _t.repeat;
				}
				_t._fire("onBegin", [value]);
			}

			_t._fire("onPlay", [value]);

			_t._cycle();
			return _t; // Animation
		},

		pause: function(){
			// summary:
			//		Pauses a running animation.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			_t._stopTimer();
			if(!_t._active){ return _t; /*Animation*/ }
			_t._paused = true;
			_t._fire("onPause", [_t.curve.getValue(_t._getStep())]);
			return _t; // Animation
		},

		gotoPercent: function(/*Decimal*/ percent, /*Boolean?*/ andPlay){
			// summary:
			//		Sets the progress of the animation.
			// percent:
			//		A percentage in decimal notation (between and including 0.0 and 1.0).
			// andPlay:
			//		If true, play the animation after setting the progress.
			var _t = this;
			_t._stopTimer();
			_t._active = _t._paused = true;
			_t._percent = percent;
			if(andPlay){ _t.play(); }
			return _t; // Animation
		},

		stop: function(/*boolean?*/ gotoEnd){
			// summary:
			//		Stops a running animation.
			// gotoEnd:
			//		If true, the animation will end.
			var _t = this;
			if(_t._delayTimer){ _t._clearTimer(); }
			if(!_t._timer){ return _t; /* Animation */ }
			_t._stopTimer();
			if(gotoEnd){
				_t._percent = 1;
			}
			_t._fire("onStop", [_t.curve.getValue(_t._getStep())]);
			_t._active = _t._paused = false;
			return _t; // Animation
		},

		destroy: function(){
			// summary:
			//		cleanup the animation
			this.stop();
		},

		status: function(){
			// summary:
			//		Returns a string token representation of the status of
			//		the animation, one of: "paused", "playing", "stopped"
			if(this._active){
				return this._paused ? "paused" : "playing"; // String
			}
			return "stopped"; // String
		},

		_cycle: function(){
			var _t = this;
			if(_t._active){
				var curr = new Date().valueOf();
				// Allow durations of 0 (instant) by setting step to 1 - see #13798
				var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / (_t.duration);

				if(step >= 1){
					step = 1;
				}
				_t._percent = step;

				// Perform easing
				if(_t.easing){
					step = _t.easing(step);
				}

				_t._fire("onAnimate", [_t.curve.getValue(step)]);

				if(_t._percent < 1){
					_t._startTimer();
				}else{
					_t._active = false;

					if(_t.repeat > 0){
						_t.repeat--;
						_t.play(null, true);
					}else if(_t.repeat == -1){
						_t.play(null, true);
					}else{
						if(_t._startRepeatCount){
							_t.repeat = _t._startRepeatCount;
							_t._startRepeatCount = 0;
						}
					}
					_t._percent = 0;
					_t._fire("onEnd", [_t.node]);
					!_t.repeat && _t._stopTimer();
				}
			}
			return _t; // Animation
		},

		_clearTimer: function(){
			// summary:
			//		Clear the play delay timer
			clearTimeout(this._delayTimer);
			delete this._delayTimer;
		}

	});

	// the local timer, stubbed into all Animation instances
	var ctr = 0,
		timer = null,
		runner = {
			run: function(){}
		};

	lang.extend(Animation, {

		_startTimer: function(){
			if(!this._timer){
				this._timer = aspect.after(runner, "run", lang.hitch(this, "_cycle"), true);
				ctr++;
			}
			if(!timer){
				timer = setInterval(lang.hitch(runner, "run"), this.rate);
			}
		},

		_stopTimer: function(){
			if(this._timer){
				this._timer.remove();
				this._timer = null;
				ctr--;
			}
			if(ctr <= 0){
				clearInterval(timer);
				timer = null;
				ctr = 0;
			}
		}

	});

	var _makeFadeable =
		has("ie") ? function(node){
			// only set the zoom if the "tickle" value would be the same as the
			// default
			var ns = node.style;
			// don't set the width to auto if it didn't already cascade that way.
			// We don't want to f anyones designs
			if(!ns.width.length && style.get(node, "width") == "auto"){
				ns.width = "auto";
			}
		} :
		function(){};

	basefx._fade = function(/*Object*/ args){
		// summary:
		//		Returns an animation that will fade the node defined by
		//		args.node from the start to end values passed (args.start
		//		args.end) (end is mandatory, start is optional)

		args.node = dom.byId(args.node);
		var fArgs = _mixin({ properties: {} }, args),
			props = (fArgs.properties.opacity = {});

		props.start = !("start" in fArgs) ?
			function(){
				return +style.get(fArgs.node, "opacity")||0;
			} : fArgs.start;
		props.end = fArgs.end;

		var anim = basefx.animateProperty(fArgs);
		aspect.after(anim, "beforeBegin", lang.partial(_makeFadeable, fArgs.node), true);

		return anim; // Animation
	};

	/*=====
	var __FadeArgs = declare(null, {
		// node: DOMNode|String
		//		The node referenced in the animation
		// duration: Integer?
		//		Duration of the animation in milliseconds.
		// easing: Function?
		//		An easing function.
	});
	=====*/

	basefx.fadeIn = function(/*__FadeArgs*/ args){
		// summary:
		//		Returns an animation that will fade node defined in 'args' from
		//		its current opacity to fully opaque.
		return basefx._fade(_mixin({ end: 1 }, args)); // Animation
	};

	basefx.fadeOut = function(/*__FadeArgs*/ args){
		// summary:
		//		Returns an animation that will fade node defined in 'args'
		//		from its current opacity to fully transparent.
		return basefx._fade(_mixin({ end: 0 }, args)); // Animation
	};

	basefx._defaultEasing = function(/*Decimal?*/ n){
		// summary:
		//		The default easing function for Animation(s)
		return 0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2);	// Decimal
	};

	var PropLine = function(properties){
		// PropLine is an internal class which is used to model the values of
		// an a group of CSS properties across an animation lifecycle. In
		// particular, the "getValue" function handles getting interpolated
		// values between start and end for a particular CSS value.
		this._properties = properties;
		for(var p in properties){
			var prop = properties[p];
			if(prop.start instanceof Color){
				// create a reusable temp color object to keep intermediate results
				prop.tempColor = new Color();
			}
		}
	};

	PropLine.prototype.getValue = function(r){
		var ret = {};
		for(var p in this._properties){
			var prop = this._properties[p],
				start = prop.start;
			if(start instanceof Color){
				ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
			}else if(!lang.isArray(start)){
				ret[p] = ((prop.end - start) * r) + start + (p != "opacity" ? prop.units || "px" : 0);
			}
		}
		return ret;
	};

	/*=====
	var __AnimArgs = declare(__FadeArgs, {
		// properties: Object?
		//		A hash map of style properties to Objects describing the transition,
		//		such as the properties of _Line with an additional 'units' property
		properties: {}

		//TODOC: add event callbacks
	});
	=====*/

	basefx.animateProperty = function(/*__AnimArgs*/ args){
		// summary:
		//		Returns an animation that will transition the properties of
		//		node defined in `args` depending how they are defined in
		//		`args.properties`
		//
		// description:
		//		Foundation of most `dojo/_base/fx`
		//		animations. It takes an object of "properties" corresponding to
		//		style properties, and animates them in parallel over a set
		//		duration.
		//
		// example:
		//		A simple animation that changes the width of the specified node.
		//	|	basefx.animateProperty({
		//	|		node: "nodeId",
		//	|		properties: { width: 400 },
		//	|	}).play();
		//		Dojo figures out the start value for the width and converts the
		//		integer specified for the width to the more expressive but
		//		verbose form `{ width: { end: '400', units: 'px' } }` which you
		//		can also specify directly. Defaults to 'px' if omitted.
		//
		// example:
		//		Animate width, height, and padding over 2 seconds... the
		//		pedantic way:
		//	|	basefx.animateProperty({ node: node, duration:2000,
		//	|		properties: {
		//	|			width: { start: '200', end: '400', units:"px" },
		//	|			height: { start:'200', end: '400', units:"px" },
		//	|			paddingTop: { start:'5', end:'50', units:"px" }
		//	|		}
		//	|	}).play();
		//		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
		//		are written using "mixed case", as the hyphen is illegal as an object key.
		//
		// example:
		//		Plug in a different easing function and register a callback for
		//		when the animation ends. Easing functions accept values between
		//		zero and one and return a value on that basis. In this case, an
		//		exponential-in curve.
		//	|	basefx.animateProperty({
		//	|		node: "nodeId",
		//	|		// dojo figures out the start value
		//	|		properties: { width: { end: 400 } },
		//	|		easing: function(n){
		//	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
		//	|		},
		//	|		onEnd: function(node){
		//	|			// called when the animation finishes. The animation
		//	|			// target is passed to this function
		//	|		}
		//	|	}).play(500); // delay playing half a second
		//
		// example:
		//		Like all `Animation`s, animateProperty returns a handle to the
		//		Animation instance, which fires the events common to Dojo FX. Use `aspect.after`
		//		to access these events outside of the Animation definition:
		//	|	var anim = basefx.animateProperty({
		//	|		node:"someId",
		//	|		properties:{
		//	|			width:400, height:500
		//	|		}
		//	|	});
		//	|	aspect.after(anim, "onEnd", function(){
		//	|		console.log("animation ended");
		//	|	}, true);
		//	|	// play the animation now:
		//	|	anim.play();
		//
		// example:
		//		Each property can be a function whose return value is substituted along.
		//		Additionally, each measurement (eg: start, end) can be a function. The node
		//		reference is passed directly to callbacks.
		//	|	basefx.animateProperty({
		//	|		node:"mine",
		//	|		properties:{
		//	|			height:function(node){
		//	|				// shrink this node by 50%
		//	|				return domGeom.position(node).h / 2
		//	|			},
		//	|			width:{
		//	|				start:function(node){ return 100; },
		//	|				end:function(node){ return 200; }
		//	|			}
		//	|		}
		//	|	}).play();
		//

		var n = args.node = dom.byId(args.node);
		if(!args.easing){ args.easing = dojo._defaultEasing; }

		var anim = new Animation(args);
		aspect.after(anim, "beforeBegin", lang.hitch(anim, function(){
			var pm = {};
			for(var p in this.properties){
				// Make shallow copy of properties into pm because we overwrite
				// some values below. In particular if start/end are functions
				// we don't want to overwrite them or the functions won't be
				// called if the animation is reused.
				if(p == "width" || p == "height"){
					this.node.display = "block";
				}
				var prop = this.properties[p];
				if(lang.isFunction(prop)){
					prop = prop(n);
				}
				prop = pm[p] = _mixin({}, (lang.isObject(prop) ? prop: { end: prop }));

				if(lang.isFunction(prop.start)){
					prop.start = prop.start(n);
				}
				if(lang.isFunction(prop.end)){
					prop.end = prop.end(n);
				}
				var isColor = (p.toLowerCase().indexOf("color") >= 0);
				function getStyle(node, p){
					// domStyle.get(node, "height") can return "auto" or "" on IE; this is more reliable:
					var v = { height: node.offsetHeight, width: node.offsetWidth }[p];
					if(v !== undefined){ return v; }
					v = style.get(node, p);
					return (p == "opacity") ? +v : (isColor ? v : parseFloat(v));
				}
				if(!("end" in prop)){
					prop.end = getStyle(n, p);
				}else if(!("start" in prop)){
					prop.start = getStyle(n, p);
				}

				if(isColor){
					prop.start = new Color(prop.start);
					prop.end = new Color(prop.end);
				}else{
					prop.start = (p == "opacity") ? +prop.start : parseFloat(prop.start);
				}
			}
			this.curve = new PropLine(pm);
		}), true);
		aspect.after(anim, "onAnimate", lang.hitch(style, "set", anim.node), true);
		return anim; // Animation
	};

	basefx.anim = function(	/*DOMNode|String*/	node,
							/*Object*/			properties,
							/*Integer?*/		duration,
							/*Function?*/		easing,
							/*Function?*/		onEnd,
							/*Integer?*/		delay){
		// summary:
		//		A simpler interface to `animateProperty()`, also returns
		//		an instance of `Animation` but begins the animation
		//		immediately, unlike nearly every other Dojo animation API.
		// description:
		//		Simpler (but somewhat less powerful) version
		//		of `animateProperty`.  It uses defaults for many basic properties
		//		and allows for positional parameters to be used in place of the
		//		packed "property bag" which is used for other Dojo animation
		//		methods.
		//
		//		The `Animation` object returned will be already playing, so
		//		calling play() on it again is (usually) a no-op.
		// node:
		//		a DOM node or the id of a node to animate CSS properties on
		// duration:
		//		The number of milliseconds over which the animation
		//		should run. Defaults to the global animation default duration
		//		(350ms).
		// easing:
		//		An easing function over which to calculate acceleration
		//		and deceleration of the animation through its duration.
		//		A default easing algorithm is provided, but you may
		//		plug in any you wish. A large selection of easing algorithms
		//		are available in `dojo/fx/easing`.
		// onEnd:
		//		A function to be called when the animation finishes
		//		running.
		// delay:
		//		The number of milliseconds to delay beginning the
		//		animation by. The default is 0.
		// example:
		//		Fade out a node
		//	|	basefx.anim("id", { opacity: 0 });
		// example:
		//		Fade out a node over a full second
		//	|	basefx.anim("id", { opacity: 0 }, 1000);
		return basefx.animateProperty({ // Animation
			node: node,
			duration: duration || Animation.prototype.duration,
			properties: properties,
			easing: easing,
			onEnd: onEnd
		}).play(delay || 0);
	};


	if( 1 ){
		_mixin(dojo, basefx);
		// Alias to drop come 2.0:
		dojo._Animation = Animation;
	}

	return basefx;
});

},
'dojo/dom-form':function(){
define(["./_base/lang", "./dom", "./io-query", "./json"], function(lang, dom, ioq, json){
	// module:
	//		dojo/dom-form

    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
        // summary:
        //		For the named property in object, set the value. If a value
        //		already exists and it is a string, convert the value to be an
        //		array of values.

        // Skip it if there is no value
        if(value === null){
            return;
        }

        var val = obj[name];
        if(typeof val == "string"){ // inline'd type check
            obj[name] = [val, value];
        }else if(lang.isArray(val)){
            val.push(value);
        }else{
            obj[name] = value;
        }
    }

	var exclude = "file|submit|image|reset|button";

	var form = {
		// summary:
		//		This module defines form-processing functions.

		fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
			// summary:
			//		Serialize a form field to a JavaScript object.
			// description:
			//		Returns the value encoded in a form field as
			//		as a string or an array of strings. Disabled form elements
			//		and unchecked radio and checkboxes are skipped.	Multi-select
			//		elements are returned as an array of string values.
			// inputNode: DOMNode|String
			// returns: Object

			var ret = null;
			inputNode = dom.byId(inputNode);
			if(inputNode){
				var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
				if(_in && type && !inputNode.disabled){
					if(type == "radio" || type == "checkbox"){
						if(inputNode.checked){
							ret = inputNode.value;
						}
					}else if(inputNode.multiple){
						ret = [];
						var nodes = [inputNode.firstChild];
						while(nodes.length){
							for(var node = nodes.pop(); node; node = node.nextSibling){
								if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
									if(node.selected){
										ret.push(node.value);
									}
								}else{
									if(node.nextSibling){
										nodes.push(node.nextSibling);
									}
									if(node.firstChild){
										nodes.push(node.firstChild);
									}
									break;
								}
							}
						}
					}else{
						ret = inputNode.value;
					}
				}
			}
			return ret; // Object
		},

		toObject: function formToObject(/*DOMNode|String*/ formNode){
			// summary:
			//		Serialize a form node to a JavaScript object.
			// description:
			//		Returns the values encoded in an HTML form as
			//		string properties in an object which it then returns. Disabled form
			//		elements, buttons, and other non-value form elements are skipped.
			//		Multi-select elements are returned as an array of string values.
			// formNode: DOMNode|String
			// example:
			//		This form:
			//		|	<form id="test_form">
			//		|		<input type="text" name="blah" value="blah">
			//		|		<input type="text" name="no_value" value="blah" disabled>
			//		|		<input type="button" name="no_value2" value="blah">
			//		|		<select type="select" multiple name="multi" size="5">
			//		|			<option value="blah">blah</option>
			//		|			<option value="thud" selected>thud</option>
			//		|			<option value="thonk" selected>thonk</option>
			//		|		</select>
			//		|	</form>
			//
			//		yields this object structure as the result of a call to
			//		formToObject():
			//
			//		|	{
			//		|		blah: "blah",
			//		|		multi: [
			//		|			"thud",
			//		|			"thonk"
			//		|		]
			//		|	};

			var ret = {}, elems = dom.byId(formNode).elements;
			for(var i = 0, l = elems.length; i < l; ++i){
				var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
				if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
					setValue(ret, _in, form.fieldToObject(item));
					if(type == "image"){
						ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
					}
				}
			}
			return ret; // Object
		},

		toQuery: function formToQuery(/*DOMNode|String*/ formNode){
			// summary:
			//		Returns a URL-encoded string representing the form passed as either a
			//		node or string ID identifying the form to serialize
			// formNode: DOMNode|String
			// returns: String

			return ioq.objectToQuery(form.toObject(formNode)); // String
		},

		toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
			// summary:
			//		Create a serialized JSON string from a form node or string
			//		ID identifying the form to serialize
			// formNode: DOMNode|String
			// prettyPrint: Boolean?
			// returns: String

			return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
		}
	};

    return form;
});

},
'dojo/promise/tracer':function(){
define([
	"../_base/lang",
	"./Promise",
	"../Evented"
], function(lang, Promise, Evented){
	"use strict";

	// module:
	//		dojo/promise/tracer

	/*=====
	return {
		// summary:
		//		Trace promise fulfillment.
		// description:
		//		Trace promise fulfillment. Calling `.trace()` or `.traceError()` on a
		//		promise enables tracing. Will emit `resolved`, `rejected` or `progress`
		//		events.

		on: function(type, listener){
			// summary:
			//		Subscribe to traces.
			// description:
			//		See `dojo/Evented#on()`.
			// type: String
			//		`resolved`, `rejected`, or `progress`
			// listener: Function
			//		The listener is passed the traced value and any arguments
			//		that were used with the `.trace()` call.
		}
	};
	=====*/

	var evented = new Evented;
	var emit = evented.emit;
	evented.emit = null;
	// Emit events asynchronously since they should not change the promise state.
	function emitAsync(args){
		setTimeout(function(){
			emit.apply(evented, args);
		}, 0);
	}

	Promise.prototype.trace = function(){
		// summary:
		//		Trace the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `trace()` is called on.

		var args = lang._toArray(arguments);
		this.then(
			function(value){ emitAsync(["resolved", value].concat(args)); },
			function(error){ emitAsync(["rejected", error].concat(args)); },
			function(update){ emitAsync(["progress", update].concat(args)); }
		);
		return this;
	};

	Promise.prototype.traceRejected = function(){
		// summary:
		//		Trace rejection of the promise.
		// description:
		//		Tracing allows you to transparently log progress,
		//		resolution and rejection of promises, without affecting the
		//		promise itself. Any arguments passed to `trace()` are
		//		emitted in trace events. See `dojo/promise/tracer` on how
		//		to handle traces.
		// returns: dojo/promise/Promise
		//		The promise instance `traceRejected()` is called on.

		var args = lang._toArray(arguments);
		this.otherwise(function(error){
			emitAsync(["rejected", error].concat(args));
		});
		return this;
	};

	return evented;
});

},
'dojo/errors/RequestError':function(){
define(['./create'], function(create){
	// module:
	//		dojo/errors/RequestError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestError", function(message, response){
		this.response = response;
	});
});

},
'dojo/_base/html':function(){
define(["./kernel", "../dom", "../dom-style", "../dom-attr", "../dom-prop", "../dom-class", "../dom-construct", "../dom-geometry"], function(dojo, dom, style, attr, prop, cls, ctr, geom){
	// module:
	//		dojo/dom

	/*=====
	return {
		// summary:
		//		This module is a stub for the core dojo DOM API.
	};
	=====*/

	// mix-in dom
	dojo.byId = dom.byId;
	dojo.isDescendant = dom.isDescendant;
	dojo.setSelectable = dom.setSelectable;

	// mix-in dom-attr
	dojo.getAttr = attr.get;
	dojo.setAttr = attr.set;
	dojo.hasAttr = attr.has;
	dojo.removeAttr = attr.remove;
	dojo.getNodeProp = attr.getNodeProp;

	dojo.attr = function(node, name, value){
		// summary:
		//		Gets or sets an attribute on an HTML element.
		// description:
		//		Handles normalized getting and setting of attributes on DOM
		//		Nodes. If 2 arguments are passed, and a the second argument is a
		//		string, acts as a getter.
		//
		//		If a third argument is passed, or if the second argument is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to get or set the attribute on
		// name: String|Object
		//		the name of the attribute to get or set.
		// value: String?
		//		The value to set for the attribute
		// returns:
		//		when used as a getter, the value of the requested attribute
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, the DOM node
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	dojo.attr(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.attr("nodeId", "foo");
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	dojo.attr("nodeId", "tabIndex", 3);
		//	|
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.attr("formId", {
		//	|		"foo": "bar",
		//	|		"tabIndex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		// example:
		//	Style is s special case: Only set with an object hash of styles
		//	|	dojo.attr("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		// example:
		//	Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.attr("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style()` in this case:
		//	|	dojo.style("someNode", obj);

		if(arguments.length == 2){
			return attr[typeof name == "string" ? "get" : "set"](node, name);
		}
		return attr.set(node, name, value);
	};

	// mix-in dom-class
	dojo.hasClass = cls.contains;
	dojo.addClass = cls.add;
	dojo.removeClass = cls.remove;
	dojo.toggleClass = cls.toggle;
	dojo.replaceClass = cls.replace;

	// mix-in dom-construct
	dojo._toDom = dojo.toDom = ctr.toDom;
	dojo.place = ctr.place;
	dojo.create = ctr.create;
	dojo.empty = function(node){ ctr.empty(node); };
	dojo._destroyElement = dojo.destroy = function(node){ ctr.destroy(node); };

	// mix-in dom-geometry
	dojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;
	dojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;
	dojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;
	dojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;
	dojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;
	dojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;
	dojo.setMarginBox = geom.setMarginBox;
	dojo._getContentBox = dojo.getContentBox = geom.getContentBox;
	dojo.setContentSize = geom.setContentSize;
	dojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;
	dojo._docScroll = dojo.docScroll = geom.docScroll;
	dojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;
	dojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;
	dojo.position = geom.position;

	dojo.marginBox = function marginBox(/*DomNode|String*/node, /*Object?*/box){
		// summary:
		//		Getter/setter for the margin-box of node.
		// description:
		//		Getter/setter for the margin-box of node.
		//		Returns an object in the expected format of box (regardless
		//		if box is passed). The object might look like:
		//		`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a margin width of 300px and a margin-height of
		//		150px.
		// node:
		//		id or reference to DOM Node to get/set box for
		// box:
		//		If passed, denotes that dojo.marginBox() should
		//		update/set the margin box for node. Box is an object in the
		//		above format. All properties are optional if passed.
		// example:
		//		Retrieve the margin box of a passed node
		//	|	var box = dojo.marginBox("someNodeId");
		//	|	console.dir(box);
		//
		// example:
		//		Set a node's margin box to the size of another node
		//	|	var box = dojo.marginBox("someNodeId");
		//	|	dojo.marginBox("someOtherNode", box);
		return box ? geom.setMarginBox(node, box) : geom.getMarginBox(node); // Object
	};

	dojo.contentBox = function contentBox(/*DomNode|String*/node, /*Object?*/box){
		// summary:
		//		Getter/setter for the content-box of node.
		// description:
		//		Returns an object in the expected format of box (regardless if box is passed).
		//		The object might look like:
		//		`{ l: 50, t: 200, w: 300: h: 150 }`
		//		for a node offset from its parent 50px to the left, 200px from
		//		the top with a content width of 300px and a content-height of
		//		150px. Note that the content box may have a much larger border
		//		or margin box, depending on the box model currently in use and
		//		CSS values set/inherited for node.
		//		While the getter will return top and left values, the
		//		setter only accepts setting the width and height.
		// node:
		//		id or reference to DOM Node to get/set box for
		// box:
		//		If passed, denotes that dojo.contentBox() should
		//		update/set the content box for node. Box is an object in the
		//		above format, but only w (width) and h (height) are supported.
		//		All properties are optional if passed.
		return box ? geom.setContentSize(node, box) : geom.getContentBox(node); // Object
	};

	dojo.coords = function(/*DomNode|String*/node, /*Boolean?*/includeScroll){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//
		//		Returns an object that measures margin-box (w)idth/(h)eight
		//		and absolute position x/y of the border-box. Also returned
		//		is computed (l)eft and (t)op values in pixels from the
		//		node's offsetParent as returned from marginBox().
		//		Return value will be in the form:
		//|			{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
		//		Does not act as a setter. If includeScroll is passed, the x and
		//		y params are affected as one would expect in dojo.position().
		dojo.deprecated("dojo.coords()", "Use dojo.position() or dojo.marginBox().");
		node = dom.byId(node);
		var s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);
		var abs = geom.position(node, includeScroll);
		mb.x = abs.x;
		mb.y = abs.y;
		return mb;	// Object
	};

	// mix-in dom-prop
	dojo.getProp = prop.get;
	dojo.setProp = prop.set;

	dojo.prop = function(/*DomNode|String*/node, /*String|Object*/name, /*String?*/value){
		// summary:
		//		Gets or sets a property on an HTML element.
		// description:
		//		Handles normalized getting and setting of properties on DOM
		//		Nodes. If 2 arguments are passed, and a the second argument is a
		//		string, acts as a getter.
		//
		//		If a third argument is passed, or if the second argument is a
		//		map of attributes, acts as a setter.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node:
		//		id or reference to the element to get or set the property on
		// name:
		//		the name of the property to get or set.
		// value:
		//		The value to set for the property
		// returns:
		//		when used as a getter, the value of the requested property
		//		or null if that attribute does not have a specified or
		//		default value;
		//
		//		when used as a setter, the DOM node
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	dojo.prop(dojo.byId("nodeId"), "foo");
		//	|	// or we can just pass the id:
		//	|	dojo.prop("nodeId", "foo");
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	dojo.prop("nodeId", "tabIndex", 3);
		//	|
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	dojo.prop("formId", {
		//	|		"foo": "bar",
		//	|		"tabIndex": -1,
		//	|		"method": "POST",
		//	|		"onsubmit": function(e){
		//	|			// stop submitting the form. Note that the IE behavior
		//	|			// of returning true or false will have no effect here
		//	|			// since our handler is connect()ed to the built-in
		//	|			// onsubmit behavior and so we need to use
		//	|			// dojo.stopEvent() to ensure that the submission
		//	|			// doesn't proceed.
		//	|			dojo.stopEvent(e);
		//	|
		//	|			// submit the form with Ajax
		//	|			dojo.xhrPost({ form: "formId" });
		//	|		}
		//	|	});
		//
		// example:
		//		Style is s special case: Only set with an object hash of styles
		//	|	dojo.prop("someNode",{
		//	|		id:"bar",
		//	|		style:{
		//	|			width:"200px", height:"100px", color:"#000"
		//	|		}
		//	|	});
		//
		// example:
		//		Again, only set style as an object hash of styles:
		//	|	var obj = { color:"#fff", backgroundColor:"#000" };
		//	|	dojo.prop("someNode", "style", obj);
		//	|
		//	|	// though shorter to use `dojo.style()` in this case:
		//	|	dojo.style("someNode", obj);

		if(arguments.length == 2){
			return prop[typeof name == "string" ? "get" : "set"](node, name);
		}
		// setter
		return prop.set(node, name, value);
	};

	// mix-in dom-style
	dojo.getStyle = style.get;
	dojo.setStyle = style.set;
	dojo.getComputedStyle = style.getComputedStyle;
	dojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;

	dojo.style = function(node, name, value){
		// summary:
		//		Accesses styles on a node. If 2 arguments are
		//		passed, acts as a getter. If 3 arguments are passed, acts
		//		as a setter.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo.marginBox()`,
		//		`dojo.contentBox()` or `dojo.position()`.
		// node: DOMNode|String
		//		id or reference to node to get/set style for
		// name: String|Object?
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		// returns:
		//		when used as a getter, return the computed style of the node if passing in an ID or node,
		//		or return the normalized, computed value for the property when passing in a node and a style property
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	dojo.style("thinger");
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	dojo.style("thinger", "opacity"); // 1 by default
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	dojo.style("thinger", "opacity", 0.5); // == 0.5
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	dojo.style("thinger", {
		//	|		"opacity": 0.5,
		//	|		"border": "3px solid black",
		//	|		"height": "300px"
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	dojo.style("thinger",{
		//	|		fontSize:"14pt",
		//	|		letterSpacing:"1.2em"
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo.style() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	dojo.query(".someClassName").style("visibility","hidden");
		//	|	// or
		//	|	dojo.query("#baz > div").style({
		//	|		opacity:0.75,
		//	|		fontSize:"13pt"
		//	|	});

		switch(arguments.length){
			case 1:
				return style.get(node);
			case 2:
				return style[typeof name == "string" ? "get" : "set"](node, name);
		}
		// setter
		return style.set(node, name, value);
	};

	return dojo;
});

},
'dojo/_base/kernel':function(){
define(["../global", "../has", "./config", "require", "module"], function(global, has, config, require, module){
	// module:
	//		dojo/_base/kernel

	// This module is the foundational module of the dojo boot sequence; it defines the dojo object.

	var
		// loop variables for this module
		i, p,

		// create dojo, dijit, and dojox
		// FIXME: in 2.0 remove dijit, dojox being created by dojo
		dijit = {},
		dojox = {},
		dojo = {
			// summary:
			//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.

			// notice dojo takes ownership of the value of the config module
			config:config,
			global:global,
			dijit:dijit,
			dojox:dojox
		};


	// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
	// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
	// unique names in the global space.
	//
	// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
	// where global when in fact they are either global under different names or not global at all. In v1.6-, the
	// config variable "scopeMap" was used to map names as used within a module to global names. This has been
	// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
	// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
	//
	// The following computations contort the packageMap for this dojo instance into a scopeMap.
	var scopeMap =
			// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
			// always map dojo, dijit, and dojox
			{
				dojo:["dojo", dojo],
				dijit:["dijit", dijit],
				dojox:["dojox", dojox]
			},

		packageMap =
			// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
			(require.map && require.map[module.id.match(/[^\/]+/)[0]]),

		item;


	// process all mapped top-level names for this instance of dojo
	for(p in packageMap){
		if(scopeMap[p]){
			// mapped dojo, dijit, or dojox
			scopeMap[p][0] = packageMap[p];
		}else{
			// some other top-level name
			scopeMap[p] = [packageMap[p], {}];
		}
	}

	// publish those names to _scopeName and, optionally, the global namespace
	for(p in scopeMap){
		item = scopeMap[p];
		item[1]._scopeName = item[0];
		if(!config.noGlobals){
			global[item[0]] = item[1];
		}
	}
	dojo.scopeMap = scopeMap;

	/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/

	// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
	dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
	dojo.isAsync = ! 1  || require.async;
	dojo.locale = config.locale;

	var rev = "$Rev:$".match(/[0-9a-f]{7,}/);
	dojo.version = {
		// summary:
		//		Version number of the Dojo Toolkit
		// description:
		//		Hash about the version, including
		//
		//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
		//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
		//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
		//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
		//		- revision: Number: The Git rev from which dojo was pulled

		major: 1, minor: 15, patch: 0, flag: "",
		revision: rev ? rev[0] : NaN,
		toString: function(){
			var v = dojo.version;
			return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
		}
	};

	// If  1  is truthy, then as a dojo module is defined it should push it's definitions
	// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
	// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
	// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
	 1 || has.add("extend-dojo", 1);

	if(!has("csp-restrictions")){
		(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
	}
	/*=====
	dojo.eval = function(scriptText){
		// summary:
		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
		// description:
		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
		//		that support indirect eval.
		//
		//		As usual, IE does not. On IE, the only way to implement global eval is to
		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
		//
		//		dojo.eval("var pi = 3.14;");
		//
		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
		//		to define a global variable using dojo.eval, write something like
		//
		//		dojo.eval("window.pi = 3.14;")
		// scriptText:
		//		The text to evaluation.
		// returns:
		//		The result of the evaluation. Often `undefined`
	};
	=====*/


	if( 0 ){
		dojo.exit = function(exitcode){
			quit(exitcode);
		};
	}else{
		dojo.exit = function(){
		};
	}

	if(!has("host-webworker")){
		// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100
		 1 || has.add("dojo-guarantee-console",
			// ensure that console.log, console.warn, etc. are defined
			1
		);
	}

	if( 1 ){
		// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197
		has.add("console-as-object", function () {
			return Function.prototype.bind && console && typeof console.log === "object";
		});

		typeof console != "undefined" || (console = {});  // intentional assignment
		//	Be careful to leave 'log' always at the end
		var cn = [
			"assert", "count", "debug", "dir", "dirxml", "error", "group",
			"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
			"trace", "warn", "log"
		];
		var tn;
		i = 0;
		while((tn = cn[i++])){
			if(!console[tn]){
				(function(){
					var tcn = tn + "";
					console[tcn] = ('log' in console) ? function(){
						var a = Array.prototype.slice.call(arguments);
						a.unshift(tcn + ":");
						console["log"](a.join(" "));
					} : function(){};
					console[tcn]._fake = true;
				})();
			}else if(has("console-as-object")){
				console[tn] = Function.prototype.bind.call(console[tn], console);
			}
		}
	}

	has.add("dojo-debug-messages",
		// include dojo.deprecated/dojo.experimental implementations
		!!config.isDebug
	);
	dojo.deprecated = dojo.experimental =  function(){};
	if(has("dojo-debug-messages")){
		dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
			// summary:
			//		Log a debug message to indicate that a behavior has been
			//		deprecated.
			// behaviour: String
			//		The API or behavior being deprecated. Usually in the form
			//		of "myApp.someFunction()".
			// extra: String?
			//		Text to append to the message. Often provides advice on a
			//		new function or facility to achieve the same goal during
			//		the deprecation period.
			// removal: String?
			//		Text to indicate when in the future the behavior will be
			//		removed. Usually a version number.
			// example:
			//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");

			var message = "DEPRECATED: " + behaviour;
			if(extra){ message += " " + extra; }
			if(removal){ message += " -- will be removed in version: " + removal; }
			console.warn(message);
		};

		dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
			// summary:
			//		Marks code as experimental.
			// description:
			//		This can be used to mark a function, file, or module as
			//		experimental.	 Experimental code is not ready to be used, and the
			//		APIs are subject to change without notice.	Experimental code may be
			//		completed deleted without going through the normal deprecation
			//		process.
			// moduleName: String
			//		The name of a module, or the name of a module file or a specific
			//		function
			// extra: String?
			//		some additional message for the user
			// example:
			//	| dojo.experimental("dojo.data.Result");
			// example:
			//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");

			var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
			if(extra){ message += " " + extra; }
			console.warn(message);
		};
	}

	 1 || has.add("dojo-modulePaths",
		// consume dojo.modulePaths processing
		1
	);
	if( 1 ){
		// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
		// this is the v1.6- behavior.
		if(config.modulePaths){
			dojo.deprecated("dojo.modulePaths", "use paths configuration");
			var paths = {};
			for(p in config.modulePaths){
				paths[p.replace(/\./g, "/")] = config.modulePaths[p];
			}
			require({paths:paths});
		}
	}

	 1 || has.add("dojo-moduleUrl",
		// include dojo.moduleUrl
		1
	);
	if( 1 ){
		dojo.moduleUrl = function(/*String*/module, /*String?*/url){
			// summary:
			//		Returns a URL relative to a module.
			// example:
			//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
			//	|	console.dir(pngPath); // list the object properties
			//	|	// create an image and set it's source to pngPath's value:
			//	|	var img = document.createElement("img");
			//	|	img.src = pngPath;
			//	|	// add our image to the document
			//	|	dojo.body().appendChild(img);
			// example:
			//		you may de-reference as far as you like down the package
			//		hierarchy.  This is sometimes handy to avoid lengthy relative
			//		urls or for building portable sub-packages. In this example,
			//		the `acme.widget` and `acme.util` directories may be located
			//		under different roots (see `dojo.registerModulePath`) but the
			//		the modules which reference them can be unaware of their
			//		relative locations on the filesystem:
			//	|	// somewhere in a configuration block
			//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
			//	|	dojo.registerModulePath("acme.util", "../../util");
			//	|
			//	|	// ...
			//	|
			//	|	// code in a module using acme resources
			//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
			//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");

			dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");

			// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
			// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
			// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
			// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
			var result = null;
			if(module){
				result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
			}
			return result;
		};
	}

	dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling

	return dojo;
});

},
'dojo/io-query':function(){
define(["./_base/lang"], function(lang){

	// module:
	//		dojo/io-query

	var backstop = {};

	return {
		// summary:
		//		This module defines query string processing functions.

		objectToQuery: function objectToQuery(/*Object*/ map){
			// summary:
			//		takes a name/value mapping object and returns a string representing
			//		a URL-encoded version of that object.
			// example:
			//		this object:
			//
			//	|	{
			//	|		blah: "blah",
			//	|		multi: [
			//	|			"thud",
			//	|			"thonk"
			//	|		]
			//	|	};
			//
			//		yields the following query string:
			//
			//	|	"blah=blah&multi=thud&multi=thonk"

			// FIXME: need to implement encodeAscii!!
			var enc = encodeURIComponent, pairs = [];
			for(var name in map){
				var value = map[name];
				if(value != backstop[name]){
					var assign = enc(name) + "=";
					if(lang.isArray(value)){
						for(var i = 0, l = value.length; i < l; ++i){
							pairs.push(assign + enc(value[i]));
						}
					}else{
						pairs.push(assign + enc(value));
					}
				}
			}
			return pairs.join("&"); // String
		},

		queryToObject: function queryToObject(/*String*/ str){
			// summary:
			//		Create an object representing a de-serialized query section of a
			//		URL. Query keys with multiple values are returned in an array.
			//
			// example:
			//		This string:
			//
			//	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
			//
			//		results in this object structure:
			//
			//	|		{
			//	|			foo: [ "bar", "baz" ],
			//	|			thinger: " spaces =blah",
			//	|			zonk: "blarg"
			//	|		}
			//
			//		Note that spaces and other urlencoded entities are correctly
			//		handled.

        	var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
			for(var i = 0, l = qp.length, item; i < l; ++i){
				item = qp[i];
				if(item.length){
					var s = item.indexOf("=");
					if(s < 0){
						name = dec(item);
						val = "";
					}else{
						name = dec(item.slice(0, s));
						val = dec(item.slice(s + 1));
					}
					if(typeof ret[name] == "string"){ // inline'd type check
						ret[name] = [ret[name]];
					}

					if(lang.isArray(ret[name])){
						ret[name].push(val);
					}else{
						ret[name] = val;
					}
				}
			}
			return ret; // Object
		}
	};
});
},
'dojo/_base/Deferred':function(){
define([
	"./kernel",
	"../Deferred",
	"../promise/Promise",
	"../errors/CancelError",
	"../has",
	"./lang",
	"../when"
], function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
	// module:
	//		dojo/_base/Deferred

	var mutator = function(){};
	var freeze = Object.freeze || function(){};
	// A deferred provides an API for creating and resolving a promise.
	var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
		// summary:
		//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
		//		New code should use dojo/Deferred instead.
		// description:
		//		The Deferred API is based on the concept of promises that provide a
		//		generic interface into the eventual completion of an asynchronous action.
		//		The motivation for promises fundamentally is about creating a
		//		separation of concerns that allows one to achieve the same type of
		//		call patterns and logical data flow in asynchronous code as can be
		//		achieved in synchronous code. Promises allows one
		//		to be able to call a function purely with arguments needed for
		//		execution, without conflating the call with concerns of whether it is
		//		sync or async. One shouldn't need to alter a call's arguments if the
		//		implementation switches from sync to async (or vice versa). By having
		//		async functions return promises, the concerns of making the call are
		//		separated from the concerns of asynchronous interaction (which are
		//		handled by the promise).
		//
		//		The Deferred is a type of promise that provides methods for fulfilling the
		//		promise with a successful result or an error. The most important method for
		//		working with Dojo's promises is the then() method, which follows the
		//		CommonJS proposed promise API. An example of using a Dojo promise:
		//
		//		|	var resultingPromise = someAsyncOperation.then(function(result){
		//		|		... handle result ...
		//		|	},
		//		|	function(error){
		//		|		... handle error ...
		//		|	});
		//
		//		The .then() call returns a new promise that represents the result of the
		//		execution of the callback. The callbacks will never affect the original promises value.
		//
		//		The Deferred instances also provide the following functions for backwards compatibility:
		//
		//		- addCallback(handler)
		//		- addErrback(handler)
		//		- callback(result)
		//		- errback(result)
		//
		//		Callbacks are allowed to return promises themselves, so
		//		you can build complicated sequences of events with ease.
		//
		//		The creator of the Deferred may specify a canceller.  The canceller
		//		is a function that will be called if Deferred.cancel is called
		//		before the Deferred fires. You can use this to implement clean
		//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
		//		deferred with a CancelledError (unless your canceller returns
		//		another kind of error), so the errbacks should be prepared to
		//		handle that error for cancellable Deferreds.
		// example:
		//	|	var deferred = new Deferred();
		//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		//	|	return deferred;
		// example:
		//		Deferred objects are often used when making code asynchronous. It
		//		may be easiest to write functions in a synchronous manner and then
		//		split code using a deferred to trigger a response to a long-lived
		//		operation. For example, instead of register a callback function to
		//		denote when a rendering operation completes, the function can
		//		simply return a deferred:
		//
		//		|	// callback style:
		//		|	function renderLotsOfData(data, callback){
		//		|		var success = false
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			success = true;
		//		|		}catch(e){ }
		//		|		if(callback){
		//		|			callback(success);
		//		|		}
		//		|	}
		//
		//		|	// using callback style
		//		|	renderLotsOfData(someDataObj, function(success){
		//		|		// handles success or failure
		//		|		if(!success){
		//		|			promptUserToRecover();
		//		|		}
		//		|	});
		//		|	// NOTE: no way to add another callback here!!
		// example:
		//		Using a Deferred doesn't simplify the sending code any, but it
		//		provides a standard interface for callers and senders alike,
		//		providing both with a simple way to service multiple callbacks for
		//		an operation and freeing both sides from worrying about details
		//		such as "did this get called already?". With Deferreds, new
		//		callbacks can be added at any time.
		//
		//		|	// Deferred style:
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		try{
		//		|			for(var x in data){
		//		|				renderDataitem(data[x]);
		//		|			}
		//		|			d.callback(true);
		//		|		}catch(e){
		//		|			d.errback(new Error("rendering failed"));
		//		|		}
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//		|	// NOTE: addErrback and addCallback both return the Deferred
		//		|	// again, so we could chain adding callbacks or save the
		//		|	// deferred for later should we need to be notified again.
		// example:
		//		In this example, renderLotsOfData is synchronous and so both
		//		versions are pretty artificial. Putting the data display on a
		//		timeout helps show why Deferreds rock:
		//
		//		|	// Deferred style and async func
		//		|	function renderLotsOfData(data){
		//		|		var d = new Deferred();
		//		|		setTimeout(function(){
		//		|			try{
		//		|				for(var x in data){
		//		|					renderDataitem(data[x]);
		//		|				}
		//		|				d.callback(true);
		//		|			}catch(e){
		//		|				d.errback(new Error("rendering failed"));
		//		|			}
		//		|		}, 100);
		//		|		return d;
		//		|	}
		//
		//		|	// using Deferred style
		//		|	renderLotsOfData(someDataObj).then(null, function(){
		//		|		promptUserToRecover();
		//		|	});
		//
		//		Note that the caller doesn't have to change his code at all to
		//		handle the asynchronous case.

		var result, finished, canceled, fired, isError, head, nextListener;
		var promise = (this.promise = new Promise());

		function complete(value){
			if(finished){
				throw new Error("This deferred has already been resolved");
			}
			result = value;
			finished = true;
			notify();
		}
		function notify(){
			var mutated;
			while(!mutated && nextListener){
				var listener = nextListener;
				nextListener = nextListener.next;
				if((mutated = (listener.progress == mutator))){ // assignment and check
					finished = false;
				}

				var func = (isError ? listener.error : listener.resolved);
				if(has("config-useDeferredInstrumentation")){
					if(isError && NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(result, !!func);
					}
				}
				if(func){
					try{
						var newResult = func(result);
						if (newResult && typeof newResult.then === "function"){
							newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
							continue;
						}
						var unchanged = mutated && newResult === undefined;
						if(mutated && !unchanged){
							isError = newResult instanceof Error;
						}
						listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
					}catch(e){
						listener.deferred.reject(e);
					}
				}else{
					if(isError){
						listener.deferred.reject(result);
					}else{
						listener.deferred.resolve(result);
					}
				}
			}
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fired == 0;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fired == 1;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return fired >= 0;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		// calling resolve will resolve the promise
		this.resolve = this.callback = function(value){
			// summary:
			//		Fulfills the Deferred instance successfully with the provide value
			this.fired = fired = 0;
			this.results = [value, null];
			complete(value);
		};


		// calling error will indicate that the promise failed
		this.reject = this.errback = function(error){
			// summary:
			//		Fulfills the Deferred instance as an error with the provided error
			isError = true;
			this.fired = fired = 1;
			if(has("config-useDeferredInstrumentation")){
				if(NewDeferred.instrumentRejected){
					NewDeferred.instrumentRejected(error, !!nextListener);
				}
			}
			complete(error);
			this.results = [null, error];
		};
		// call progress to provide updates on the progress on the completion of the promise
		this.progress = function(update){
			// summary:
			//		Send progress events to all listeners
			var listener = nextListener;
			while(listener){
				var progress = listener.progress;
				progress && progress(update);
				listener = listener.next;
			}
		};
		this.addCallbacks = function(callback, errback){
			// summary:
			//		Adds callback and error callback for this deferred instance.
			// callback: Function?
			//		The callback attached to this deferred object.
			// errback: Function?
			//		The error callback attached to this deferred object.
			// returns:
			//		Returns this deferred object.
			this.then(callback, errback, mutator);
			return this;	// Deferred
		};
		// provide the implementation of the promise
		promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
			// summary:
			//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
			//		completion of a promise. The fulfilledHandler is called when the promise
			//		is fulfilled. The errorHandler is called when a promise fails. The
			//		progressHandler is called for progress events. All arguments are optional
			//		and non-function values are ignored. The progressHandler is not only an
			//		optional argument, but progress events are purely optional. Promise
			//		providers are not required to ever create progress events.
			//
			//		This function will return a new promise that is fulfilled when the given
			//		fulfilledHandler or errorHandler callback is finished. This allows promise
			//		operations to be chained together. The value returned from the callback
			//		handler is the fulfillment value for the returned promise. If the callback
			//		throws an error, the returned promise will be moved to failed state.
			//
			// returns:
			//		Returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			// example:
			//		An example of using a CommonJS compliant promise:
			//		|	asyncComputeTheAnswerToEverything().
			//		|		then(addTwo).
			//		|		then(printResult, onError);
			//		|	>44
			//
			var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
			var listener = {
				resolved: resolvedCallback,
				error: errorCallback,
				progress: progressCallback,
				deferred: returnDeferred
			};
			if(nextListener){
				head = head.next = listener;
			}
			else{
				nextListener = head = listener;
			}
			if(finished){
				notify();
			}
			return returnDeferred.promise; // Promise
		};
		var deferred = this;
		promise.cancel = this.cancel = function(){
			// summary:
			//		Cancels the asynchronous operation
			if(!finished){
				var error = canceller && canceller(deferred);
				if(!finished){
					if (!(error instanceof Error)){
						error = new CancelError(error);
					}
					error.log = false;
					deferred.reject(error);
				}
			}
			canceled = true;
		};
		freeze(promise);
	};
	lang.extend(Deferred, {
		addCallback: function(/*Function*/ callback){
			// summary:
			//		Adds successful callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addErrback: function(/*Function*/ errback){
			// summary:
			//		Adds error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
		},

		addBoth: function(/*Function*/ callback){
			// summary:
			//		Add handler as both successful callback and error callback for this deferred instance.
			// returns:
			//		Returns this deferred object.
			var enclosed = lang.hitch.apply(dojo, arguments);
			return this.addCallbacks(enclosed, enclosed);	// Deferred
		},
		fired: -1
	});

	Deferred.when = dojo.when = when;

	return Deferred;
});

},
'dojo/NodeList-dom':function(){
define(["./_base/kernel", "./query", "./_base/array", "./_base/lang", "./dom-class", "./dom-construct", "./dom-geometry", "./dom-attr", "./dom-style"], function(dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle){

	// module:
	//		dojo/NodeList-dom.js

	/*=====
	 return function(){
		 // summary:
		 //		Adds DOM related methods to NodeList, and returns NodeList constructor.
	 };
	 =====*/

	var magicGuard = function(a){
		// summary:
		//		the guard function for dojo/dom-attr() and dojo/dom-style()
		return a.length == 1 && (typeof a[0] == "string"); // inline'd type check
	};

	var orphan = function(node){
		// summary:
		//		function to orphan nodes
		var p = node.parentNode;
		if(p){
			p.removeChild(node);
		}
	};
	// FIXME: should we move orphan() to dojo/_base/html?

	var NodeList = query.NodeList,
		awc = NodeList._adaptWithCondition,
		aafe = NodeList._adaptAsForEach,
		aam = NodeList._adaptAsMap;

	function getSet(module){
		return function(node, name, value){
			if(arguments.length == 2){
				return module[typeof name == "string" ? "get" : "set"](node, name);
			}
			// setter
			return module.set(node, name, value);
		};
	}

	lang.extend(NodeList, {
		_normalize: function(/*String||Element||Object||NodeList*/content, /*DOMNode?*/refNode){
			// summary:
			//		normalizes data to an array of items to insert.
			// description:
			//		If content is an object, it can have special properties "template" and
			//		"parse". If "template" is defined, then the template value is run through
			//		dojo/string.substitute (if dojo/string.substitute() has been required elsewhere),
			//		or if templateFunc is a function on the content, that function will be used to
			//		transform the template into a final string to be used for for passing to dojo/dom-construct.toDom().
			//		If content.parse is true, then it is remembered for later, for when the content
			//		nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
			//		(if dojo/parser has been required elsewhere).

			//Wanted to just use a DocumentFragment, but for the array/NodeList
			//case that meant using cloneNode, but we may not want that.
			//Cloning should only happen if the node operations span
			//multiple refNodes. Also, need a real array, not a NodeList from the
			//DOM since the node movements could change those NodeLists.

			var parse = content.parse === true;

			//Do we have an object that needs to be run through a template?
			if(typeof content.template == "string"){
				var templateFunc = content.templateFunc || (dojo.string && dojo.string.substitute);
				content = templateFunc ? templateFunc(content.template, content) : content;
			}

			var type = (typeof content);
			if(type == "string" || type == "number"){
				content = domCtr.toDom(content, (refNode && refNode.ownerDocument));
				if(content.nodeType == 11){
					//DocumentFragment. It cannot handle cloneNode calls, so pull out the children.
					content = lang._toArray(content.childNodes);
				}else{
					content = [content];
				}
			}else if(!lang.isArrayLike(content)){
				content = [content];
			}else if(!lang.isArray(content)){
				//To get to this point, content is array-like, but
				//not an array, which likely means a DOM NodeList. Convert it now.
				content = lang._toArray(content);
			}

			//Pass around the parse info
			if(parse){
				content._runParse = true;
			}
			return content; //Array
		},

		_cloneNode: function(/*DOMNode*/ node){
			// summary:
			//		private utility to clone a node. Not very interesting in the vanilla
			//		dojo/NodeList case, but delegates could do interesting things like
			//		clone event handlers if that is derivable from the node.
			return node.cloneNode(true);
		},

		_place: function(/*Array*/ary, /*DOMNode*/refNode, /*String*/position, /*Boolean*/useClone){
			// summary:
			//		private utility to handle placing an array of nodes relative to another node.
			// description:
			//		Allows for cloning the nodes in the array, and for
			//		optionally parsing widgets, if ary._runParse is true.

			//Avoid a disallowed operation if trying to do an innerHTML on a non-element node.
			if(refNode.nodeType != 1 && position == "only"){
				return;
			}
			var rNode = refNode, tempNode;

			//Always cycle backwards in case the array is really a
			//DOM NodeList and the DOM operations take it out of the live collection.
			var length = ary.length;
			for(var i = length - 1; i >= 0; i--){
				var node = (useClone ? this._cloneNode(ary[i]) : ary[i]);

				//If need widget parsing, use a temp node, instead of waiting after inserting into
				//real DOM because we need to start widget parsing at one node up from current node,
				//which could cause some already parsed widgets to be parsed again.
				if(ary._runParse && dojo.parser && dojo.parser.parse){
					if(!tempNode){
						tempNode = rNode.ownerDocument.createElement("div");
					}
					tempNode.appendChild(node);
					dojo.parser.parse(tempNode);
					node = tempNode.firstChild;
					while(tempNode.firstChild){
						tempNode.removeChild(tempNode.firstChild);
					}
				}

				if(i == length - 1){
					domCtr.place(node, rNode, position);
				}else{
					rNode.parentNode.insertBefore(node, rNode);
				}
				rNode = node;
			}
		},


		position: aam(domGeom.position),
		/*=====
		position: function(){
			// summary:
			//		Returns border-box objects (x/y/w/h) of all elements in a node list
			//		as an Array (*not* a NodeList). Acts like `dojo/dom-geometry-position`, though
			//		assumes the node passed is each node in this list.

			return dojo.map(this, dojo.position); // Array
		},
		=====*/

		attr: awc(getSet(domAttr), magicGuard),
		/*=====
		attr: function(property, value){
			// summary:
			//		gets or sets the DOM attribute for every element in the
			//		NodeList. See also `dojo/dom-attr`
			// property: String
			//		the attribute to get/set
			// value: String?
			//		optional. The value to set the property to
			// returns:
			//		if no value is passed, the result is an array of attribute values
			//		If a value is passed, the return is this NodeList
			// example:
			//		Make all nodes with a particular class focusable:
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		query(".focusable").attr("tabIndex", -1);
			//	|	});
			// example:
			//		Disable a group of buttons:
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		query("button.group").attr("disabled", true);
			//	|	});
			// example:
			//		innerHTML can be assigned or retrieved as well:
			//	|	// get the innerHTML (as an array) for each list item
			//	|	require(["dojo/query", "dojo/NodeList-dom"], function(query){
			//	|		var ih = query("li.replaceable").attr("innerHTML");
			//	|	});
			return; // dojo/NodeList|Array
		},
		=====*/

		style: awc(getSet(domStyle), magicGuard),
		/*=====
		style: function(property, value){
			// summary:
			//		gets or sets the CSS property for every element in the NodeList
			// property: String
			//		the CSS property to get/set, in JavaScript notation
			//		("lineHieght" instead of "line-height")
			// value: String?
			//		optional. The value to set the property to
			// returns:
			//		if no value is passed, the result is an array of strings.
			//		If a value is passed, the return is this NodeList
			return; // dojo/NodeList
			return; // Array
		},
		=====*/

		addClass: aafe(domCls.add),
		/*=====
		addClass: function(className){
			// summary:
			//		adds the specified class to every node in the list
			// className: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			return; // dojo/NodeList
		},
		=====*/

		removeClass: aafe(domCls.remove),
		/*=====
		removeClass: function(className){
			// summary:
			//		removes the specified class from every node in the list
			// className: String|Array?
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			// returns:
			//		this list
			return; // dojo/NodeList
		},
		=====*/

		toggleClass: aafe(domCls.toggle),
		/*=====
		toggleClass: function(className, condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			// condition: Boolean?
			//		If passed, true means to add the class, false means to remove.
			// className: String
			//		the CSS class to add
			return; // dojo/NodeList
		},
		=====*/

		replaceClass: aafe(domCls.replace),
		/*=====
		replaceClass: function(addClassStr, removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling `removeClass()` and `addClass()`
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			return; // dojo/NodeList
		 },
		 =====*/

		empty: aafe(domCtr.empty),
		/*=====
		empty: function(){
			// summary:
			//		clears all content from each node in the list. Effectively
			//		equivalent to removing all child nodes from every item in
			//		the list.
			return this.forEach("item.innerHTML='';"); // dojo/NodeList
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		=====*/

		removeAttr: aafe(domAttr.remove),
		/*=====
		 removeAttr: function(name){
			// summary:
			//		Removes an attribute from each node in the list.
			// name: String
			//		the name of the attribute to remove
			return;		// dojo/NodeList
		},
		=====*/

		marginBox: aam(domGeom.getMarginBox),
		/*=====
		marginBox: function(){
			// summary:
			//		Returns margin-box size of nodes
		 	return; // dojo/NodeList
		 },
		 =====*/

		// FIXME: connectPublisher()? connectRunOnce()?

		/*
		destroy: function(){
			// summary:
			//		destroys every item in the list.
			this.forEach(d.destroy);
			// FIXME: should we be checking for and/or disposing of widgets below these nodes?
		},
		*/

		place: function(/*String||Node*/ queryOrNode, /*String*/ position){
			// summary:
			//		places elements of this node list relative to the first element matched
			//		by queryOrNode. Returns the original NodeList. See: `dojo/dom-construct.place`
			// queryOrNode:
			//		may be a string representing any valid CSS3 selector or a DOM node.
			//		In the selector case, only the first matching element will be used
			//		for relative positioning.
			// position:
			//		can be one of:
			//
			//		-	"last" (default)
			//		-	"first"
			//		-	"before"
			//		-	"after"
			//		-	"only"
			//		-	"replace"
			//
			//		or an offset in the childNodes property
			var item = query(queryOrNode)[0];
			return this.forEach(function(node){ domCtr.place(node, item, position); }); // dojo/NodeList
		},

		orphan: function(/*String?*/ filter){
			// summary:
			//		removes elements in this list that match the filter
			//		from their parents and returns them as a new NodeList.
			// filter:
			//		CSS selector like ".foo" or "div > span"
			// returns:
			//		NodeList containing the orphaned elements
			return (filter ? query._filterResult(this, filter) : this).forEach(orphan); // dojo/NodeList
		},

		adopt: function(/*String||Array||DomNode*/ queryOrListOrNode, /*String?*/ position){
			// summary:
			//		places any/all elements in queryOrListOrNode at a
			//		position relative to the first element in this list.
			//		Returns a dojo/NodeList of the adopted elements.
			// queryOrListOrNode:
			//		a DOM node or a query string or a query result.
			//		Represents the nodes to be adopted relative to the
			//		first element of this NodeList.
			// position:
			//		can be one of:
			//
			//		-	"last" (default)
			//		-	"first"
			//		-	"before"
			//		-	"after"
			//		-	"only"
			//		-	"replace"
			//
			//		or an offset in the childNodes property
			return query(queryOrListOrNode).place(this[0], position)._stash(this);	// dojo/NodeList
		},

		// FIXME: do we need this?
		query: function(/*String*/ queryStr){
			// summary:
			//		Returns a new list whose members match the passed query,
			//		assuming elements of the current NodeList as the root for
			//		each search.
			// example:
			//		assume a DOM created by this markup:
			//	|	<div id="foo">
			//	|		<p>
			//	|			bacon is tasty, <span>dontcha think?</span>
			//	|		</p>
			//	|	</div>
			//	|	<div id="bar">
			//	|		<p>great comedians may not be funny <span>in person</span></p>
			//	|	</div>
			//		If we are presented with the following definition for a NodeList:
			//	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(dom, query){
			//	|		var l = new NodeList(dom.byId("foo"), dom.byId("bar"));
			//		it's possible to find all span elements under paragraphs
			//		contained by these elements with this sub-query:
			//	|		var spans = l.query("p span");
			//	|	});

			// FIXME: probably slow
			if(!queryStr){ return this; }
			var ret = new NodeList;
			this.map(function(node){
				// FIXME: why would we ever get undefined here?
				query(queryStr, node).forEach(function(subNode){
					if(subNode !== undefined){
						ret.push(subNode);
					}
				});
			});
			return ret._stash(this);	// dojo/NodeList
		},

		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in dojo.filter:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("*").filter(function(item){
			//	|			// highlight every paragraph
			//	|			return (item.nodeName == "p");
			//	|		}).style("backgroundColor", "yellow");
			//	|	});
			// example:
			//	the same filtering using a CSS selector
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("*").filter("p").styles("backgroundColor", "yellow");
			//	|	});
			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},

		/*
		// FIXME: should this be "copyTo" and include parenting info?
		clone: function(){
			// summary:
			//		creates node clones of each element of this list
			//		and returns a new list containing the clones
		},
		*/

		addContent: function(/*String||DomNode||Object||dojo/NodeList*/ content, /*String||Integer?*/ position){
			// summary:
			//		add a node, NodeList or some HTML as a string to every item in the
			//		list.  Returns the original list.
			// description:
			//		a copy of the HTML content is added to each item in the
			//		list, with an optional position argument. If no position
			//		argument is provided, the content is appended to the end of
			//		each item.
			// content:
			//		DOM node, HTML in string format, a NodeList or an Object. If a DOM node or
			//		NodeList, the content will be cloned if the current NodeList has more than one
			//		element. Only the DOM nodes are cloned, no event handlers. If it is an Object,
			//		it should be an object with at "template" String property that has the HTML string
			//		to insert. If dojo.string has already been dojo.required, then dojo.string.substitute
			//		will be used on the "template" to generate the final HTML string. Other allowed
			//		properties on the object are: "parse" if the HTML
			//		string should be parsed for widgets (dojo.require("dojo.parser") to get that
			//		option to work), and "templateFunc" if a template function besides dojo.string.substitute
			//		should be used to transform the "template".
			// position:
			//		can be one of:
			//
			//		-	"last"||"end" (default)
			//		-	"first||"start"
			//		-	"before"
			//		-	"after"
			//		-	"replace" (replaces nodes in this NodeList with new content)
			//		-	"only" (removes other children of the nodes so new content is the only child)
			//
			//		or an offset in the childNodes property
			// example:
			//		appends content to the end if the position is omitted
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("h3 > p").addContent("hey there!");
			//	|	});
			// example:
			//		add something to the front of each element that has a
			//		"thinger" property:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("[thinger]").addContent("...", "first");
			//	|	});
			// example:
			//		adds a header before each element of the list
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query(".note").addContent("<h4>NOTE:</h4>", "before");
			//	|	});
			// example:
			//		add a clone of a DOM node to the end of every element in
			//		the list, removing it from its existing parent.
			//	|	require(["dojo/dom", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(dom, query){
			//	|		query(".note").addContent(dom.byId("foo"));
			//	|	});
			// example:
			//		Append nodes from a templatized string.
			//	|	require(["dojo/string", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(string, query){
			//	|		query(".note").addContent({
			//	|			template: '<b>${id}: </b><span>${name}</span>',
			//	|			id: "user332",
			//	|			name: "Mr. Anderson"
			//	|		});
			//	|	});
			// example:
			//		Append nodes from a templatized string that also has widgets parsed.
			//	|	require(["dojo/string", "dojo/parser", "dojo/query", "dojo/NodeList-dom"
			//	|	], function(string, parser, query){
			//	|		var notes = query(".note").addContent({
			//	|			template: '<button dojoType="dijit/form/Button">${text}</button>',
			//	|			parse: true,
			//	|			text: "Send"
			//	|		});
			//	|	});
			content = this._normalize(content, this[0]);
			for(var i = 0, node; (node = this[i]); i++){
				if(content.length){
					this._place(content, node, position, i > 0);
				}else{
					// if it is an empty array, we empty the target node
					domCtr.empty(node);
				}
			}
			return this; // dojo/NodeList
		}
	});

	return NodeList;
});

},
'dojo/query':function(){
define(["./_base/kernel", "./has", "./dom", "./on", "./_base/array", "./_base/lang", "./selector/_loader", "./selector/_loader!default"],
	function(dojo, has, dom, on, array, lang, loader, defaultEngine){

	"use strict";

	has.add("array-extensible", function(){
		// test to see if we can extend an array (not supported in old IE)
		return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
	});
	
	var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;

	var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
		// summary:
		//		decorate an array to make it look like a `dojo/NodeList`.
		// a:
		//		Array of nodes to decorate.
		// parent:
		//		An optional parent NodeList that generated the current
		//		list of nodes. Used to call _stash() so the parent NodeList
		//		can be accessed via end() later.
		// NodeListCtor:
		//		An optional constructor function to use for any
		//		new NodeList calls. This allows a certain chain of
		//		NodeList calls to use a different object than dojo/NodeList.
		var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
		return parent ? nodeList._stash(parent) : nodeList;
	};

	var loopBody = function(f, a, o){
		a = [0].concat(aps.call(a, 0));
		o = o || dojo.global;
		return function(node){
			a[0] = node;
			return f.apply(o, a);
		};
	};

	// adapters

	var adaptAsForEach = function(f, o){
		// summary:
		//		adapts a single node function to be used in the forEach-type
		//		actions. The initial object is returned from the specialized
		//		function.
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			this.forEach(loopBody(f, arguments, o));
			return this;	// Object
		};
	};

	var adaptAsMap = function(f, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions. The return is a new array of values, as via `dojo/_base/array.map`
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.map(loopBody(f, arguments, o));
		};
	};

	var adaptAsFilter = function(f, o){
		// summary:
		//		adapts a single node function to be used in the filter-type actions
		// f: Function
		//		a function to adapt
		// o: Object?
		//		an optional context for f
		return function(){
			return this.filter(loopBody(f, arguments, o));
		};
	};

	var adaptWithCondition = function(f, g, o){
		// summary:
		//		adapts a single node function to be used in the map-type
		//		actions, behaves like forEach() or map() depending on arguments
		// f: Function
		//		a function to adapt
		// g: Function
		//		a condition function, if true runs as map(), otherwise runs as forEach()
		// o: Object?
		//		an optional context for f and g
		return function(){
			var a = arguments, body = loopBody(f, a, o);
			if(g.call(o || dojo.global, a)){
				return this.map(body);	// self
			}
			this.forEach(body);
			return this;	// self
		};
	};

	var NodeList = function(array){
		// summary:
		//		Array-like object which adds syntactic
		//		sugar for chaining, common iteration operations, animation, and
		//		node manipulation. NodeLists are most often returned as the
		//		result of dojo/query() calls.
		// description:
		//		NodeList instances provide many utilities that reflect
		//		core Dojo APIs for Array iteration and manipulation, DOM
		//		manipulation, and event handling. Instead of needing to dig up
		//		functions in the dojo package, NodeLists generally make the
		//		full power of Dojo available for DOM manipulation tasks in a
		//		simple, chainable way.
		// example:
		//		create a node list from a node
		//		|	require(["dojo/query", "dojo/dom"
		//		|	], function(query, dom){
		//		|		query.NodeList(dom.byId("foo"));
		//		|	});
		// example:
		//		get a NodeList from a CSS query and iterate on it
		//		|	require(["dojo/on", "dojo/dom"
		//		|	], function(on, dom){
		//		|		var l = query(".thinger");
		//		|		l.forEach(function(node, index, nodeList){
		//		|			console.log(index, node.innerHTML);
		//		|		});
		//		|	});
		// example:
		//		use native and Dojo-provided array methods to manipulate a
		//		NodeList without needing to use dojo.* functions explicitly:
		//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
		//		|	], function(query, domConstruct, dom){
		//		|		var l = query(".thinger");
		//		|		// since NodeLists are real arrays, they have a length
		//		|		// property that is both readable and writable and
		//		|		// push/pop/shift/unshift methods
		//		|		console.log(l.length);
		//		|		l.push(domConstruct.create("span"));
		//		|
		//		|		// dojo's normalized array methods work too:
		//		|		console.log( l.indexOf(dom.byId("foo")) );
		//		|		// ...including the special "function as string" shorthand
		//		|		console.log( l.every("item.nodeType == 1") );
		//		|
		//		|		// NodeLists can be [..] indexed, or you can use the at()
		//		|		// function to get specific items wrapped in a new NodeList:
		//		|		var node = l[3]; // the 4th element
		//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
		//		|	});
		// example:
		//		chainability is a key advantage of NodeLists:
		//		|	require(["dojo/query", "dojo/NodeList-dom"
		//		|	], function(query){
		//		|		query(".thinger")
		//		|			.onclick(function(e){ /* ... */ })
		//		|			.at(1, 3, 8) // get a subset
		//		|				.style("padding", "5px")
		//		|				.forEach(console.log);
		//		|	});

		var isNew = this instanceof nl && has("array-extensible");
		if(typeof array == "number"){
			array = Array(array);
		}
		var nodeArray = (array && "length" in array) ? array : arguments;
		if(isNew || !nodeArray.sort){
			// make sure it's a real array before we pass it on to be wrapped 
			var target = isNew ? this : [],
				l = target.length = nodeArray.length;
			for(var i = 0; i < l; i++){
				target[i] = nodeArray[i];
			}
			if(isNew){
				// called with new operator, this means we are going to use this instance and push
				// the nodes on to it. This is usually much faster since the NodeList properties
				//	don't need to be copied (unless the list of nodes is extremely large).
				return target;
			}
			nodeArray = target;
		}
		// called without new operator, use a real array and copy prototype properties,
		// this is slower and exists for back-compat. Should be removed in 2.0.
		lang._mixin(nodeArray, nlp);
		nodeArray._NodeListCtor = function(array){
			// call without new operator to preserve back-compat behavior
			return nl(array);
		};
		return nodeArray;
	};
	
	var nl = NodeList, nlp = nl.prototype = 
		has("array-extensible") ? [] : {};// extend an array if it is extensible

	// expose adapters and the wrapper as private functions

	nl._wrap = nlp._wrap = tnl;
	nl._adaptAsMap = adaptAsMap;
	nl._adaptAsForEach = adaptAsForEach;
	nl._adaptAsFilter  = adaptAsFilter;
	nl._adaptWithCondition = adaptWithCondition;

	// mass assignment

	// add array redirectors
	forEach(["slice", "splice"], function(name){
		var f = ap[name];
		//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
		// CANNOT apply ._stash()/end() to splice since it currently modifies
		// the existing this array -- it would break backward compatibility if we copy the array before
		// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
		nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
	});
	// concat should be here but some browsers with native NodeList have problems with it

	// add array.js redirectors
	forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
		var f = array[name];
		nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
	});

	lang.extend(NodeList, {
		// copy the constructors
		constructor: nl,
		_NodeListCtor: nl,
		toString: function(){
			// Array.prototype.toString can't be applied to objects, so we use join
			return this.join(",");
		},
		_stash: function(parent){
			// summary:
			//		private function to hold to a parent NodeList. end() to return the parent NodeList.
			//
			// example:
			//		How to make a `dojo/NodeList` method that only returns the third node in
			//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
			//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
			//	|	], function(query, lang){
			//	|		lang.extend(NodeList, {
			//	|			third: function(){
			//	|				var newNodeList = NodeList(this[2]);
			//	|				return newNodeList._stash(this);
			//	|			}
			//	|		});
			//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
			//	|		query(".foo")
			//	|			.third()
			//	|				.addClass("thirdFoo")
			//	|			.end()
			//	|			// access to the orig .foo list
			//	|			.removeClass("foo")
			//	|	});
			//
			this._parent = parent;
			return this; // dojo/NodeList
		},

		on: function(eventName, listener){
			// summary:
			//		Listen for events on the nodes in the NodeList. Basic usage is:
			//
			// example:
			//		|	require(["dojo/query"
			//		|	], function(query){
			//		|		query(".my-class").on("click", listener);
			//			This supports event delegation by using selectors as the first argument with the event names as
			//			pseudo selectors. For example:
			//		| 		query("#my-list").on("li:click", listener);
			//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
			//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
			//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
			//		|	});
			var handles = this.map(function(node){
				return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
			});
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		},

		end: function(){
			// summary:
			//		Ends use of the current `NodeList` by returning the previous NodeList
			//		that generated the current NodeList.
			// description:
			//		Returns the `NodeList` that generated the current `NodeList`. If there
			//		is no parent NodeList, an empty NodeList is returned.
			// example:
			//	|	require(["dojo/query", "dojo/NodeList-dom"
			//	|	], function(query){
			//	|		query("a")
			//	|			.filter(".disabled")
			//	|				// operate on the anchors that only have a disabled class
			//	|				.style("color", "grey")
			//	|			.end()
			//	|			// jump back to the list of anchors
			//	|			.style(...)
			//	|	});
			//
			if(this._parent){
				return this._parent;
			}else{
				//Just return empty list.
				return new this._NodeListCtor(0);
			}
		},

		// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods

		// FIXME: handle return values for #3244
		//		http://trac.dojotoolkit.org/ticket/3244

		// FIXME:
		//		need to wrap or implement:
		//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
		//			reduce
		//			reduceRight

		/*=====
		slice: function(begin, end){
			// summary:
			//		Returns a new NodeList, maintaining this one in place
			// description:
			//		This method behaves exactly like the Array.slice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [slice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
			// begin: Integer
			//		Can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// end: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			return this._wrap(a.slice.apply(this, arguments));
		},

		splice: function(index, howmany, item){
			// summary:
			//		Returns a new NodeList, manipulating this NodeList based on
			//		the arguments passed, potentially splicing in new elements
			//		at an offset, optionally deleting elements
			// description:
			//		This method behaves exactly like the Array.splice method
			//		with the caveat that it returns a `dojo/NodeList` and not a
			//		raw Array. For more details, see Mozilla's [splice
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
			//		For backwards compatibility, calling .end() on the spliced NodeList
			//		does not return the original NodeList -- splice alters the NodeList in place.
			// index: Integer
			//		begin can be a positive or negative integer, with positive
			//		integers noting the offset to begin at, and negative
			//		integers denoting an offset from the end (i.e., to the left
			//		of the end)
			// howmany: Integer?
			//		Optional parameter to describe what position relative to
			//		the NodeList's zero index to end the slice at. Like begin,
			//		can be positive or negative.
			// item: Object...?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList
			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
		},

		indexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// description:
			//		For more details on the behavior of indexOf, see Mozilla's
			//		[indexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.indexOf(this, value, fromIndex); // Integer
		},

		lastIndexOf: function(value, fromIndex){
			// summary:
			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
			//		acted-on array is implicitly this NodeList
			// description:
			//		For more details on the behavior of lastIndexOf, see
			//		Mozilla's [lastIndexOf
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
			// value: Object
			//		The value to search for.
			// fromIndex: Integer?
			//		The location to start searching from. Optional. Defaults to 0.
			// returns:
			//		Positive Integer or 0 for a match, -1 of not found.
			return d.lastIndexOf(this, value, fromIndex); // Integer
		},

		every: function(callback, thisObject){
			// summary:
			//		see `dojo/_base/array.every()` and the [Array.every
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
			//		Takes the same structure of arguments and returns as
			//		dojo/_base/array.every() with the caveat that the passed array is
			//		implicitly this NodeList
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.every(this, callback, thisObject); // Boolean
		},

		some: function(callback, thisObject){
			// summary:
			//		Takes the same structure of arguments and returns as
			//		`dojo/_base/array.some()` with the caveat that the passed array is
			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
			//		[Array.some
			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
			// callback: Function
			//		the callback
			// thisObject: Object?
			//		the context
			return d.some(this, callback, thisObject); // Boolean
		},
		=====*/

		concat: function(item){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		as well as items passed in as parameters
			// description:
			//		This method behaves exactly like the Array.concat method
			//		with the caveat that it returns a `NodeList` and not a
			//		raw Array. For more details, see the [Array.concat
			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
			// item: Object?
			//		Any number of optional parameters may be passed in to be
			//		spliced into the NodeList

			//return this._wrap(apc.apply(this, arguments));
			// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(

			// implementation notes:
			// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
			// as arrays, and so does not inline them into a unioned array, but
			// appends them as single entities. Both the original NodeList and the
			// items passed in as parameters must be converted to raw Arrays
			// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.

			var t = aps.call(this, 0),
				m = array.map(arguments, function(a){
					return aps.call(a, 0);
				});
			return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
		},

		map: function(/*Function*/ func, /*Function?*/ obj){
			// summary:
			//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList and the return is a
			//		NodeList (a subclass of Array)
			return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
		},

		forEach: function(callback, thisObj){
			// summary:
			//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
			//		array is implicitly this NodeList. If you want the option to break out
			//		of the forEach loop, use every() or some() instead.
			forEach(this, callback, thisObj);
			// non-standard return to allow easier chaining
			return this; // dojo/NodeList
		},
		filter: function(/*String|Function*/ filter){
			// summary:
			//		"masks" the built-in javascript filter() method (supported
			//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
			//		string filter in addition to supporting filtering function
			//		objects.
			// filter:
			//		If a string, a CSS rule like ".thinger" or "div > span".
			// example:
			//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter(function(item){
			//		|			// highlight every paragraph
			//		|			return (item.nodeName == "p");
			//		|		}).style("backgroundColor", "yellow");
			//		|	});
			// example:
			//		the same filtering using a CSS selector
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query("*").filter("p").styles("backgroundColor", "yellow");
			//		|	});

			var a = arguments, items = this, start = 0;
			if(typeof filter == "string"){ // inline'd type check
				items = query._filterResult(this, a[0]);
				if(a.length == 1){
					// if we only got a string query, pass back the filtered results
					return items._stash(this); // dojo/NodeList
				}
				// if we got a callback, run it over the filtered items
				start = 1;
			}
			return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
		},
		instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
			// summary:
			//		Create a new instance of a specified class, using the
			//		specified properties and each node in the NodeList as a
			//		srcNodeRef.
			// example:
			//		Grabs all buttons in the page and converts them to dijit/form/Button's.
			//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
			var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
			properties = properties || {};
			return this.forEach(function(node){
				new c(properties, node);
			});	// dojo/NodeList
		},
		at: function(/*===== index =====*/){
			// summary:
			//		Returns a new NodeList comprised of items in this NodeList
			//		at the given index or indices.
			//
			// index: Integer...
			//		One or more 0-based indices of items in the current
			//		NodeList. A negative index will start at the end of the
			//		list and go backwards.
			//
			// example:
			//	Shorten the list to the first, second, and third elements
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0, 1, 2).forEach(fn);
			//	|	});
			//
			// example:
			//	Retrieve the first and last elements of a unordered list:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("ul > li").at(0, -1).forEach(cb);
			//	|	});
			//
			// example:
			//	Do something for the first element only, but end() out back to
			//	the original list and continue chaining:
			//	|	require(["dojo/query"
			//	|	], function(query){
			//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
			//	|			console.log(n); // all anchors on the page.
			//	|	})
			//	|	});

			var t = new this._NodeListCtor(0);
			forEach(arguments, function(i){
				if(i < 0){ i = this.length + i; }
				if(this[i]){ t.push(this[i]); }
			}, this);
			return t._stash(this); // dojo/NodeList
		}
	});

	function queryForEngine(engine, NodeList){
		var query = function(/*String*/ query, /*String|DOMNode?*/ root){
			// summary:
			//		Returns nodes which match the given CSS selector, searching the
			//		entire document by default but optionally taking a node to scope
			//		the search by. Returns an instance of NodeList.
			if(typeof root == "string"){
				root = dom.byId(root);
				if(!root){
					return new NodeList([]);
				}
			}
			var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
			if(results.end && results.on){
				// already wrapped
				return results;
			}
			return new NodeList(results);
		};
		query.matches = engine.match || function(node, selector, root){
			// summary:
			//		Test to see if a node matches a selector
			return query.filter([node], selector, root).length > 0;
		};
		// the engine provides a filtering function, use it to for matching
		query.filter = engine.filter || function(nodes, selector, root){
			// summary:
			//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
			return query(selector, root).filter(function(node){
				return array.indexOf(nodes, node) > -1;
			});
		};
		if(typeof engine != "function"){
			var search = engine.search;
			engine = function(selector, root){
				// Slick does it backwards (or everyone else does it backwards, probably the latter)
				return search(root || document, selector);
			};
		}
		return query;
	}
	var query = queryForEngine(defaultEngine, NodeList);
	/*=====
	query = function(selector, context){
		// summary:
		//		This modules provides DOM querying functionality. The module export is a function
		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
		//		representing the matching nodes.
		// selector: String
		//		A CSS selector to search for.
		// context: String|DomNode?
		//		An optional context to limit the searching scope. Only nodes under `context` will be
		//		scanned.
		// example:
		//		add an onclick handler to every submit button in the document
		//		which causes the form to be sent via Ajax instead:
		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
		//	|	], function(query, request, domForm, domConstruct, domStyle){
		//	|		query("input[type='submit']").on("click", function(e){
		//	|			e.preventDefault(); // prevent sending the form
		//	|			var btn = e.target;
		//	|			request.post("http://example.com/", {
		//	|				data: domForm.toObject(btn.form)
		//	|			}).then(function(response){
		//	|				// replace the form with the response
		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
		//	|				domStyle.set(btn.form, "display", "none");
		//	|			});
		//	|		});
		//	|	});
		//
		// description:
		//		dojo/query is responsible for loading the appropriate query engine and wrapping
		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
		//		by using it as a plugin. For example, if you installed the sizzle package, you could
		//		use it as the selector engine with:
		//		|	require(["dojo/query!sizzle"], function(query){
		//		|		query("div")...
		//
		//		The id after the ! can be a module id of the selector engine or one of the following values:
		//
		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
		//		Acme engine is always loaded.
		//
		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
		//		operators) and nothing more.
		//
		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
		//		selectors (most modern browsers except IE8), this will be used, otherwise the
		//		full Acme engine will be loaded.
		//
		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
		//
		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
		//		you will need support them with:
		//		|	require(["dojo/query!css3"], function(query){
		//		|		query('#t > h3:nth-child(odd)')...
		//
		//		You can also choose the selector engine/load configuration by setting the query-selector:
		//		For example:
		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
		//
		return new NodeList(); // dojo/NodeList
	 };
	 =====*/

	// the query that is returned from this module is slightly different than dojo.query,
	// because dojo.query has to maintain backwards compatibility with returning a
	// true array which has performance problems. The query returned from the module
	// does not use true arrays, but rather inherits from Array, making it much faster to
	// instantiate.
	dojo.query = queryForEngine(defaultEngine, function(array){
		// call it without the new operator to invoke the back-compat behavior that returns a true array
		return NodeList(array);	// dojo/NodeList
	});

	query.load = function(id, parentRequire, loaded){
		// summary:
		//		can be used as AMD plugin to conditionally load new query engine
		// example:
		//	|	require(["dojo/query!custom"], function(qsa){
		//	|		// loaded selector/custom.js as engine
		//	|		qsa("#foobar").forEach(...);
		//	|	});
		loader.load(id, parentRequire, function(engine){
			loaded(queryForEngine(engine, NodeList));
		});
	};

	dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
		return new NodeList(query.filter(nodes, selector, root));
	};
	dojo.NodeList = query.NodeList = NodeList;
	return query;
});

},
'dojo/has':function(){
define(["./global", "require", "module"], function(global, require, module){
	// module:
	//		dojo/has
	// summary:
	//		Defines the has.js API and several feature tests used by dojo.
	// description:
	//		This module defines the has API as described by the project has.js with the following additional features:
	//
	//		- the has test cache is exposed at has.cache.
	//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
	//		- the loader's has cache may be optionally copied into this module's has cahce.
	//
	//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!

	// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
	// if using a foreign loader, then the has cache may be initialized via the config object for this module
	// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
	var has = require.has || function(){};
	if(! 1 ){
		var
			isBrowser =
				// the most fundamental decision: are we in the browser?
				typeof window != "undefined" &&
				typeof location != "undefined" &&
				typeof document != "undefined" &&
				window.location == location && window.document == document,

			// has API variables
			doc = isBrowser && document,
			element = doc && doc.createElement("DiV"),
			cache = (module.config && module.config()) || {};

		has = function(name){
			// summary:
			//		Return the current value of the named feature.
			//
			// name: String|Integer
			//		The name (if a string) or identifier (if an integer) of the feature to test.
			//
			// description:
			//		Returns the value of the feature named by name. The feature must have been
			//		previously added to the cache by has.add.

			return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
		};

		has.cache = cache;

		has.add = function(name, test, now, force){
			// summary:
			//	 	Register a new feature test for some named feature.
			// name: String|Integer
			//	 	The name (if a string) or identifier (if an integer) of the feature to test.
			// test: Function
			//		 A test function to register. If a function, queued for testing until actually
			//		 needed. The test function should return a boolean indicating
			//	 	the presence of a feature or bug.
			// now: Boolean?
			//		 Optional. Omit if `test` is not a function. Provides a way to immediately
			//		 run the test and cache the result.
			// force: Boolean?
			//	 	Optional. If the test already exists and force is truthy, then the existing
			//	 	test will be replaced; otherwise, add does not replace an existing test (that
			//	 	is, by default, the first test advice wins).
			// example:
			//		A redundant test, testFn with immediate execution:
			//	|	has.add("javascript", function(){ return true; }, true);
			//
			// example:
			//		Again with the redundantness. You can do this in your tests, but we should
			//		not be doing this in any internal has.js tests
			//	|	has.add("javascript", true);
			//
			// example:
			//		Three things are passed to the testFunction. `global`, `document`, and a generic element
			//		from which to work your test should the need arise.
			//	|	has.add("bug-byid", function(g, d, el){
			//	|		// g	== global, typically window, yadda yadda
			//	|		// d	== document object
			//	|		// el == the generic element. a `has` element.
			//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
			//	|	});

			(typeof cache[name]=="undefined" || force) && (cache[name]= test);
			return now && has(name);
		};

		// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
		// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
		// can optimize these away iff desired
		 1 || has.add("host-browser", isBrowser);
		 0 && has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
		 0 && has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
		 1 || has.add("dom", isBrowser);
		 1 || has.add("dojo-dom-ready-api", 1);
		 1 || has.add("dojo-sniff", 1);
	}

	if( 1 ){
		// Common application level tests
		has.add("dom-addeventlistener", !!document.addEventListener);

		// Do the device and browser have touch capability?
		has.add("touch", "ontouchstart" in document
			|| ("onpointerdown" in document && navigator.maxTouchPoints > 0)
			|| window.navigator.msMaxTouchPoints);

		// Touch events support
		has.add("touch-events", "ontouchstart" in document);

		// Test if pointer events are supported and enabled, with either standard names ("pointerdown" etc.) or
		// IE specific names ("MSPointerDown" etc.).  Tests are designed to work on embedded C# WebBrowser Controls
		// in addition to IE, Edge, and future versions of Firefox and Chrome.
		// Note that on IE11, has("pointer-events") and has("MSPointer") are both true.
		has.add("pointer-events", "pointerEnabled" in window.navigator ?
				window.navigator.pointerEnabled : "PointerEvent" in window);
		has.add("MSPointer", window.navigator.msPointerEnabled);
		// The "pointermove"" event is only continuously emitted in a touch environment if
		// the target node's "touch-action"" CSS property is set to "none"
		// https://www.w3.org/TR/pointerevents/#the-touch-action-css-property
		has.add("touch-action", has("touch") && has("pointer-events"));

		// I don't know if any of these tests are really correct, just a rough guess
		has.add("device-width", screen.availWidth || innerWidth);

		// Tests for DOMNode.attributes[] behavior:
		//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
		//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
		//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
		var form = document.createElement("form");
		has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
		has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
	}

	has.clearElement = function(element){
		// summary:
		//	 Deletes the contents of the element passed to test functions.
		element.innerHTML= "";
		return element;
	};

	has.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if(!skip && has(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};

	has.load = function(id, parentRequire, loaded){
		// summary:
		//		Conditional loading of AMD modules based on a has feature test value.
		// id: String
		//		Gives the resolved module id to load.
		// parentRequire: Function
		//		The loader require function with respect to the module that contained the plugin resource in it's
		//		dependency list.
		// loaded: Function
		//	 Callback to loader that consumes result of plugin demand.

		if(id){
			parentRequire([id], loaded);
		}else{
			loaded();
		}
	};

	return has;
});

},
'dojo/json':function(){
define(["./has"], function(has){
	"use strict";
	var hasJSON = typeof JSON != "undefined";
	has.add("json-parse", hasJSON); // all the parsers work fine
		// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
	has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');

	/*=====
	return {
		// summary:
		//		Functions to parse and serialize JSON

		parse: function(str, strict){
			// summary:
			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
			// description:
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
			//		support is not available. By default this will evaluate any valid JS expression.
			//		With the strict parameter set to true, the parser will ensure that only
			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
			//		parameter, the content passed to this method must come
			//		from a trusted source.
			// str:
			//		a string literal of a JSON item, for instance:
			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
			// strict:
			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
			//		without native JSON support, setting this to true will run slower.
		},
		stringify: function(value, replacer, spacer){
			// summary:
			//		Returns a [JSON](http://json.org) serialization of an object.
			// description:
			//		Returns a [JSON](http://json.org) serialization of an object.
			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
			//		Note that this doesn't check for infinite recursion, so don't do that!
			// value:
			//		A value to be serialized.
			// replacer:
			//		A replacer function that is called for each value and can return a replacement
			// spacer:
			//		A spacer string to be used for pretty printing of JSON
			// example:
			//		simple serialization of a trivial object
			//	|	define(["dojo/json"], function(JSON){
			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		}
	};
	=====*/

	if(has("json-stringify")){
		return JSON;
	}else{
		var escapeString = function(/*String*/str){
			// summary:
			//		Adds escape sequences for non-visual characters, double quote and
			//		backslash and surrounds with double quotes to form a valid string
			//		literal.
			return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
				replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
				replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
		};
		return {
			parse: has("json-parse") ? JSON.parse : function(str, strict){
				if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
					throw new SyntaxError("Invalid characters in JSON");
				}
				return eval('(' + str + ')');
			},
			stringify: function(value, replacer, spacer){
				var undef;
				if(typeof replacer == "string"){
					spacer = replacer;
					replacer = null;
				}
				function stringify(it, indent, key){
					if(replacer){
						it = replacer(key, it);
					}
					var val, objtype = typeof it;
					if(objtype == "number"){
						return isFinite(it) ? it + "" : "null";
					}
					if(objtype == "boolean"){
						return it + "";
					}
					if(it === null){
						return "null";
					}
					if(typeof it == "string"){
						return escapeString(it);
					}
					if(objtype == "function" || objtype == "undefined"){
						return undef; // undefined
					}
					// short-circuit for objects that support "json" serialization
					// if they return "self" then just pass-through...
					if(typeof it.toJSON == "function"){
						return stringify(it.toJSON(key), indent, key);
					}
					if(it instanceof Date){
						return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
							var num = it["getUTC" + prop]() + (plus ? 1 : 0);
							return num < 10 ? "0" + num : num;
						});
					}
					if(it.valueOf() !== it){
						// primitive wrapper, try again unwrapped:
						return stringify(it.valueOf(), indent, key);
					}
					var nextIndent= spacer ? (indent + spacer) : "";
					/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
				
					var sep = spacer ? " " : "";
					var newLine = spacer ? "\n" : "";
				
					// array
					if(it instanceof Array){
						var itl = it.length, res = [];
						for(key = 0; key < itl; key++){
							var obj = it[key];
							val = stringify(obj, nextIndent, key);
							if(typeof val != "string"){
								val = "null";
							}
							res.push(newLine + nextIndent + val);
						}
						return "[" + res.join(",") + newLine + indent + "]";
					}
					// generic object code path
					var output = [];
					for(key in it){
						var keyStr;
						if(it.hasOwnProperty(key)){
							if(typeof key == "number"){
								keyStr = '"' + key + '"';
							}else if(typeof key == "string"){
								keyStr = escapeString(key);
							}else{
								// skip non-string or number keys
								continue;
							}
							val = stringify(it[key], nextIndent, key);
							if(typeof val != "string"){
								// skip non-serializable values
								continue;
							}
							// At this point, the most non-IE browsers don't get in this branch 
							// (they have native JSON), so push is definitely the way to
							output.push(newLine + nextIndent + keyStr + ":" + sep + val);
						}
					}
					return "{" + output.join(",") + newLine + indent + "}"; // String
				}
				return stringify(value, "", "");
			}
		};
	}
});

},
'dojo/_base/declare':function(){
define(["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/declare

	var mix = lang.mixin, op = Object.prototype, opts = op.toString,
		xtor, counter = 0, cname = "constructor";

	if(!has("csp-restrictions")){
		// 'new Function()' is preferable when available since it does not create a closure
		xtor = new Function;
	}else{
		xtor = function(){};
	}

	function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }

	// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
	function c3mro(bases, className){
		var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
			l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;

		// build a list of bases naming them if needed
		for(; i < l; ++i){
			base = bases[i];
			if(!base){
				err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
			}else if(opts.call(base) != "[object Function]"){
				err("mixin #" + i + " is not a callable constructor.", className);
			}
			lin = base._meta ? base._meta.bases : [base];
			top = 0;
			// add bases to the name map
			for(j = lin.length - 1; j >= 0; --j){
				proto = lin[j].prototype;
				if(!proto.hasOwnProperty("declaredClass")){
					proto.declaredClass = "uniqName_" + (counter++);
				}
				name = proto.declaredClass;
				if(!nameMap.hasOwnProperty(name)){
					nameMap[name] = {count: 0, refs: [], cls: lin[j]};
					++clsCount;
				}
				rec = nameMap[name];
				if(top && top !== rec){
					rec.refs.push(top);
					++top.count;
				}
				top = rec;
			}
			++top.count;
			roots[0].refs.push(top);
		}

		// remove classes without external references recursively
		while(roots.length){
			top = roots.pop();
			result.push(top.cls);
			--clsCount;
			// optimization: follow a single-linked chain
			while(refs = top.refs, refs.length == 1){
				top = refs[0];
				if(!top || --top.count){
					// branch or end of chain => do not end to roots
					top = 0;
					break;
				}
				result.push(top.cls);
				--clsCount;
			}
			if(top){
				// branch
				for(i = 0, l = refs.length; i < l; ++i){
					top = refs[i];
					if(!--top.count){
						roots.push(top);
					}
				}
			}
		}
		if(clsCount){
			err("can't build consistent linearization", className);
		}

		// calculate the superclass offset
		base = bases[0];
		result[0] = base ?
			base._meta && base === result[result.length - base._meta.bases.length] ?
				base._meta.bases.length : 1 : 0;

		return result;
	}

	function inherited(args, a, f, g){
		var name, chains, bases, caller, meta, base, proto, opf, pos,
			cache = this._inherited = this._inherited || {};

		// crack arguments
		if(typeof args === "string"){
			name = args;
			args = a;
			a = f;
			f = g;
		}

		if(typeof args === "function"){
			// support strict mode
			caller = args;
			args = a;
			a = f;
		}else{
			try{
				caller = args.callee;
			}catch (e){
				if(e instanceof TypeError){
					// caller was defined in a strict-mode context
					err("strict mode inherited() requires the caller function to be passed before arguments", this.declaredClass);
				}else{
					throw e;
				}
			}
		}

		name = name || caller.nom;
		if(!name){
			err("can't deduce a name to call inherited()", this.declaredClass);
		}
		f = g = 0;

		meta = this.constructor._meta;
		bases = meta.bases;

		pos = cache.p;
		if(name != cname){
			// method
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				base = bases[0];
				meta = base._meta;
				if(meta.hidden[name] !== caller){
					// error detection
					chains = meta.chains;
					if(chains && typeof chains[name] == "string"){
						err("calling chained method with inherited: " + name, this.declaredClass);
					}
					// find caller
					do{
						meta = base._meta;
						proto = base.prototype;
						if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
					pos = base ? pos : -1;
				}
			}
			// find next
			base = bases[++pos];
			if(base){
				proto = base.prototype;
				if(base._meta && proto.hasOwnProperty(name)){
					f = proto[name];
				}else{
					opf = op[name];
					do{
						proto = base.prototype;
						f = proto[name];
						if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
							break;
						}
					}while(base = bases[++pos]); // intentional assignment
				}
			}
			f = base && f || op[name];
		}else{
			// constructor
			if(cache.c !== caller){
				// cache bust
				pos = 0;
				meta = bases[0]._meta;
				if(meta && meta.ctor !== caller){
					// error detection
					chains = meta.chains;
					if(!chains || chains.constructor !== "manual"){
						err("calling chained constructor with inherited", this.declaredClass);
					}
					// find caller
					while(base = bases[++pos]){ // intentional assignment
						meta = base._meta;
						if(meta && meta.ctor === caller){
							break;
						}
					}
					pos = base ? pos : -1;
				}
			}
			// find next
			while(base = bases[++pos]){	// intentional assignment
				meta = base._meta;
				f = meta ? meta.ctor : base;
				if(f){
					break;
				}
			}
			f = base && f;
		}

		// cache the found super method
		cache.c = f;
		cache.p = pos;

		// now we have the result
		if(f){
			return a === true ? f : f.apply(this, a || args);
		}
		// intentionally no return if a super method was not found
	}

	function getInherited(name, args, a){
		if(typeof name === "string"){
			if (typeof args === "function") {
				return this.__inherited(name, args, a, true);
			}
			return this.__inherited(name, args, true);
		}
		else if (typeof name === "function") {
			return this.__inherited(name, args, true);
		}
		return this.__inherited(name, true);
	}

	function inherited__debug(args, a1, a2, a3){
		var f = this.getInherited(args, a1, a2);
		if(f){
			return f.apply(this, a3 || a2 || a1 || args);
		}
		// intentionally no return if a super method was not found
	}

	var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;

	// emulation of "instanceof"
	function isInstanceOf(cls){
		var bases = this.constructor._meta.bases;
		for(var i = 0, l = bases.length; i < l; ++i){
			if(bases[i] === cls){
				return true;
			}
		}
		return this instanceof cls;
	}

	function mixOwn(target, source){
		// add props adding metadata for incoming functions skipping a constructor
		for(var name in source){
			if(name != cname && source.hasOwnProperty(name)){
				target[name] = source[name];
			}
		}
		if(has("bug-for-in-skips-shadowed")){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				if(name != cname && source.hasOwnProperty(name)){
					  target[name] = source[name];
				}
			}
		}
	}

	// implementation of safe mixin function
	function safeMixin(target, source){
		// summary:
		//		Mix in properties skipping a constructor and decorating functions
		//		like it is done by declare().
		// target: Object
		//		Target object to accept new properties.
		// source: Object
		//		Source object for new properties.
		// description:
		//		This function is used to mix in properties like lang.mixin does,
		//		but it skips a constructor property and decorates functions like
		//		declare() does.
		//
		//		It is meant to be used with classes and objects produced with
		//		declare. Functions mixed in with dojo.safeMixin can use
		//		this.inherited() like normal methods.
		//
		//		This function is used to implement extend() method of a constructor
		//		produced with declare().
		//
		// example:
		//	|	var A = declare(null, {
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m1");
		//	|		}
		//	|	});
		//	|	B.extend({
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	dojo.safeMixin(x, {
		//	|		m1: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m1");
		//	|		},
		//	|		m2: function(){
		//	|			this.inherited(arguments);
		//	|			console.log("X.m2");
		//	|		}
		//	|	});
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m1
		//	|	// B.m1
		//	|	// X.m1

		var name, t;
		// add props adding metadata for incoming functions skipping a constructor
		for(name in source){
			t = source[name];
			if((t !== op[name] || !(name in op)) && name != cname){
				if(opts.call(t) == "[object Function]"){
					// non-trivial function method => attach its name
					t.nom = name;
				}
				target[name] = t;
			}
		}
		if(has("bug-for-in-skips-shadowed") && source){
			for(var extraNames= lang._extraNames, i= extraNames.length; i;){
				name = extraNames[--i];
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						  t.nom = name;
					}
					target[name] = t;
				}
			}
		}
		return target;
	}

	function extend(source){
		declare.safeMixin(this.prototype, source);
		return this;
	}

	function createSubclass(mixins, props){
		// crack parameters
		if(!(mixins instanceof Array || typeof mixins === 'function')){
			props = mixins;
			mixins = undefined;
		}

		props = props || {};
		mixins = mixins || [];

		return declare([this].concat(mixins), props);
	}

	// chained constructor compatible with the legacy declare()
	function chainedConstructor(bases, ctorSpecial){
		return function(){
			var a = arguments, args = a, a0 = a[0], f, i, m,
				l = bases.length, preArgs;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
				// full blown ritual
				preArgs = new Array(bases.length);
				// prepare parameters
				preArgs[0] = a;
				for(i = 0;;){
					// process the preamble of the 1st argument
					a0 = a[0];
					if(a0){
						f = a0.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
					}
					// process the preamble of this class
					f = bases[i].prototype;
					f = f.hasOwnProperty("preamble") && f.preamble;
					if(f){
						a = f.apply(this, a) || a;
					}
					// one peculiarity of the preamble:
					// it is called if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
					if(++i == l){
						break;
					}
					preArgs[i] = a;
				}
			}
			// 2) call all non-trivial constructors using prepared arguments
			for(i = l - 1; i >= 0; --i){
				f = bases[i];
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, preArgs ? preArgs[i] : a);
				}
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, args);
			}
		};
	}


	// chained constructor compatible with the legacy declare()
	function singleConstructor(ctor, ctorSpecial){
		return function(){
			var a = arguments, t = a, a0 = a[0], f;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) call two types of the preamble
			if(ctorSpecial){
				// full blown ritual
				if(a0){
					// process the preamble of the 1st argument
					f = a0.preamble;
					if(f){
						t = f.apply(this, t) || t;
					}
				}
				f = this.preamble;
				if(f){
					// process the preamble of this class
					f.apply(this, t);
					// one peculiarity of the preamble:
					// it is called even if it is not needed,
					// e.g., there is no constructor to call
					// let's watch for the last constructor
					// (see ticket #9795)
				}
			}
			// 2) call a constructor
			if(ctor){
				ctor.apply(this, a);
			}
			// 3) continue the original ritual: call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	// plain vanilla constructor (can use inherited() to call its base constructor)
	function simpleConstructor(bases){
		return function(){
			var a = arguments, i = 0, f, m;

			if(!(this instanceof a.callee)){
				// not called via new, so force it
				return applyNew(a);
			}

			//this._inherited = {};
			// perform the shaman's rituals of the original declare()
			// 1) do not call the preamble
			// 2) call the top constructor (it can use this.inherited())
			for(; f = bases[i]; ++i){ // intentional assignment
				m = f._meta;
				f = m ? m.ctor : f;
				if(f){
					f.apply(this, a);
					break;
				}
			}
			// 3) call the postscript
			f = this.postscript;
			if(f){
				f.apply(this, a);
			}
		};
	}

	function chain(name, bases, reversed){
		return function(){
			var b, m, f, i = 0, step = 1;
			if(reversed){
				i = bases.length - 1;
				step = -1;
			}
			for(; b = bases[i]; i += step){ // intentional assignment
				m = b._meta;
				f = (m ? m.hidden : b.prototype)[name];
				if(f){
					f.apply(this, arguments);
				}
			}
		};
	}

	// forceNew(ctor)
	// return a new object that inherits from ctor.prototype but
	// without actually running ctor on the object.
	function forceNew(ctor){
		// create object with correct prototype using a do-nothing
		// constructor
		xtor.prototype = ctor.prototype;
		var t = new xtor;
		xtor.prototype = null;	// clean up
		return t;
	}

	// applyNew(args)
	// just like 'new ctor()' except that the constructor and its arguments come
	// from args, which must be an array or an arguments object
	function applyNew(args){
		// create an object with ctor's prototype but without
		// calling ctor on it.
		var ctor = args.callee, t = forceNew(ctor);
		// execute the real constructor on the new object
		ctor.apply(t, args);
		return t;
	}

	function declare(className, superclass, props){
		// summary:
		//		Create a feature-rich constructor from compact notation.
		// className: String?
		//		The optional name of the constructor (loosely, a "class")
		//		stored in the "declaredClass" property in the created prototype.
		//		It will be used as a global name for a created constructor.
		// superclass: Function|Function[]
		//		May be null, a Function, or an Array of Functions. This argument
		//		specifies a list of bases (the left-most one is the most deepest
		//		base).
		// props: Object
		//		An object whose properties are copied to the created prototype.
		//		Add an instance-initialization function by making it a property
		//		named "constructor".
		// returns: dojo/_base/declare.__DeclareCreatedObject
		//		New constructor function.
		// description:
		//		Create a constructor using a compact notation for inheritance and
		//		prototype extension.
		//
		//		Mixin ancestors provide a type of multiple inheritance.
		//		Prototypes of mixin ancestors are copied to the new class:
		//		changes to mixin prototypes will not affect classes to which
		//		they have been mixed in.
		//
		//		Ancestors can be compound classes created by this version of
		//		declare(). In complex cases all base classes are going to be
		//		linearized according to C3 MRO algorithm
		//		(see http://www.python.org/download/releases/2.3/mro/ for more
		//		details).
		//
		//		"className" is cached in "declaredClass" property of the new class,
		//		if it was supplied. The immediate super class will be cached in
		//		"superclass" property of the new class.
		//
		//		Methods in "props" will be copied and modified: "nom" property
		//		(the declared name of the method) will be added to all copied
		//		functions to help identify them for the internal machinery. Be
		//		very careful, while reusing methods: if you use the same
		//		function under different names, it can produce errors in some
		//		cases.
		//
		//		It is possible to use constructors created "manually" (without
		//		declare()) as bases. They will be called as usual during the
		//		creation of an instance, their methods will be chained, and even
		//		called by "this.inherited()".
		//
		//		Special property "-chains-" governs how to chain methods. It is
		//		a dictionary, which uses method names as keys, and hint strings
		//		as values. If a hint string is "after", this method will be
		//		called after methods of its base classes. If a hint string is
		//		"before", this method will be called before methods of its base
		//		classes.
		//
		//		If "constructor" is not mentioned in "-chains-" property, it will
		//		be chained using the legacy mode: using "after" chaining,
		//		calling preamble() method before each constructor, if available,
		//		and calling postscript() after all constructors were executed.
		//		If the hint is "after", it is chained as a regular method, but
		//		postscript() will be called after the chain of constructors.
		//		"constructor" cannot be chained "before", but it allows
		//		a special hint string: "manual", which means that constructors
		//		are not going to be chained in any way, and programmer will call
		//		them manually using this.inherited(). In the latter case
		//		postscript() will be called after the construction.
		//
		//		All chaining hints are "inherited" from base classes and
		//		potentially can be overridden. Be very careful when overriding
		//		hints! Make sure that all chained methods can work in a proposed
		//		manner of chaining.
		//
		//		Once a method was chained, it is impossible to unchain it. The
		//		only exception is "constructor". You don't need to define a
		//		method in order to supply a chaining hint.
		//
		//		If a method is chained, it cannot use this.inherited() because
		//		all other methods in the hierarchy will be called automatically.
		//
		//		Usually constructors and initializers of any kind are chained
		//		using "after" and destructors of any kind are chained as
		//		"before". Note that chaining assumes that chained methods do not
		//		return any value: any returned value will be discarded.
		//
		// example:
		//	|	declare("my.classes.bar", my.classes.foo, {
		//	|		// properties to be added to the class prototype
		//	|		someValue: 2,
		//	|		// initialization function
		//	|		constructor: function(){
		//	|			this.myComplicatedObject = new ReallyComplicatedObject();
		//	|		},
		//	|		// other functions
		//	|		someMethod: function(){
		//	|			doStuff();
		//	|		}
		//	|	});
		//
		// example:
		//	|	var MyBase = declare(null, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass1 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyClass2 = declare(MyBase, {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//	|	var MyDiamond = declare([MyClass1, MyClass2], {
		//	|		// constructor, properties, and methods go here
		//	|		// ...
		//	|	});
		//
		// example:
		//	|	var F = function(){ console.log("raw constructor"); };
		//	|	F.prototype.method = function(){
		//	|		console.log("raw method");
		//	|	};
		//	|	var A = declare(F, {
		//	|		constructor: function(){
		//	|			console.log("A.constructor");
		//	|		},
		//	|		method: function(){
		//	|			console.log("before calling F.method...");
		//	|			this.inherited(arguments);
		//	|			console.log("...back in A");
		//	|		}
		//	|	});
		//	|	new A().method();
		//	|	// will print:
		//	|	// raw constructor
		//	|	// A.constructor
		//	|	// before calling F.method...
		//	|	// raw method
		//	|	// ...back in A
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			destroy: "before"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			console.log("B.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("B.destroy");
		//	|		}
		//	|	});
		//	|	var C = declare(B, {
		//	|		constructor: function(){
		//	|			console.log("C.constructor");
		//	|		},
		//	|		destroy: function(){
		//	|			console.log("C.destroy");
		//	|		}
		//	|	});
		//	|	new C().destroy();
		//	|	// prints:
		//	|	// B.constructor
		//	|	// C.constructor
		//	|	// C.destroy
		//	|	// B.destroy
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			constructor: "manual"
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		constructor: function(){
		//	|			// ...
		//	|			// call the base constructor with new parameters
		//	|			this.inherited(arguments, [1, 2, 3]);
		//	|			// ...
		//	|		}
		//	|	});
		//
		// example:
		//	|	var A = declare(null, {
		//	|		"-chains-": {
		//	|			m1: "before"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("A.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("A.m2");
		//	|		}
		//	|	});
		//	|	var B = declare(A, {
		//	|		"-chains-": {
		//	|			m2: "after"
		//	|		},
		//	|		m1: function(){
		//	|			console.log("B.m1");
		//	|		},
		//	|		m2: function(){
		//	|			console.log("B.m2");
		//	|		}
		//	|	});
		//	|	var x = new B();
		//	|	x.m1();
		//	|	// prints:
		//	|	// B.m1
		//	|	// A.m1
		//	|	x.m2();
		//	|	// prints:
		//	|	// A.m2
		//	|	// B.m2

		// crack parameters
		if(typeof className != "string"){
			props = superclass;
			superclass = className;
			className = "";
		}
		props = props || {};

		var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;

		// build a prototype
		if(opts.call(superclass) == "[object Array]"){
			// C3 MRO
			bases = c3mro(superclass, className);
			t = bases[0];
			mixins = bases.length - t;
			superclass = bases[mixins];
		}else{
			bases = [0];
			if(superclass){
				if(opts.call(superclass) == "[object Function]"){
					t = superclass._meta;
					bases = bases.concat(t ? t.bases : superclass);
				}else{
					err("base class is not a callable constructor.", className);
				}
			}else if(superclass !== null){
				err("unknown base class. Did you use dojo.require to pull it in?", className);
			}
		}
		if(superclass){
			for(i = mixins - 1;; --i){
				proto = forceNew(superclass);
				if(!i){
					// stop if nothing to add (the last base)
					break;
				}
				// mix in properties
				t = bases[i];
				(t._meta ? mixOwn : mix)(proto, t.prototype);
				// chain in new constructor
				if (has("csp-restrictions")) {
					ctor = function () {};
				}
				else {
					ctor = new Function;
				}
				ctor.superclass = superclass;
				ctor.prototype = proto;
				superclass = proto.constructor = ctor;
			}
		}else{
			proto = {};
		}
		// add all properties
		declare.safeMixin(proto, props);
		// add constructor
		t = props.constructor;
		if(t !== op.constructor){
			t.nom = cname;
			proto.constructor = t;
		}

		// collect chains and flags
		for(i = mixins - 1; i; --i){ // intentional assignment
			t = bases[i]._meta;
			if(t && t.chains){
				chains = mix(chains || {}, t.chains);
			}
		}
		if(proto["-chains-"]){
			chains = mix(chains || {}, proto["-chains-"]);
		}

		if(superclass && superclass.prototype && superclass.prototype["-chains-"]) {
			chains = mix(chains || {}, superclass.prototype["-chains-"]);
		}

		// build ctor
		t = !chains || !chains.hasOwnProperty(cname);
		bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
			(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));

		// add meta information to the constructor
		ctor._meta  = {bases: bases, hidden: props, chains: chains,
			parents: parents, ctor: props.constructor};
		ctor.superclass = superclass && superclass.prototype;
		ctor.extend = extend;
		ctor.createSubclass = createSubclass;
		ctor.prototype = proto;
		proto.constructor = ctor;

		// add "standard" methods to the prototype
		proto.getInherited = getInherited;
		proto.isInstanceOf = isInstanceOf;
		proto.inherited    = inheritedImpl;
		proto.__inherited  = inherited;

		// add name if specified
		if(className){
			proto.declaredClass = className;
			lang.setObject(className, ctor);
		}

		// build chains and add them to the prototype
		if(chains){
			for(name in chains){
				if(proto[name] && typeof chains[name] == "string" && name != cname){
					t = proto[name] = chain(name, bases, chains[name] === "after");
					t.nom = name;
				}
			}
		}
		// chained methods do not return values
		// no need to chain "invisible" functions

		return ctor;	// Function
	}

	/*=====
	declare.__DeclareCreatedObject = {
		// summary:
		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
		//		methods, in addition to the methods and properties specified via the arguments passed to declare().

		inherited: function(name, caller, args, newArgs){
			// summary:
			//		Calls a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// caller: Function?
			//		The reference to the calling function. Required only if the
			//		call to "this.inherited" occurs from within strict-mode code.
			//		If the caller is omitted within strict-mode code, an error will
			//		be thrown.
			//		The best way to obtain a reference to the calling function is to
			//		use a named function expression (i.e. place a function name
			//		after the "function" keyword and before the open paren, as in
			//		"function fn(a, b)"). If the function is parsed as an expression
			//		and not a statement (i.e. it's not by itself on its own line),
			//		the function name will only be accessible as an identifier from
			//		within the body of the function.
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// newArgs: Object?
			//		If "true", the found function will be returned without
			//		executing it.
			//		If Array, it will be used to call a super method. Otherwise
			//		"args" will be used.
			// returns:
			//		Whatever is returned by a super method, or a super method itself,
			//		if "true" was specified as newArgs.
			// description:
			//		This method is used inside method of classes produced with
			//		declare() to call a super method (next in the chain). It is
			//		used for manually controlled chaining. Consider using the regular
			//		chaining, because it is faster. Use "this.inherited()" only in
			//		complex cases.
			//
			//		This method cannot me called from automatically chained
			//		constructors including the case of a special (legacy)
			//		constructor chaining. It cannot be called from chained methods.
			//
			//		If "this.inherited()" cannot find the next-in-chain method, it
			//		does nothing and returns "undefined". The last method in chain
			//		can be a default method implemented in Object, which will be
			//		called last.
			//
			//		If "name" is specified, it is assumed that the method that
			//		received "args" is the parent method for this call. It is looked
			//		up in the chain list and if it is found the next-in-chain method
			//		is called. If it is not found, the first-in-chain method is
			//		called.
			//
			//		If "name" is not specified, it will be derived from the calling
			//		method (using a methoid property "nom").
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method1: function(a, b, c){
			//	|			this.inherited(arguments);
			//	|		},
			//	|		method2: function(a, b){
			//	|			return this.inherited(arguments, [a + b]);
			//	|		}
			//	|	});
			//	|	// next method is not in the chain list because it is added
			//	|	// manually after the class was created.
			//	|	B.prototype.method3 = function(){
			//	|		console.log("This is a dynamically-added method.");
			//	|		this.inherited("method3", arguments);
			//	|	};
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.inherited(arguments, true);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			// example:
			//	|	"use strict";
			//	|	// class is defined in strict-mode code,
			//	|	// so caller must be passed before arguments.
			//	|	var B = declare(A, {
			//	|		// using a named function expression with "fn" as the name.
			//	|		method: function fn(a, b) {
			//	|			this.inherited(fn, arguments);
			//	|		}
			//	|	});
			return	{};	// Object
		},

		getInherited: function(name, caller, args){
			// summary:
			//		Returns a super method.
			// name: String?
			//		The optional method name. Should be the same as the caller's
			//		name. Usually "name" is specified in complex dynamic cases, when
			//		the calling method was dynamically added, undecorated by
			//		declare(), and it cannot be determined.
			// caller: Function?
			//		The caller function. This is required when running in
			//		strict-mode code. A reference to the caller function
			//		can be obtained by using a named function expression
			//		(e.g. function fn(a,b) {...}).
			// args: Arguments
			//		The caller supply this argument, which should be the original
			//		"arguments".
			// returns:
			//		Returns a super method (Function) or "undefined".
			// description:
			//		This method is a convenience method for "this.inherited()".
			//		It uses the same algorithm but instead of executing a super
			//		method, it returns it, or "undefined" if not found.
			//
			// example:
			//	|	var B = declare(A, {
			//	|		method: function(a, b){
			//	|			var super = this.getInherited(arguments);
			//	|			// ...
			//	|			if(!super){
			//	|				console.log("there is no super method");
			//	|				return 0;
			//	|			}
			//	|			return super.apply(this, arguments);
			//	|		}
			//	|	});
			// example:
			//	|	"use strict;" // first line of function or file
			//	|	//...
			//	|	var B = declare(A, {
			//	|		// Using a named function expression with "fn" as the name,
			//	|		// since we're in strict mode.
			//	|		method: function fn(a, b){
			//	|			var super = this.getInherited(fn, arguments);
			//	|			if(super){
			//	|				return super.apply(this, arguments);
			//	|			}
			//	|		}
			//	|	});
			return	{};	// Object
		},

		isInstanceOf: function(cls){
			// summary:
			//		Checks the inheritance chain to see if it is inherited from this
			//		class.
			// cls: Function
			//		Class constructor.
			// returns:
			//		"true", if this object is inherited from this class, "false"
			//		otherwise.
			// description:
			//		This method is used with instances of classes produced with
			//		declare() to determine of they support a certain interface or
			//		not. It models "instanceof" operator.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var B = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var C = declare([A, B], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var D = declare(A, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|
			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
			//	|
			//	|	console.log(a.isInstanceOf(A)); // true
			//	|	console.log(b.isInstanceOf(A)); // false
			//	|	console.log(c.isInstanceOf(A)); // true
			//	|	console.log(d.isInstanceOf(A)); // true
			//	|
			//	|	console.log(a.isInstanceOf(B)); // false
			//	|	console.log(b.isInstanceOf(B)); // true
			//	|	console.log(c.isInstanceOf(B)); // true
			//	|	console.log(d.isInstanceOf(B)); // false
			//	|
			//	|	console.log(a.isInstanceOf(C)); // false
			//	|	console.log(b.isInstanceOf(C)); // false
			//	|	console.log(c.isInstanceOf(C)); // true
			//	|	console.log(d.isInstanceOf(C)); // false
			//	|
			//	|	console.log(a.isInstanceOf(D)); // false
			//	|	console.log(b.isInstanceOf(D)); // false
			//	|	console.log(c.isInstanceOf(D)); // false
			//	|	console.log(d.isInstanceOf(D)); // true
			return	{};	// Object
		},

		extend: function(source){
			// summary:
			//		Adds all properties and methods of source to constructor's
			//		prototype, making them available to all instances created with
			//		constructor. This method is specific to constructors created with
			//		declare().
			// source: Object
			//		Source object which properties are going to be copied to the
			//		constructor's prototype.
			// description:
			//		Adds source properties to the constructor's prototype. It can
			//		override existing properties.
			//
			//		This method is similar to dojo.extend function, but it is specific
			//		to constructors produced by declare(). It is implemented
			//		using dojo.safeMixin, and it skips a constructor property,
			//		and properly decorates copied functions.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "Popokatepetl"
			//	|	});
			//	|	A.extend({
			//	|		m1: function(){},
			//	|		m2: function(){},
			//	|		f1: true,
			//	|		d1: 42
			//	|	});
		},

		createSubclass: function(mixins, props){
			// summary:
			//		Create a subclass of the declared class from a list of base classes.
			// mixins: Function[]
			//		Specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object?
			//		An optional object whose properties are copied to the created prototype.
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){},
			//	|		s1: "bar"
			//	|	});
			//	|	var B = declare(null, {
			//	|		m2: function(){},
			//	|		s2: "foo"
			//	|	});
			//	|	var C = declare(null, {
			//	|	});
			//	|	var D1 = A.createSubclass([B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d1 = new D1();
			//	|
			//	|	// this is equivalent to:
			//	|	var D2 = declare([A, B, C], {
			//	|		m1: function(){},
			//	|		d1: 42
			//	|	});
			//	|	var d2 = new D2();
		}
	};
	=====*/

	// For back-compat, remove for 2.0
	dojo.safeMixin = declare.safeMixin = safeMixin;
	dojo.declare = declare;

	return declare;
});

},
'dojo/dom':function(){
define(["./sniff", "./_base/window", "./_base/kernel"],
		function(has, win, kernel){
	// module:
	//		dojo/dom

	// FIXME: need to add unit tests for all the semi-public methods

	if(has("ie") <= 7){
		try{
			document.execCommand("BackgroundImageCache", false, true);
		}catch(e){
			// sane browsers don't have cache "issues"
		}
	}

	// =============================
	// DOM Functions
	// =============================

	// the result object
	var dom = {
		// summary:
		//		This module defines the core dojo DOM API.
	};

	if(has("ie")){
		dom.byId = function(id, doc){
			if(typeof id != "string"){
				return id || null;
			}
			var _d = doc || win.doc, te = id && _d.getElementById(id);
			// attributes.id.value is better than just id in case the
			// user has a name=id inside a form
			if(te && (te.attributes.id.value == id || te.id == id)){
				return te;
			}else{
				var eles = _d.all[id];
				if(!eles || eles.nodeName){
					eles = [eles];
				}
				// if more than 1, choose first with the correct id
				var i = 0;
				while((te = eles[i++])){
					if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
						return te;
					}
				}
			}
			return null;
		};
	}else{
		dom.byId = function(id, doc){
			// inline'd type check.
			// be sure to return null per documentation, to match IE branch.
			return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
		};
	}
	/*=====
	 dom.byId = function(id, doc){
		// summary:
		//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
		//		if not found.  If `id` is a DomNode, this function is a no-op.
		//
		// id: String|DOMNode
		//		A string to match an HTML id attribute or a reference to a DOM Node
		//
		// doc: Document?
		//		Document to work in. Defaults to the current value of
		//		dojo/_base/window.doc.  Can be used to retrieve
		//		node references from other documents.
		//
		// example:
		//		Look up a node by ID:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("foo");
		//	|	});
		//
		// example:
		//		Check if a node exists, and use it.
		//	|	require(["dojo/dom"], function(dom){
		//	|		var n = dom.byId("bar");
		//	|		if(n){ doStuff() ... }
		//	|	});
		//
		// example:
		//		Allow string or DomNode references to be passed to a custom function:
		//	|	require(["dojo/dom"], function(dom){
		//	|		var foo = function(nodeOrId){
		//	|			nodeOrId = dom.byId(nodeOrId);
		//	|			// ... more stuff
		//	|		}
		//	|	});
	 };
	 =====*/

	// Test for DOMNode.contains() method, available everywhere except FF8-
	// and IE8-, where it's available in general, but not on document itself,
	// and also problems when either ancestor or node are text nodes.

	var doc = kernel.global["document"] || null;
	has.add("dom-contains", !!(doc && doc.contains));
	dom.isDescendant = has("dom-contains") ?
		// FF9+, IE9+, webkit, opera, iOS, Android, Edge, etc.
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			return !!( (ancestor = dom.byId(ancestor)) && ancestor.contains(dom.byId(node)) );
		} :
		function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
			// summary:
			//		Returns true if node is a descendant of ancestor
			// node: DOMNode|String
			//		string id or node reference to test
			// ancestor: DOMNode|String
			//		string id or node reference of potential parent to test against
			//
			// example:
			//		Test is node id="bar" is a descendant of node id="foo"
			//	|	require(["dojo/dom"], function(dom){
			//	|		if(dom.isDescendant("bar", "foo")){ ... }
			//	|	});

			try{
				node = dom.byId(node);
				ancestor = dom.byId(ancestor);
				while(node){
					if(node == ancestor){
						return true; // Boolean
					}
					node = node.parentNode;
				}
			}catch(e){ /* squelch, return false */ }
			return false; // Boolean
		};

	// TODO: do we need setSelectable in the base?

	// Add feature test for user-select CSS property
	// (currently known to work in all but IE < 10 and Opera)
	// TODO: The user-select CSS property as of May 2014 is no longer part of
	// any CSS specification. In IE, -ms-user-select does not do the same thing
	// as the unselectable attribute on elements; namely, dijit Editor buttons
	// do not properly prevent the content of the editable content frame from
	// unblurring. As a result, the -ms- prefixed version is omitted here.
	has.add("css-user-select", function(global, doc, element){
		// Avoid exception when dom.js is loaded in non-browser environments
		if(!element){ return false; }

		var style = element.style;
		var prefixes = ["Khtml", "O", "Moz", "Webkit"],
			i = prefixes.length,
			name = "userSelect",
			prefix;

		// Iterate prefixes from most to least likely
		do{
			if(typeof style[name] !== "undefined"){
				// Supported; return property name
				return name;
			}
		}while(i-- && (name = prefixes[i] + "UserSelect"));

		// Not supported if we didn't return before now
		return false;
	});

	/*=====
	dom.setSelectable = function(node, selectable){
		// summary:
		//		Enable or disable selection on a node
		// node: DOMNode|String
		//		id or reference to node
		// selectable: Boolean
		//		state to put the node in. false indicates unselectable, true
		//		allows selection.
		// example:
		//		Make the node id="bar" unselectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar");
		//	|	});
		// example:
		//		Make the node id="bar" selectable
		//	|	require(["dojo/dom"], function(dom){
		//	|		dom.setSelectable("bar", true);
		//	|	});
	};
	=====*/

	var cssUserSelect = has("css-user-select");
	dom.setSelectable = cssUserSelect ? function(node, selectable){
		// css-user-select returns a (possibly vendor-prefixed) CSS property name
		dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
	} : function(node, selectable){
		node = dom.byId(node);

		// (IE < 10 / Opera) Fall back to setting/removing the
		// unselectable attribute on the element and all its children
		var nodes = node.getElementsByTagName("*"),
			i = nodes.length;

		if(selectable){
			node.removeAttribute("unselectable");
			while(i--){
				nodes[i].removeAttribute("unselectable");
			}
		}else{
			node.setAttribute("unselectable", "on");
			while(i--){
				nodes[i].setAttribute("unselectable", "on");
			}
		}
	};

	return dom;
});

},
'dojo/_base/browser':function(){
if(require.has){
	require.has.add("config-selectorEngine", "acme");
}
define([
	"../ready",
	"./kernel",
	"./connect", // until we decide if connect is going back into non-browser environments
	"./unload",
	"./window",
	"./event",
	"./html",
	"./NodeList",
	"../query",
	"./xhr",
	"./fx"], function(dojo){

	// module:
	//		dojo/_base/browser

	/*=====
	return {
		// summary:
		//		This module causes the browser-only base modules to be loaded.
	};
	=====*/

	return dojo;
});

},
'dojo/errors/RequestTimeoutError':function(){
define(['./create', './RequestError'], function(create, RequestError){
	// module:
	//		dojo/errors/RequestTimeoutError

	/*=====
	 return function(){
		 // summary:
		 //		TODOC
	 };
	 =====*/

	return create("RequestTimeoutError", null, RequestError, {
		dojoType: "timeout"
	});
});

},
'dojo/dom-style':function(){
define(["./sniff", "./dom", "./_base/window"], function(has, dom, win){
	// module:
	//		dojo/dom-style

	// =============================
	// Style Functions
	// =============================

	// getComputedStyle drives most of the style code.
	// Wherever possible, reuse the returned object.
	//
	// API functions below that need to access computed styles accept an
	// optional computedStyle parameter.
	// If this parameter is omitted, the functions will call getComputedStyle themselves.
	// This way, calling code can access computedStyle once, and then pass the reference to
	// multiple API functions.

	// Although we normally eschew argument validation at this
	// level, here we test argument 'node' for (duck)type,
	// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
	// it is frequently sent to this function even
	// though it is not Element.
	var getComputedStyle, style = {
		// summary:
		//		This module defines the core dojo DOM style API.
	};
	if(has("webkit")){
		getComputedStyle = function(/*DomNode*/ node){
			var s;
			if(node.nodeType == 1){
				var dv = node.ownerDocument.defaultView;
				s = dv.getComputedStyle(node, null);
				if(!s && node.style){
					node.style.display = "";
					s = dv.getComputedStyle(node, null);
				}
			}
			return s || {};
		};
	}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
		getComputedStyle = function(node){
			// IE (as of 7) doesn't expose Element like sane browsers
			// currentStyle can be null on IE8!
			return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
		};
	}else{
		getComputedStyle = function(node){
			if(node.nodeType === 1 /* ELEMENT_NODE*/){
				var dv = node.ownerDocument.defaultView,
					w = dv.opener ? dv : win.global.window;
				return w.getComputedStyle(node, null);
			}
			return {};
		};
	}
	style.getComputedStyle = getComputedStyle;
	/*=====
	style.getComputedStyle = function(node){
		// summary:
		//		Returns a "computed style" object.
		//
		// description:
		//		Gets a "computed style" object which can be used to gather
		//		information about the current state of the rendered node.
		//
		//		Note that this may behave differently on different browsers.
		//		Values may have different formats and value encodings across
		//		browsers.
		//
		//		Note also that this method is expensive.  Wherever possible,
		//		reuse the returned object.
		//
		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
		//		return values.
		//
		// node: DOMNode
		//		A reference to a DOM node. Does NOT support taking an
		//		ID string for speed reasons.
		// example:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
		//	|	});
		//
		// example:
		//		Reusing the returned object, avoiding multiple lookups:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
		//	|		var w = cs.width, h = cs.height;
		//	|	});
		return; // CSS2Properties
	};
	=====*/

	var toPixel;
	if(!has("ie")){
		toPixel = function(element, value){
			// style values can be floats, client code may want
			// to round for integer pixels.
			return parseFloat(value) || 0;
		};
	}else{
		toPixel = function(element, avalue){
			if(!avalue){ return 0; }
			// on IE7, medium is usually 4 pixels
			if(avalue == "medium"){ return 4; }
			// style values can be floats, client code may
			// want to round this value for integer pixels.
			if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
			var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
				sLeft = s.left, rsLeft = rs.left;
			rs.left = cs.left;
			try{
				// 'avalue' may be incompatible with style.left, which can cause IE to throw
				// this has been observed for border widths using "thin", "medium", "thick" constants
				// those particular constants could be trapped by a lookup
				// but perhaps there are more
				s.left = avalue;
				avalue = s.pixelLeft;
			}catch(e){
				avalue = 0;
			}
			s.left = sLeft;
			rs.left = rsLeft;
			return avalue;
		};
	}
	style.toPixelValue = toPixel;
	/*=====
	style.toPixelValue = function(node, value){
		// summary:
		//		converts style value to pixels on IE or return a numeric value.
		// node: DOMNode
		// value: String
		// returns: Number
	};
	=====*/

	// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.

	var astr = "DXImageTransform.Microsoft.Alpha";
	var af = function(n, f){
		try{
			return n.filters.item(astr);
		}catch(e){
			return f ? {} : null;
		}
	};

	var _getOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
			try{
				return af(node).Opacity / 100; // Number
			}catch(e){
				return 1; // Number
			}
		} :
		function(node){
			return getComputedStyle(node).opacity;
		};

	var _setOpacity =
		has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
			if(opacity === ""){ opacity = 1; }
			var ov = opacity * 100, fullyOpaque = opacity === 1;

			// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
			// but still update the opacity value so we can get a correct reading if it is read later:
			// af(node, 1).Enabled = !fullyOpaque;

			if(fullyOpaque){
				node.style.zoom = "";
				if(af(node)){
					node.style.filter = node.style.filter.replace(
						new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
				}
			}else{
				node.style.zoom = 1;
				if(af(node)){
					af(node, 1).Opacity = ov;
				}else{
					node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
				}
				af(node, 1).Enabled = true;
			}

			if(node.tagName.toLowerCase() == "tr"){
				for(var td = node.firstChild; td; td = td.nextSibling){
					if(td.tagName.toLowerCase() == "td"){
						_setOpacity(td, opacity);
					}
				}
			}
			return opacity;
		} :
		function(node, opacity){
			return node.style.opacity = opacity;
		};

	var _pixelNamesCache = {
		left: true, top: true
	};
	var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
	function _toStyleValue(node, type, value){
		//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
		type = type.toLowerCase();

		// Adjustments for IE and Edge
		if(value == "auto"){
			if(type == "height"){ return node.offsetHeight; }
			if(type == "width"){ return node.offsetWidth; }
		}
		if(type == "fontweight"){
			switch(value){
				case 700: return "bold";
				case 400:
				default: return "normal";
			}
		}

		if(!(type in _pixelNamesCache)){
			_pixelNamesCache[type] = _pixelRegExp.test(type);
		}
		return _pixelNamesCache[type] ? toPixel(node, value) : value;
	}

	var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};

	// public API

	style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
		// summary:
		//		Accesses styles on a node.
		// description:
		//		Getting the style value uses the computed style for the node, so the value
		//		will be a calculated value, not just the immediate node.style value.
		//		Also when getting values, use specific style names,
		//		like "borderBottomWidth" instead of "border" since compound values like
		//		"border" are not necessarily reflected as expected.
		//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
		//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
		// node: DOMNode|String
		//		id or reference to node to get style for
		// name: String?
		//		the style property to get
		// example:
		//		Passing only an ID or node returns the computed style object of
		//		the node:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger");
		//	|	});
		// example:
		//		Passing a node and a style property returns the current
		//		normalized, computed value for that property:
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.get("thinger", "opacity"); // 1 by default
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		if(l == 2 && op){
			return _getOpacity(n);
		}
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		var s = style.getComputedStyle(n);
		return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
	};

	style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets styles on a node.
		// node: DOMNode|String
		//		id or reference to node to set style for
		// name: String|Object
		//		the style property to set in DOM-accessor format
		//		("borderWidth", not "border-width") or an object with key/value
		//		pairs suitable for setting each property.
		// value: String?
		//		If passed, sets value on the node for style, handling
		//		cross-browser concerns.  When setting a pixel value,
		//		be sure to include "px" in the value. For instance, top: "200px".
		//		Otherwise, in some cases, some browsers will not apply the style.
		//
		// example:
		//		Passing a node, a style property, and a value changes the
		//		current display of the node and returns the new computed value
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
		//	|	});
		//
		// example:
		//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		//	|	require(["dojo/dom-style"], function(domStyle){
		//	|		domStyle.set("thinger", {
		//	|			"opacity": 0.5,
		//	|			"border": "3px solid black",
		//	|			"height": "300px"
		//	|		});
		//	|	});
		//
		// example:
		//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
		//		font-size becomes fontSize, and so on.
		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
		//	|		domStyle.set("thinger",{
		//	|			fontSize:"14pt",
		//	|			letterSpacing:"1.2em"
		//	|		});
		//	|	});
		//
		// example:
		//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
		//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
		//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
		//	|	function(domStyle, query){
		//	|		query(".someClassName").style("visibility","hidden");
		//	|		// or
		//	|		query("#baz > div").style({
		//	|			opacity:0.75,
		//	|			fontSize:"13pt"
		//	|		});
		//	|	});

		var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
		name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
		if(l == 3){
			return op ? _setOpacity(n, value) : n.style[name] = value; // Number
		}
		for(var x in name){
			style.set(node, x, name[x]);
		}
		return style.getComputedStyle(n);
	};

	return style;
});

},
'dojo/dom-geometry':function(){
define(["./sniff", "./_base/window","./dom", "./dom-style"],
		function(has, win, dom, style){
	// module:
	//		dojo/dom-geometry

	// the result object
	var geom = {
		// summary:
		//		This module defines the core dojo DOM geometry API.
	};

	// Box functions will assume this model.
	// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
	// Can be set to change behavior of box setters.

	// can be either:
	//	"border-box"
	//	"content-box" (default)
	geom.boxModel = "content-box";

	// We punt per-node box mode testing completely.
	// If anybody cares, we can provide an additional (optional) unit
	// that overrides existing code to include per-node box sensitivity.

	// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
	// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
	// IIRC, earlier versions of Opera did in fact use border-box.
	// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.

	if(has("ie") /*|| has("opera")*/){
		// client code may have to adjust if compatMode varies across iframes
		geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
	}

	geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with special values specifically useful for node
		//		fitting.
		// description:
		//		Returns an object with `w`, `h`, `l`, `t` properties:
		//	|		l/t/r/b = left/top/right/bottom padding (respectively)
		//	|		w = the total of the left and right padding
		//	|		h = the total of the top and bottom padding
		//		If 'node' has position, l/t forms the origin for child nodes.
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	var none = "none";

	geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object with properties useful for noting the border
		//		dimensions.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right border
		//		- h = the sum of the top and bottom border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
			l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
			t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
			r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
			b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		Returns object with properties useful for box fitting with
		//		regards to padding.
		// description:
		//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
		//		- w = the sum of the left and right padding and border
		//		- h = the sum of the top and bottom padding and border
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node),
			p = geom.getPadExtents(node, s),
			b = geom.getBorderExtents(node, s);
		return {
			l: p.l + b.l,
			t: p.t + b.t,
			r: p.r + b.r,
			b: p.b + b.b,
			w: p.w + b.w,
			h: p.h + b.h
		};
	};

	geom.getMarginExtents = function getMarginExtents(node, computedStyle){
		// summary:
		//		returns object with properties useful for box fitting with
		//		regards to box margins (i.e., the outer-box).
		//
		//		- l/t = marginLeft, marginTop, respectively
		//		- w = total width, margin inclusive
		//		- h = total height, margin inclusive
		//
		//		The w/h are used for calculating boxes.
		//		Normally application code will not need to invoke this
		//		directly, and will use the ...box... functions instead.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
			l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
		return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
	};

	// Box getters work in any box context because offsetWidth/clientWidth
	// are invariant wrt box context
	//
	// They do *not* work for display: inline objects that have padding styles
	// because the user agent ignores padding (it's bogus styling in any case)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.

	// Although it would be easier to read, there are not separate versions of
	// _getMarginBox for each browser because:
	// 1. the branching is not expensive
	// 2. factoring the shared code wastes cycles (function call overhead)
	// 3. duplicating the shared code wastes bytes

	geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width, height, left and top
		//		positions of the node's margin box.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
			l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;

		if((has("ie") == 8 && !has("quirks"))){
			// IE 8 offsetLeft/Top includes the parent's border
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}
		return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
	};

	geom.getContentBox = function getContentBox(node, computedStyle){
		// summary:
		//		Returns an object that encodes the width, height, left and top
		//		positions of the node's content box, irrespective of the
		//		current box model.
		// node: DOMNode
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		// clientWidth/Height are important since the automatically account for scrollbars
		// fallback to offsetWidth/Height for special cases (see #3378)
		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
			pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s), l = node.offsetLeft + pe.l + be.l,
			t = node.offsetTop + pe.t + be.t;
		if(!w){
			w = node.offsetWidth - be.w;
			h = node.offsetHeight - be.h;
		}else{
			h = node.clientHeight;
		}

		if((has("ie") == 8 && !has("quirks"))){
			// IE 8 offsetLeft/Top includes the parent's border
			var p = node.parentNode, px = style.toPixelValue, pcs;
			if(p){
				pcs = style.getComputedStyle(p);
				l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
				t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
			}
		}

		return {l: l, t: t, w: w - pe.w, h: h - pe.h};
	};

	// Box setters depend on box context because interpretation of width/height styles
	// vary wrt box context.
	//
	// The value of boxModel is used to determine box context.
	// boxModel can be set directly to change behavior.
	//
	// Beware of display: inline objects that have padding styles
	// because the user agent ignores padding (it's a bogus setup anyway)
	//
	// Be careful with IMGs because they are inline or block depending on
	// browser and browser mode.
	//
	// Elements other than DIV may have special quirks, like built-in
	// margins or padding, or values not detectable via computedStyle.
	// In particular, margins on TABLE do not seems to appear
	// at all in computedStyle on Mozilla.

	function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
		// summary:
		//		sets width/height/left/top in the current (native) box-model
		//		dimensions. Uses the unit passed in u.
		// node:
		//		DOM Node reference. Id string not supported for performance
		//		reasons.
		// l:
		//		left offset from parent.
		// t:
		//		top offset from parent.
		// w:
		//		width in current box model.
		// h:
		//		width in current box model.
		// u:
		//		unit measure to use for other measures. Defaults to "px".
		u = u || "px";
		var s = node.style;
		if(!isNaN(l)){
			s.left = l + u;
		}
		if(!isNaN(t)){
			s.top = t + u;
		}
		if(w >= 0){
			s.width = w + u;
		}
		if(h >= 0){
			s.height = h + u;
		}
	}

	function isButtonTag(/*DomNode*/ node){
		// summary:
		//		True if the node is BUTTON or INPUT.type="button".
		return node.tagName.toLowerCase() == "button" ||
			node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
	}

	function usesBorderBox(/*DomNode*/ node){
		// summary:
		//		True if the node uses border-box layout.

		// We could test the computed style of node to see if a particular box
		// has been specified, but there are details and we choose not to bother.

		// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
		// If you have assigned a different box to either one via CSS then
		// box functions will break.

		return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
	}

	geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		Sets the size of the node's contents, irrespective of margins,
		//		padding, or borders.
		// node: DOMNode
		// box: Object
		//		hash with optional "w", and "h" properties for "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var w = box.w, h = box.h;
		if(usesBorderBox(node)){
			var pb = geom.getPadBorderExtents(node, computedStyle);
			if(w >= 0){
				w += pb.w;
			}
			if(h >= 0){
				h += pb.h;
			}
		}
		setBox(node, NaN, NaN, w, h);
	};

	var nilExtents = {l: 0, t: 0, w: 0, h: 0};

	geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
		// summary:
		//		sets the size of the node's margin box and placement
		//		(left/top), irrespective of box model. Think of it as a
		//		passthrough to setBox that handles box-model vagaries for
		//		you.
		// node: DOMNode
		// box: Object
		//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
		//		respectively. All specified properties should have numeric values in whole pixels.
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
		// Some elements have special padding, margin, and box-model settings.
		// To use box functions you may need to set padding, margin explicitly.
		// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
			pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
			mb = geom.getMarginExtents(node, s);
		if(has("webkit")){
			// on Safari (3.1.2), button nodes with no explicit size have a default margin
			// setting an explicit size eliminates the margin.
			// We have to swizzle the width to get correct margin reading.
			if(isButtonTag(node)){
				var ns = node.style;
				if(w >= 0 && !ns.width){
					ns.width = "4px";
				}
				if(h >= 0 && !ns.height){
					ns.height = "4px";
				}
			}
		}
		if(w >= 0){
			w = Math.max(w - pb.w - mb.w, 0);
		}
		if(h >= 0){
			h = Math.max(h - pb.h - mb.h, 0);
		}
		setBox(node, box.l, box.t, w, h);
	};

	// =============================
	// Positioning
	// =============================

	geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
		// summary:
		//		Returns true if the current language is left-to-right, and false otherwise.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Boolean

		doc = doc || win.doc;
		return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
	};

	geom.docScroll = function docScroll(/*Document?*/ doc){
		// summary:
		//		Returns an object with {node, x, y} with corresponding offsets.
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Object

		doc = doc || win.doc;
		var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
		return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
			(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
				{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
	};

	geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
		// summary:
		//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
		return {
			x: 0,
			y: 0
		};
	};

	geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
		// summary:
		//		In RTL direction, scrollLeft should be a negative value, but IE
		//		returns a positive one. All codes using documentElement.scrollLeft
		//		must call this function to fix this error, otherwise the position
		//		will offset to right when there is a horizontal scrollbar.
		// scrollLeft: Number
		// doc: Document?
		//		Optional document to query.   If unspecified, use win.doc.
		// returns: Number

		// In RTL direction, scrollLeft should be a negative value, but IE
		// returns a positive one. All codes using documentElement.scrollLeft
		// must call this function to fix this error, otherwise the position
		// will offset to right when there is a horizontal scrollbar.

		doc = doc || win.doc;
		var ie = has("ie");
		if(ie && !geom.isBodyLtr(doc)){
			var qk = has("quirks"),
				de = qk ? win.body(doc) : doc.documentElement,
				pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
			if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
				scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
			}
			return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
		}
		return scrollLeft; // Integer
	};

	geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
		// summary:
		//		Gets the position and size of the passed element relative to
		//		the viewport (if includeScroll==false), or relative to the
		//		document root (if includeScroll==true).
		//
		// description:
		//		Returns an object of the form:
		//		`{ x: 100, y: 300, w: 20, h: 15 }`.
		//		If includeScroll==true, the x and y values will include any
		//		document offsets that may affect the position relative to the
		//		viewport.
		//		Uses the border-box model (inclusive of border and padding but
		//		not margin).  Does not act as a setter.
		// node: DOMNode|String
		// includeScroll: Boolean?
		// returns: Object

		node = dom.byId(node);
		var	db = win.body(node.ownerDocument),
			ret = node.getBoundingClientRect();
		ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};

		if(has("ie") < 9){
			// fixes the position in IE, quirks mode
			ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
			ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
		}

		// account for document scrolling
		// if offsetParent is used, ret value already includes scroll position
		// so we may have to actually remove that value if !includeScroll
		if(includeScroll){
			var scroll = geom.docScroll(node.ownerDocument);
			ret.x += scroll.x;
			ret.y += scroll.y;
		}

		return ret; // Object
	};

	// random "private" functions wildly used throughout the toolkit

	geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
		// summary:
		//		returns an object that encodes the width and height of
		//		the node's margin box
		// node: DOMNode|String
		// computedStyle: Object?
		//		This parameter accepts computed styles object.
		//		If this parameter is omitted, the functions will call
		//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
		//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
		//		computedStyle parameter. Wherever possible, reuse the returned
		//		object of dojo/dom-style.getComputedStyle().

		node = dom.byId(node);
		var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
		var size = node.getBoundingClientRect();
		return {
			w: (size.right - size.left) + me.w,
			h: (size.bottom - size.top) + me.h
		};
	};

	geom.normalizeEvent = function(event){
		// summary:
		//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
		//		offsetX, offsetY, layerX, and layerX properties
		// event: Object
		if(!("layerX" in event)){
			event.layerX = event.offsetX;
			event.layerY = event.offsetY;
		}

		if(!("pageX" in event)){
			// FIXME: scroll position query is duped from dojo/_base/html to
			// avoid dependency on that entire module. Now that HTML is in
			// Base, we should convert back to something similar there.
			var se = event.target;
			var doc = (se && se.ownerDocument) || document;
			// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
			// here rather than document.body
			var docBody = has("quirks") ? doc.body : doc.documentElement;
			event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
			event.pageY = event.clientY + (docBody.scrollTop || 0);
		}
	};

	// TODO: evaluate separate getters/setters for position and sizes?

	return geom;
});

},
'dojo/global':function(){
define(function(){
    if (typeof global !== 'undefined' && typeof global !== 'function') {
        // global spec defines a reference to the global object called 'global'
        // https://github.com/tc39/proposal-global
        // `global` is also defined in NodeJS
        return global;
    }
    else if (typeof window !== 'undefined') {
        // window is defined in browsers
        return window;
    }
    else if (typeof self !== 'undefined') {
        // self is defined in WebWorkers
        return self;
    }
    return this;
});

},
'dojo/dom-prop':function(){
define(["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"],
		function(exports, dojo, has, lang, dom, style, ctr, conn){
	// module:
	//		dojo/dom-prop
	// summary:
	//		This module defines the core dojo DOM properties API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element properties Functions
	// =============================

	// helper to connect events
	var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
	has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });

	exports.names = {
		// properties renamed to avoid clashes with reserved words
		"class": "className",
		"for": "htmlFor",
		// properties written as camelCase
		tabindex: "tabIndex",
		readonly: "readOnly",
		colspan: "colSpan",
		frameborder: "frameBorder",
		rowspan: "rowSpan",
		textcontent: "textContent",
		valuetype: "valueType"
	};
	
	function getText(/*DOMNode*/node){
		// summary:
		//		recursion method for get('textContent') to use. Gets text value for a node.
		// description:
		//		Juse uses nodedValue so things like <br/> tags do not end up in
		//		the text as any sort of line return.
		var text = "", ch = node.childNodes;
		for(var i = 0, n; n = ch[i]; i++){
			//Skip comments.
			if(n.nodeType != 8){
				if(n.nodeType == 1){
					text += getText(n);
				}else{
					text += n.nodeValue;
				}
			}
		}
		return text;
	}

	exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets a property on an HTML element.
		// description:
		//		Handles normalized getting of properties on DOM nodes.
		//
		// node: DOMNode|String
		//		id or reference to the element to get the property on
		// name: String
		//		the name of the property to get.
		// returns:
		//		the value of the requested property or its default value
		//
		// example:
		//	|	// get the current value of the "foo" property on a node
		//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
		//	|		domProp.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domProp.get("nodeId", "foo");
		//	|	});

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		
		if(propName == "textContent" && !has("dom-textContent")){
			return getText(node);
		}
		
		return node[propName];	// Anything
	};

	exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets a property on an HTML element.
		// description:
		//		Handles normalized setting of properties on DOM nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the property on
		// name: String|Object
		//		the name of the property to set, or a hash object to set
		//		multiple properties at once.
		// value: String?
		//		The value to set for the property
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use prop() to set the tab index
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-prop"], function(domProp){
		//	|		domProp.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST",
		//	|		});
		//	|	});

		node = dom.byId(node);
		var l = arguments.length;
		if(l == 2 && typeof name != "string"){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(), propName = exports.names[lc] || name;
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(propName == "innerHTML"){
			// special case: assigning HTML
			// the hash lists elements with read-only innerHTML on IE
			if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
						table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
				ctr.empty(node);
				node.appendChild(ctr.toDom(value, node.ownerDocument));
			}else{
				node[propName] = value;
			}
			return node; // DomNode
		}
		if(propName == "textContent" && !has("dom-textContent")) {
			ctr.empty(node);
			node.appendChild(node.ownerDocument.createTextNode(value));
			return node;
		}
		if(lang.isFunction(value)){
			// special case: assigning an event handler
			// clobber if we can
			var attrId = node[_attrId];
			if(!attrId){
				attrId = _ctr++;
				node[_attrId] = attrId;
			}
			if(!_evtHdlrMap[attrId]){
				_evtHdlrMap[attrId] = {};
			}
			var h = _evtHdlrMap[attrId][propName];
			if(h){
				//h.remove();
				conn.disconnect(h);
			}else{
				try{
					delete node[propName];
				}catch(e){}
			}
			// ensure that event objects are normalized, etc.
			if(value){
				//_evtHdlrMap[attrId][propName] = on(node, propName, value);
				_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
			}else{
				node[propName] = null;
			}
			return node; // DomNode
		}
		node[propName] = value;
		return node;	// DomNode
	};
});

},
'dojo/when':function(){
define([
	"./Deferred",
	"./promise/Promise"
], function(Deferred, Promise){
	"use strict";

	// module:
	//		dojo/when

	return function when(valueOrPromise, callback, errback, progback){
		// summary:
		//		Transparently applies callbacks to values and/or promises.
		// description:
		//		Accepts promises but also transparently handles non-promises. If no
		//		callbacks are provided returns a promise, regardless of the initial
		//		value. Foreign promises are converted.
		//
		//		If callbacks are provided and the initial value is not a promise,
		//		the callback is executed immediately with no error handling. Returns
		//		a promise if the initial value is a promise, or the result of the
		//		callback otherwise.
		// valueOrPromise:
		//		Either a regular value or an object with a `then()` method that
		//		follows the Promises/A specification.
		// callback: Function?
		//		Callback to be invoked when the promise is resolved, or a non-promise
		//		is received.
		// errback: Function?
		//		Callback to be invoked when the promise is rejected.
		// progback: Function?
		//		Callback to be invoked when the promise emits a progress update.
		// returns: dojo/promise/Promise
		//		Promise, or if a callback is provided, the result of the callback.

		var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
		var nativePromise = receivedPromise && valueOrPromise instanceof Promise;

		if(!receivedPromise){
			if(arguments.length > 1){
				return callback ? callback(valueOrPromise) : valueOrPromise;
			}else{
				return new Deferred().resolve(valueOrPromise);
			}
		}else if(!nativePromise){
			var deferred = new Deferred(valueOrPromise.cancel);
			valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
			valueOrPromise = deferred.promise;
		}

		if(callback || errback || progback){
			return valueOrPromise.then(callback, errback, progback);
		}
		return valueOrPromise;
	};
});

},
'dojo/dom-attr':function(){
define(["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"],
		function(exports, has, lang, dom, style, prop){
	// module:
	//		dojo/dom-attr
	// summary:
	//		This module defines the core dojo DOM attributes API.

	// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42

	// =============================
	// Element attribute Functions
	// =============================

	// This module will be obsolete soon. Use dojo/prop instead.

	// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/

	// attribute-related functions (to be obsolete soon)
	var forcePropNames = {
			innerHTML:	1,
			textContent:1,
			className:	1,
			htmlFor:	has("ie") ? 1 : 0,
			value:		1
		},
		attrNames = {
			// original attribute names
			classname: "class",
			htmlfor: "for",
			// for IE
			tabindex: "tabIndex",
			readonly: "readOnly"
		};

	function _hasAttr(node, name){
		var attr = node.getAttributeNode && node.getAttributeNode(name);
		return !!attr && attr.specified; // Boolean
	}
	
	// There is a difference in the presence of certain properties and their default values
	// between browsers. For example, on IE "disabled" is present on all elements,
	// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
	// can return -1.

	exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns true if the requested attribute is specified on the
		//		given element, and false otherwise.
		// node: DOMNode|String
		//		id or reference to the element to check
		// name: String
		//		the name of the attribute
		// returns: Boolean
		//		true if the requested attribute is specified on the
		//		given element, and false otherwise

		var lc = name.toLowerCase();
		return !!forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
	};

	exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Gets an attribute on an HTML element.
		// description:
		//		Handles normalized getting of attributes on DOM Nodes.
		// node: DOMNode|String
		//		id or reference to the element to get the attribute on
		// name: String
		//		the name of the attribute to get.
		// returns:
		//		the value of the requested attribute or null if that attribute does not have a specified or
		//		default value;
		//
		// example:
		//	|	// get the current value of the "foo" attribute on a node
		//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
		//	|		domAttr.get(dom.byId("nodeId"), "foo");
		//	|		// or we can just pass the id:
		//	|		domAttr.get("nodeId", "foo");
		//	|	});	
		//	|	

		node = dom.byId(node);
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName],
			value = node[propName];		// should we access this attribute via a property or via getAttribute()?

		if(forceProp && typeof value != "undefined"){
			// node's property
			return value;	// Anything
		}
		
		if(propName == "textContent"){
			return prop.get(node, propName);
		}
		
		if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
			// node's property
			return value;	// Anything
		}
		// node's attribute
		// we need _hasAttr() here to guard against IE returning a default value
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};

	exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
		// summary:
		//		Sets an attribute on an HTML element.
		// description:
		//		Handles normalized setting of attributes on DOM Nodes.
		//
		//		When passing functions as values, note that they will not be
		//		directly assigned to slots on the node, but rather the default
		//		behavior will be removed and the new behavior will be added
		//		using `dojo.connect()`, meaning that event handler properties
		//		will be normalized and that some caveats with regards to
		//		non-standard behaviors for onsubmit apply. Namely that you
		//		should cancel form submission using `dojo.stopEvent()` on the
		//		passed event object instead of returning a boolean value from
		//		the handler itself.
		// node: DOMNode|String
		//		id or reference to the element to set the attribute on
		// name: String|Object
		//		the name of the attribute to set, or a hash of key-value pairs to set.
		// value: String?
		//		the value to set for the attribute, if the name is a string.
		// returns:
		//		the DOM node
		//
		// example:
		//	|	// use attr() to set the tab index
		//	|	require(["dojo/dom-attr"], function(domAttr){
		//	|		domAttr.set("nodeId", "tabIndex", 3);
		//	|	});
		//
		// example:
		//	Set multiple values at once, including event handlers:
		//	|	require(["dojo/dom-attr"],
		//	|	function(domAttr){
		//	|		domAttr.set("formId", {
		//	|			"foo": "bar",
		//	|			"tabIndex": -1,
		//	|			"method": "POST"
		//	|		}
		//	|	});

		node = dom.byId(node);
		if(arguments.length == 2){ // inline'd type check
			// the object form of setter: the 2nd argument is a dictionary
			for(var x in name){
				exports.set(node, x, name[x]);
			}
			return node; // DomNode
		}
		var lc = name.toLowerCase(),
			propName = prop.names[lc] || name,
			forceProp = forcePropNames[propName];
		if(propName == "style" && typeof value != "string"){ // inline'd type check
			// special case: setting a style
			style.set(node, value);
			return node; // DomNode
		}
		if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
			return prop.set(node, name, value);
		}
		// node's attribute
		node.setAttribute(attrNames[lc] || name, value);
		return node; // DomNode
	};

	exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
		// summary:
		//		Removes an attribute from an HTML element.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute to remove

		dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
	};

	exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
		// summary:
		//		Returns an effective value of a property or an attribute.
		// node: DOMNode|String
		//		id or reference to the element to remove the attribute from
		// name: String
		//		the name of the attribute
		// returns:
		//		the value of the attribute

		node = dom.byId(node);
		var lc = name.toLowerCase(), propName = prop.names[lc] || name;
		if((propName in node) && propName != "href"){
			// node's property
			return node[propName];	// Anything
		}
		// node's attribute
		var attrName = attrNames[lc] || name;
		return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
	};
});

},
'dojo/dom-construct':function(){
define(["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"],
		function(exports, dojo, has, win, dom, attr){
	// module:
	//		dojo/dom-construct
	// summary:
	//		This module defines the core dojo DOM construction API.

	// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42

	// support stuff for toDom()
	var tagWrap = {
			option: ["select"],
			tbody: ["table"],
			thead: ["table"],
			tfoot: ["table"],
			tr: ["table", "tbody"],
			td: ["table", "tbody", "tr"],
			th: ["table", "thead", "tr"],
			legend: ["fieldset"],
			caption: ["table"],
			colgroup: ["table"],
			col: ["table", "colgroup"],
			li: ["ul"]
		},
		reTag = /<\s*([\w\:]+)/,
		masterNode = {}, masterNum = 0,
		masterName = "__" + dojo._scopeName + "ToDomId";

	// generate start/end tag strings to use
	// for the injection for each special tag wrap case.
	for(var param in tagWrap){
		if(tagWrap.hasOwnProperty(param)){
			var tw = tagWrap[param];
			tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
			tw.post = "</" + tw.reverse().join("></") + ">";
			// the last line is destructive: it reverses the array,
			// but we don't care at this point
		}
	}

	var html5domfix;
	if(has("ie") <= 8){
		html5domfix = function(doc){
			doc.__dojo_html5_tested = "yes";
			var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
			if(div.childNodes.length !== 1){
				('abbr article aside audio canvas details figcaption figure footer header ' +
				'hgroup mark meter nav output progress section summary time video').replace(
					/\b\w+\b/g, function(n){
						doc.createElement(n);
					}
				);
			}
			destroy(div);
		}
	}

	function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
		var parent = ref.parentNode;
		if(parent){
			parent.insertBefore(node, ref);
		}
	}

	function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
		// summary:
		//		Try to insert node after ref
		var parent = ref.parentNode;
		if(parent){
			if(parent.lastChild == ref){
				parent.appendChild(node);
			}else{
				parent.insertBefore(node, ref.nextSibling);
			}
		}
	}

	exports.toDom = function toDom(frag, doc){
		// summary:
		//		instantiates an HTML fragment returning the corresponding DOM.
		// frag: String
		//		the HTML fragment
		// doc: DocumentNode?
		//		optional document to use when creating DOM nodes, defaults to
		//		dojo/_base/window.doc if not specified.
		// returns:
		//		Document fragment, unless it's a single node in which case it returns the node itself
		// example:
		//		Create a table row:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
		//	|	});

		doc = doc || win.doc;
		var masterId = doc[masterName];
		if(!masterId){
			doc[masterName] = masterId = ++masterNum + "";
			masterNode[masterId] = doc.createElement("div");
		}

		if(has("ie") <= 8){
			if(!doc.__dojo_html5_tested && doc.body){
				html5domfix(doc);
			}
		}

		// make sure the frag is a string.
		frag += "";

		// find the starting tag, and get node wrapper
		var match = frag.match(reTag),
			tag = match ? match[1].toLowerCase() : "",
			master = masterNode[masterId],
			wrap, i, fc, df;
		if(match && tagWrap[tag]){
			wrap = tagWrap[tag];
			master.innerHTML = wrap.pre + frag + wrap.post;
			for(i = wrap.length; i; --i){
				master = master.firstChild;
			}
		}else{
			master.innerHTML = frag;
		}

		// one node shortcut => return the node itself
		if(master.childNodes.length == 1){
			return master.removeChild(master.firstChild); // DOMNode
		}

		// return multiple nodes as a document fragment
		df = doc.createDocumentFragment();
		while((fc = master.firstChild)){ // intentional assignment
			df.appendChild(fc);
		}
		return df; // DocumentFragment
	};

	exports.place = function place(node, refNode, position){
		// summary:
		//		Attempt to insert node into the DOM, choosing from various positioning options.
		//		Returns the first argument resolved to a DOM node.
		// node: DOMNode|DocumentFragment|String
		//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
		// refNode: DOMNode|String
		//		id or node reference to use as basis for placement
		// position: String|Number?
		//		string noting the position of node relative to refNode or a
		//		number indicating the location in the childNodes collection of refNode.
		//		Accepted string values are:
		//
		//		- before
		//		- after
		//		- replace
		//		- only
		//		- first
		//		- last
		//
		//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
		//		"only" replaces all children.  position defaults to "last" if not specified
		// returns: DOMNode
		//		Returned values is the first argument resolved to a DOM node.
		//
		//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
		// example:
		//		Place a node by string id as the last child of another node by string id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode");
		//	|	});
		// example:
		//		Place a node by string id before another node by string id
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("someNode", "anotherNode", "before");
		//	|	});
		// example:
		//		Create a Node, and place it in the body element (last child):
		//	|	require(["dojo/dom-construct", "dojo/_base/window"
		//	|	], function(domConstruct, win){
		//	|		domConstruct.place("<div></div>", win.body());
		//	|	});
		// example:
		//		Put a new LI as the first child of a list by id:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.place("<li></li>", "someUl", "first");
		//	|	});

		refNode = dom.byId(refNode);
		if(typeof node == "string"){ // inline'd type check
			node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
		}
		if(typeof position == "number"){ // inline'd type check
			var cn = refNode.childNodes;
			if(!cn.length || cn.length <= position){
				refNode.appendChild(node);
			}else{
				_insertBefore(node, cn[position < 0 ? 0 : position]);
			}
		}else{
			switch(position){
				case "before":
					_insertBefore(node, refNode);
					break;
				case "after":
					_insertAfter(node, refNode);
					break;
				case "replace":
					refNode.parentNode.replaceChild(node, refNode);
					break;
				case "only":
					exports.empty(refNode);
					refNode.appendChild(node);
					break;
				case "first":
					if(refNode.firstChild){
						_insertBefore(node, refNode.firstChild);
						break;
					}
					// else fallthrough...
				default: // aka: last
					refNode.appendChild(node);
			}
		}
		return node; // DomNode
	};

	var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
		// summary:
		//		Create an element, allowing for optional attribute decoration
		//		and placement.
		// description:
		//		A DOM Element creation function. A shorthand method for creating a node or
		//		a fragment, and allowing for a convenient optional attribute setting step,
		//		as well as an optional DOM placement reference.
		//
		//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
		//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
		//
		//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
		//		the action node, passing along the optional reference node and position.
		// tag: DOMNode|String
		//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
		//		or an existing DOM node to process.
		// attrs: Object
		//		An object-hash of attributes to set on the newly created node.
		//		Can be null, if you don't want to set any attributes/styles.
		//		See: `dojo/dom-attr.set` for a description of available attributes.
		// refNode: DOMNode|String?
		//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
		//		node somewhere in the dom relative to refNode. Can be a DomNode reference
		//		or String ID of a node.
		// pos: String?
		//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
		//		though can be set to "first","after","before","last", "replace" or "only"
		//		to further control the placement of the new node relative to the refNode.
		//		'refNode' is required if a 'pos' is specified.
		// example:
		//		Create a DIV:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div");
		//	|	});
		//
		// example:
		//		Create a DIV with content:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
		//	|	});
		//
		// example:
		//		Place a new DIV in the BODY, with no attributes set
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		var n = domConstruct.create("div", null, win.body());
		//	|	});
		//
		// example:
		//		Create an UL, and populate it with LI's. Place the list as the first-child of a
		//		node with id="someId":
		//	|	require(["dojo/dom-construct", "dojo/_base/array"],
		//	|	function(domConstruct, arrayUtil){
		//	|		var ul = domConstruct.create("ul", null, "someId", "first");
		//	|		var items = ["one", "two", "three", "four"];
		//	|		arrayUtil.forEach(items, function(data){
		//	|			domConstruct.create("li", { innerHTML: data }, ul);
		//	|		});
		//	|	});
		//
		// example:
		//		Create an anchor, with an href. Place in BODY:
		//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
		//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
		//	|	});

		var doc = win.doc;
		if(refNode){
			refNode = dom.byId(refNode);
			doc = refNode.ownerDocument;
		}
		if(typeof tag == "string"){ // inline'd type check
			tag = doc.createElement(tag);
		}
		if(attrs){ attr.set(tag, attrs); }
		if(refNode){ exports.place(tag, refNode, pos); }
		return tag; // DomNode
	};

	function _empty(/*DomNode*/ node){
		// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
		// and then uncomment the emptyGrandchildren() test case from html.html.
		// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
		// see http://jsperf.com/clear-dom-node.
		if("innerHTML" in node){
			try{
				// fast path
				node.innerHTML = "";
				return;
			}catch(e){
				// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
				// Fall through (saves bytes)
			}
		}

		// SVG/strict elements don't support innerHTML
		for(var c; c = node.lastChild;){ // intentional assignment
			node.removeChild(c);
		}
	}

	exports.empty = function empty(/*DOMNode|String*/ node){
		// summary:
		//		safely removes all children of the node.
		// node: DOMNode|String
		//		a reference to a DOM node or an id.
		// example:
		//		Destroy node's children byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.empty("someId");
		//	|	});

		_empty(dom.byId(node));
	};


	function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
		// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
		if(node.firstChild){
			_empty(node);
		}
		if(parent){
			// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
			// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
			// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
			// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
			has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
		}
	}
	var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
		// summary:
		//		Removes a node from its parent, clobbering it and all of its
		//		children.
		//
		// description:
		//		Removes a node from its parent, clobbering it and all of its
		//		children. Function only works with DomNodes, and returns nothing.
		//
		// node: DOMNode|String
		//		A String ID or DomNode reference of the element to be destroyed
		//
		// example:
		//		Destroy a node byId:
		//	|	require(["dojo/dom-construct"], function(domConstruct){
		//	|		domConstruct.destroy("someId");
		//	|	});

		node = dom.byId(node);
		if(!node){ return; }
		_destroy(node, node.parentNode);
	};
});

},
'dojo/request/xhr':function(){
define([
	'../errors/RequestError',
	'./watch',
	'./handlers',
	'./util',
	'../has'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
	has.add('native-xhr', function(){
		// if true, the environment has a native XHR implementation
		return typeof XMLHttpRequest !== 'undefined';
	});
	has.add('dojo-force-activex-xhr', function(){
		return has('activex') && window.location.protocol === 'file:';
	});

	has.add('native-xhr2', function(){
		if(!has('native-xhr') || has('dojo-force-activex-xhr')){ return; }
		var x = new XMLHttpRequest();
		return typeof x['addEventListener'] !== 'undefined' &&
			(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
	});

	has.add('native-formdata', function(){
		// if true, the environment has a native FormData implementation
		return typeof FormData !== 'undefined';
	});

	has.add('native-blob', function(){
		// if true, the environment has a native Blob implementation
		return typeof Blob !== 'undefined';
	});

	has.add('native-arraybuffer', function(){
		// if true, the environment has a native ArrayBuffer implementation
		return typeof ArrayBuffer !== 'undefined';
	});

	has.add('native-response-type', function(){
		return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
	});

	has.add('native-xhr2-blob', function(){
		if(!has('native-response-type')){ return; }
		var x = new XMLHttpRequest();
		// The URL used here does not have to be reachable as the XHR's `send` method is never called.
		// It does need to be parsable/resolvable in all cases, so it should be an absolute URL.
		// XMLHttpRequest within a Worker created from a Blob does not support relative URL paths.
		x.open('GET', 'https://dojotoolkit.org/', true);
		x.responseType = 'blob';
		// will not be set if unsupported
		var responseType = x.responseType;
		x.abort();
		return responseType === 'blob';
	});

	// Google Chrome doesn't support "json" response type
	// up to version 30, so it's intentionally not included here
	var nativeResponseTypes = {
		'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
		'document': 'document',
		'arraybuffer': 'arraybuffer'
	};

	function handleResponse(response, error){
		var _xhr = response.xhr;
		response.status = response.xhr.status;

		try {
			// Firefox throws an error when trying to access
			// xhr.responseText if response isn't text
			response.text = _xhr.responseText;
		} catch (e) {}

		if(response.options.handleAs === 'xml'){
			response.data = _xhr.responseXML;
		}

		var handleError;
		if(error){
			this.reject(error);
		}else{
			try{
				handlers(response);
			}catch(e){
				handleError = e;
			}
			if(util.checkStatus(_xhr.status)){
				if(!handleError){
					this.resolve(response);
				}else{
					this.reject(handleError);
				}
			}else{
				if(!handleError){
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
					this.reject(error);
				}else{
					error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status +
						' and an error in handleAs: transformation of response', response);
					this.reject(error);
				}
			}
		}
	}

	var isValid, isReady, addListeners, cancel;
	if(has('native-xhr2')){
		// Any platform with XHR2 will only use the watch mechanism for timeout.

		isValid = function(response){
			// summary:
			//		Check to see if the request should be taken out of the watch queue
			return !this.isFulfilled();
		};
		cancel = function(dfd, response){
			// summary:
			//		Canceler for deferred
			response.xhr.abort();
		};
		addListeners = function(_xhr, dfd, response, uploadProgress){
			// summary:
			//		Adds event listeners to the XMLHttpRequest object
			function onLoad(evt){
				dfd.handleResponse(response);
			}
			function onError(evt){
				var _xhr = evt.target;
				var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
				dfd.handleResponse(response, error);
			}

			function onProgress(transferType, evt){
				response.transferType = transferType;
				if(evt.lengthComputable){
					response.loaded = evt.loaded;
					response.total = evt.total;
					dfd.progress(response);
				} else if(response.xhr.readyState === 3){
					response.loaded = ('loaded' in evt) ? evt.loaded : evt.position;
					dfd.progress(response);
				}
			}

			function onDownloadProgress(evt) {
				return onProgress('download', evt);
			}

			function onUploadProgress(evt) {
				return onProgress('upload', evt);
			}

			_xhr.addEventListener('load', onLoad, false);
			_xhr.addEventListener('error', onError, false);
			_xhr.addEventListener('progress', onDownloadProgress, false);

			if (uploadProgress && _xhr.upload) {
				_xhr.upload.addEventListener('progress', onUploadProgress, false);
			}

			return function(){
				_xhr.removeEventListener('load', onLoad, false);
				_xhr.removeEventListener('error', onError, false);
				_xhr.removeEventListener('progress', onDownloadProgress, false);
				_xhr.upload.removeEventListener('progress', onUploadProgress, false);
				_xhr = null;
			};
		};
	}else{
		isValid = function(response){
			return response.xhr.readyState; //boolean
		};
		isReady = function(response){
			return 4 === response.xhr.readyState; //boolean
		};
		cancel = function(dfd, response){
			// summary:
			//		canceller function for util.deferred call.
			var xhr = response.xhr;
			var _at = typeof xhr.abort;
			if(_at === 'function' || _at === 'object' || _at === 'unknown'){
				xhr.abort();
			}
		};
	}

	function getHeader(headerName){
		return this.xhr.getResponseHeader(headerName);
	}

	var undefined,
		defaultOptions = {
			data: null,
			query: null,
			sync: false,
			method: 'GET'
		};
	function xhr(url, options, returnDeferred){
		var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
		var response = util.parseArgs(
			url,
			util.deepCreate(defaultOptions, options),
			isFormData
		);
		url = response.url;
		options = response.options;
		var hasNoData = !options.data && options.method !== 'POST' && options.method !== 'PUT';

		if(has('ie') <= 10){
			// older IE breaks point 9 in http://www.w3.org/TR/XMLHttpRequest/#the-open()-method and sends fragment, so strip it
			url = url.split('#')[0];
		}

		var remover,
			last = function(){
				remover && remover();
			};

		//Make the Deferred object for this xhr request.
		var dfd = util.deferred(
			response,
			cancel,
			isValid,
			isReady,
			handleResponse,
			last
		);
		var _xhr = response.xhr = xhr._create();

		if(!_xhr){
			// If XHR factory somehow returns nothings,
			// cancel the deferred.
			dfd.cancel(new RequestError('XHR was not created'));
			return returnDeferred ? dfd : dfd.promise;
		}

		response.getHeader = getHeader;

		if(addListeners){
			remover = addListeners(_xhr, dfd, response, options.uploadProgress);
		}

		// IE11 treats data: undefined different than other browsers
		var data = typeof(options.data) === 'undefined' ? null : options.data,
			async = !options.sync,
			method = options.method;

		try{
			// IE6 won't let you call apply() on the native function.
			_xhr.open(method, url, async, options.user || undefined, options.password || undefined);

			if(options.withCredentials){
				_xhr.withCredentials = options.withCredentials;
			}

			if(has('native-response-type') && options.handleAs in nativeResponseTypes) {
				_xhr.responseType = nativeResponseTypes[options.handleAs];
			}

			var headers = options.headers,
				contentType = (isFormData || hasNoData) ? false : 'application/x-www-form-urlencoded';
			if(headers){
				for(var hdr in headers){
					if(hdr.toLowerCase() === 'content-type'){
						contentType = headers[hdr];
					}else if(headers[hdr]){
						//Only add header if it has a value. This allows for instance, skipping
						//insertion of X-Requested-With by specifying empty value.
						_xhr.setRequestHeader(hdr, headers[hdr]);
					}
				}
			}

			if(contentType && contentType !== false){
				_xhr.setRequestHeader('Content-Type', contentType);
			}
			if(!headers || !('X-Requested-With' in headers)){
				_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
			}

			if(util.notify){
				util.notify.emit('send', response, dfd.promise.cancel);
			}
			_xhr.send(data);
		}catch(e){
			dfd.reject(e);
		}

		watch(dfd);
		_xhr = null;

		return returnDeferred ? dfd : dfd.promise;
	}

	/*=====
	xhr = function(url, options){
		// summary:
		//		Sends a request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.__BaseOptions = declare(request.__BaseOptions, {
		// sync: Boolean?
		//		Whether to make a synchronous request or not. Default
		//		is `false` (asynchronous).
		// data: String|Object|FormData?
		//		Data to transfer. This is ignored for GET and DELETE
		//		requests.
		// headers: Object?
		//		Headers to use for the request.
		// user: String?
		//		Username to use during the request.
		// password: String?
		//		Password to use during the request.
		// withCredentials: Boolean?
		//		For cross-site requests, whether to send credentials
		//		or not.
		// uploadProgress: Boolean?
		//		Upload progress events cause preflighted requests. This
		//		option enables upload progress event support but also
		//		causes all requests to be preflighted.
	});
	xhr.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request. Must be
		//		uppercase. Default is `"GET"`.
	});
	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);

	xhr.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.put = function(url, options){
		// summary:
		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	xhr.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/xhr.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	xhr._create = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
		throw new Error('XMLHTTP not available');
	};
	if(has('native-xhr') && !has('dojo-force-activex-xhr')){
		xhr._create = function(){
			return new XMLHttpRequest();
		};
	}else if(has('activex')){
		try{
			new ActiveXObject('Msxml2.XMLHTTP');
			xhr._create = function(){
				return new ActiveXObject('Msxml2.XMLHTTP');
			};
		}catch(e){
			try{
				new ActiveXObject('Microsoft.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Microsoft.XMLHTTP');
				};
			}catch(e){}
		}
	}

	util.addCommonMethods(xhr);

	return xhr;
});

},
'dojo/keys':function(){
define(["./_base/kernel", "./sniff"], function(dojo, has){

	// module:
	//		dojo/keys

	return dojo.keys = {
		// summary:
		//		Definitions for common key values.  Client code should test keyCode against these named constants,
		//		as the actual codes can vary by browser.

		BACKSPACE: 8,
		TAB: 9,
		CLEAR: 12,
		ENTER: 13,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		META: has("webkit") ? 91 : 224,		// the apple key on macs
		PAUSE: 19,
		CAPS_LOCK: 20,
		ESCAPE: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		HELP: 47,
		LEFT_WINDOW: 91,
		RIGHT_WINDOW: 92,
		SELECT: 93,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_PLUS: 107,
		NUMPAD_ENTER: 108,
		NUMPAD_MINUS: 109,
		NUMPAD_PERIOD: 110,
		NUMPAD_DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		F13: 124,
		F14: 125,
		F15: 126,
		NUM_LOCK: 144,
		SCROLL_LOCK: 145,
		UP_DPAD: 175,
		DOWN_DPAD: 176,
		LEFT_DPAD: 177,
		RIGHT_DPAD: 178,
		// virtual key mapping
		copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
	};
});

},
'dojo/domReady':function(){
define(['./global', './has'], function(global, has){
	var doc = document,
		readyStates = { 'loaded': 1, 'complete': 1 },
		fixReadyState = typeof doc.readyState != "string",
		ready = !!readyStates[doc.readyState],
		readyQ = [],
		recursiveGuard;

	function domReady(callback){
		// summary:
		//		Plugin to delay require()/define() callback from firing until the DOM has finished loading.
		readyQ.push(callback);
		if(ready){ processQ(); }
	}
	domReady.load = function(id, req, load){
		domReady(load);
	};

	// Export queue so that ready() can check if it's empty or not.
	domReady._Q = readyQ;
	domReady._onQEmpty = function(){
		// summary:
		//		Private method overridden by dojo/ready, to notify when everything in the
		//		domReady queue has been processed.  Do not use directly.
		//		Will be removed in 2.0, along with domReady._Q.
	};

	// For FF <= 3.5
	if(fixReadyState){ doc.readyState = "loading"; }

	function processQ(){
		// Calls all functions in the queue in order, unless processQ() is already running, in which case just return

		if(recursiveGuard){ return; }
		recursiveGuard = true;

		while(readyQ.length){
			try{
				(readyQ.shift())(doc);
			}catch(err){
				console.error(err, "in domReady callback", err.stack);
			}
		}

		recursiveGuard = false;

		// Notification for dojo/ready.  Remove for 2.0.
		// Note that this could add more tasks to the ready queue.
		domReady._onQEmpty();
	}

	if(!ready){
		var tests = [],
			detectReady = function(evt){
				evt = evt || global.event;
				if(ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])){ return; }

				// For FF <= 3.5
				if(fixReadyState){ doc.readyState = "complete"; }

				ready = 1;
				processQ();
			},
			on = function(node, event){
				node.addEventListener(event, detectReady, false);
				readyQ.push(function(){ node.removeEventListener(event, detectReady, false); });
			};

		if(!has("dom-addeventlistener")){
			on = function(node, event){
				event = "on" + event;
				node.attachEvent(event, detectReady);
				readyQ.push(function(){ node.detachEvent(event, detectReady); });
			};

			var div = doc.createElement("div");
			try{
				if(div.doScroll && global.frameElement === null){
					// the doScroll test is only useful if we're in the top-most frame
					tests.push(function(){
						// Derived with permission from Diego Perini's IEContentLoaded
						// http://javascript.nwbox.com/IEContentLoaded/
						try{
							div.doScroll("left");
							return 1;
						}catch(e){}
					});
				}
			}catch(e){}
		}

		on(doc, "DOMContentLoaded");
		on(global, "load");

		if("onreadystatechange" in doc){
			on(doc, "readystatechange");
		}else if(!fixReadyState){
			// if the ready state property exists and there's
			// no readystatechange event, poll for the state
			// to change
			tests.push(function(){
				return readyStates[doc.readyState];
			});
		}

		if(tests.length){
			var poller = function(){
				if(ready){ return; }
				var i = tests.length;
				while(i--){
					if(tests[i]()){
						detectReady("poller");
						return;
					}
				}
				setTimeout(poller, 30);
			};
			poller();
		}
	}

	return domReady;
});

},
'dojo/_base/lang':function(){
define(["./kernel", "../has", "../sniff"], function(dojo, has){
	// module:
	//		dojo/_base/lang

	has.add("bug-for-in-skips-shadowed", function(){
		// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
		for(var i in {toString: 1}){
			return 0;
		}
		return 1;
	});

	// Helper methods
	var _extraNames =
			has("bug-for-in-skips-shadowed") ?
				"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],

		_extraLen = _extraNames.length,

		getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
			if(!context){
				if(parts[0] && dojo.scopeMap[parts[0]]) {
					// Voodoo code from the old days where "dojo" or "dijit" maps to some special object
					// rather than just window.dojo
					context = dojo.scopeMap[parts.shift()][1];
				}else{
					context = dojo.global;
				}
			}

			try{
				for(var i = 0; i < parts.length; i++){
					var p = parts[i];
					if(!(p in context)){
						if(create){
							context[p] = {};
						}else{
							return;		// return undefined
						}
					}
					context = context[p];
				}
				return context; // mixed
			}catch(e){
				// "p in context" throws an exception when context is a number, boolean, etc. rather than an object,
				// so in that corner case just return undefined (by having no return statement)
			}
		},

		opts = Object.prototype.toString,

		efficient = function(obj, offset, startWith){
			return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
		},

		_pattern = /\{([^\}]+)\}/g;

	// Module export
	var lang = {
		// summary:
		//		This module defines Javascript language extensions.

		// _extraNames: String[]
		//		Lists property names that must be explicitly processed during for-in iteration
		//		in environments that have has("bug-for-in-skips-shadowed") true.
		_extraNames:_extraNames,

		_mixin: function(dest, source, copyFunc){
			// summary:
			//		Copies/adds all properties of source to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source.
			// source: Object
			//		The object from which to draw all properties to copy into dest.
			// copyFunc: Function?
			//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
			// returns:
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
			//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
			//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			var name, s, i, empty = {};
			for(name in source){
				// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
				// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
				// don't overwrite it with the toString() method that source inherited from Object.prototype
				s = source[name];
				if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
					dest[name] = copyFunc ? copyFunc(s) : s;
				}
			}

			if(has("bug-for-in-skips-shadowed")){
				if(source){
					for(i = 0; i < _extraLen; ++i){
						name = _extraNames[i];
						s = source[name];
						if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
							dest[name] = copyFunc ? copyFunc(s) : s;
						}
					}
				}
			}

			return dest; // Object
		},

		mixin: function(dest, sources){
			// summary:
			//		Copies/adds all properties of one or more sources to dest; returns dest.
			// dest: Object
			//		The object to which to copy/add all properties contained in source. If dest is falsy, then
			//		a new object is manufactured before copying/adding properties begins.
			// sources: Object...
			//		One of more objects from which to draw all properties to copy into dest. sources are processed
			//		left-to-right and if more than one of these objects contain the same property name, the right-most
			//		value "wins".
			// returns: Object
			//		dest, as modified
			// description:
			//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
			//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
			//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
			//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
			// example:
			//		make a shallow copy of an object
			//	|	var copy = lang.mixin({}, source);
			// example:
			//		many class constructors often take an object which specifies
			//		values to be configured on the object. In this case, it is
			//		often simplest to call `lang.mixin` on the `this` object:
			//	|	declare("acme.Base", null, {
			//	|		constructor: function(properties){
			//	|			// property configuration:
			//	|			lang.mixin(this, properties);
			//	|
			//	|			console.log(this.quip);
			//	|			//	...
			//	|		},
			//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
			//	|		// ...
			//	|	});
			//	|
			//	|	// create an instance of the class and configure it
			//	|	var b = new acme.Base({quip: "That's what it does!" });
			// example:
			//		copy in properties from multiple objects
			//	|	var flattened = lang.mixin(
			//	|		{
			//	|			name: "Frylock",
			//	|			braces: true
			//	|		},
			//	|		{
			//	|			name: "Carl Brutanananadilewski"
			//	|		}
			//	|	);
			//	|
			//	|	// will print "Carl Brutanananadilewski"
			//	|	console.log(flattened.name);
			//	|	// will print "true"
			//	|	console.log(flattened.braces);

			if(!dest){ dest = {}; }
			for(var i = 1, l = arguments.length; i < l; i++){
				lang._mixin(dest, arguments[i]);
			}
			return dest; // Object
		},

		setObject: function(name, value, context){
			// summary:
			//		Set a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			//		Objects are created as needed along `path`. Returns the passed
			//		value if setting is successful or `undefined` if not.
			// name: String
			//		Path to a property, in the form "A.B.C".
			// value: anything
			//		value or object to place at location given by name
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		`dojo.global`.
			// example:
			//		set the value of `foo.bar.baz`, regardless of whether
			//		intermediate objects already exist:
			//	| lang.setObject("foo.bar.baz", value);
			// example:
			//		without `lang.setObject`, we often see code like this:
			//	| // ensure that intermediate objects are available
			//	| if(!obj["parent"]){ obj.parent = {}; }
			//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
			//	| // now we can safely set the property
			//	| obj.parent.child.prop = "some value";
			//		whereas with `lang.setObject`, we can shorten that to:
			//	| lang.setObject("parent.child.prop", "some value", obj);

			var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
			return obj && p ? (obj[p] = value) : undefined; // Object
		},

		getObject: function(name, create, context){
			// summary:
			//		Get a property from a dot-separated string, such as "A.B.C"
			// description:
			//		Useful for longer api chains where you have to test each object in
			//		the chain, or when you have an object reference in string format.
			// name: String
			//		Path to an property, in the form "A.B.C".
			// create: Boolean?
			//		Optional. Defaults to `false`. If `true`, Objects will be
			//		created at any point along the 'path' that is undefined.
			// context: Object?
			//		Optional. Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			return !name ? context : getProp(name.split("."), create, context); // Object
		},

		exists: function(name, obj){
			// summary:
			//		determine if an object supports a given method
			// description:
			//		useful for longer api chains where you have to test each object in
			//		the chain. Useful for object and method detection.
			// name: String
			//		Path to an object, in the form "A.B.C".
			// obj: Object?
			//		Object to use as root of path. Defaults to
			//		'dojo.global'. Null may be passed.
			// example:
			//	| // define an object
			//	| var foo = {
			//	|		bar: { }
			//	| };
			//	|
			//	| // search the global scope
			//	| lang.exists("foo.bar"); // true
			//	| lang.exists("foo.bar.baz"); // false
			//	|
			//	| // search from a particular scope
			//	| lang.exists("bar", foo); // true
			//	| lang.exists("bar.baz", foo); // false
			return lang.getObject(name, false, obj) !== undefined; // Boolean
		},

		// Crockford (ish) functions

		isString: function(it){
			// summary:
			//		Return true if it is a String
			// it: anything
			//		Item to test.
			return (typeof it == "string" || it instanceof String); // Boolean
		},

		isArray: Array.isArray || function(it){
			// summary:
			//		Return true if it is an Array.
			// it: anything
			//		Item to test.
			return opts.call(it) == "[object Array]"; // Boolean
		},

		isFunction: function(it){
			// summary:
			//		Return true if it is a Function
			// it: anything
			//		Item to test.
			return opts.call(it) === "[object Function]";
		},

		isObject: function(it){
			// summary:
			//		Returns true if it is a JavaScript object (or an Array, a Function
			//		or null)
			// it: anything
			//		Item to test.
			return it !== undefined &&
				(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
		},

		isArrayLike: function(it){
			// summary:
			//		similar to isArray() but more permissive
			// it: anything
			//		Item to test.
			// returns:
			//		If it walks like a duck and quacks like a duck, return `true`
			// description:
			//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
			//		a string or number and has a length property". Arguments objects
			//		and DOM collections will return true when passed to
			//		isArrayLike(), but will return false when passed to
			//		isArray().
			return !!it && // Boolean
				// keep out built-in constructors (Number, String, ...) which have length
				// properties
				!lang.isString(it) && !lang.isFunction(it) &&
				!(it.tagName && it.tagName.toLowerCase() == 'form') &&
				(lang.isArray(it) || isFinite(it.length));
		},

		isAlien: function(it){
			// summary:
			//		Returns true if it is a built-in function or some other kind of
			//		oddball that *should* report as a function but doesn't
			return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
		},

		extend: function(ctor, props){
			// summary:
			//		Adds all properties and methods of props to constructor's
			//		prototype, making them available to all instances created with
			//		constructor.
			// ctor: Object
			//		Target constructor to extend.
			// props: Object
			//		One or more objects to mix into ctor.prototype
			for(var i=1, l=arguments.length; i<l; i++){
				lang._mixin(ctor.prototype, arguments[i]);
			}
			return ctor; // Object
		},

		_hitchArgs: function(scope, method){
			var pre = lang._toArray(arguments, 2);
			var named = lang.isString(method);
			return function(){
				// arrayify arguments
				var args = lang._toArray(arguments);
				// locate our method
				var f = named ? (scope||dojo.global)[method] : method;
				// invoke with collected args
				return f && f.apply(scope || this, pre.concat(args)); // mixed
			}; // Function
		},

		hitch: function(scope, method){
			// summary:
			//		Returns a function that will only ever execute in the given scope.
			//		This allows for easy use of object member functions
			//		in callbacks and other places in which the "this" keyword may
			//		otherwise not reference the expected scope.
			//		Any number of default positional arguments may be passed as parameters
			//		beyond "method".
			//		Each of these values will be used to "placehold" (similar to curry)
			//		for the hitched function.
			// scope: Object
			//		The scope to use when method executes. If method is a string,
			//		scope is also the object containing method.
			// method: Function|String...
			//		A function to be hitched to scope, or the name of the method in
			//		scope to be hitched.
			// example:
			//	|	lang.hitch(foo, "bar")();
			//		runs foo.bar() in the scope of foo
			// example:
			//	|	lang.hitch(foo, myFunction);
			//		returns a function that runs myFunction in the scope of foo
			// example:
			//		Expansion on the default positional arguments passed along from
			//		hitch. Passed args are mixed first, additional args after.
			//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
			//	|	var fn = lang.hitch(foo, "bar", 1, 2);
			//	|	fn(3); // logs "1, 2, 3"
			// example:
			//	|	var foo = { bar: 2 };
			//	|	lang.hitch(foo, function(){ this.bar = 10; })();
			//		execute an anonymous function in scope of foo
			if(arguments.length > 2){
				return lang._hitchArgs.apply(dojo, arguments); // Function
			}
			if(!method){
				method = scope;
				scope = null;
			}
			if(lang.isString(method)){
				scope = scope || dojo.global;
				if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
				return function(){ return scope[method].apply(scope, arguments || []); }; // Function
			}
			return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
		},

		delegate: (function(){
			// boodman/crockford delegation w/ cornford optimization
			function TMP(){}
			return function(obj, props){
				TMP.prototype = obj;
				var tmp = new TMP();
				TMP.prototype = null;
				if(props){
					lang._mixin(tmp, props);
				}
				return tmp; // Object
			};
		})(),
		/*=====
		delegate: function(obj, props){
			// summary:
			//		Returns a new object which "looks" to obj for properties which it
			//		does not have a value for. Optionally takes a bag of properties to
			//		seed the returned object with initially.
			// description:
			//		This is a small implementation of the Boodman/Crockford delegation
			//		pattern in JavaScript. An intermediate object constructor mediates
			//		the prototype chain for the returned object, using it to delegate
			//		down to obj for property lookup when object-local lookup fails.
			//		This can be thought of similarly to ES4's "wrap", save that it does
			//		not act on types but rather on pure objects.
			// obj: Object
			//		The object to delegate to for properties not found directly on the
			//		return object or in props.
			// props: Object...
			//		an object containing properties to assign to the returned object
			// returns:
			//		an Object of anonymous type
			// example:
			//	|	var foo = { bar: "baz" };
			//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
			//	|	thinger.bar == "baz"; // delegated to foo
			//	|	foo.thud == undefined; // by definition
			//	|	thinger.thud == "xyzzy"; // mixed in from props
			//	|	foo.bar = "thonk";
			//	|	thinger.bar == "thonk"; // still delegated to foo's bar
		},
		=====*/

		_toArray: has("ie") ?
			(function(){
				function slow(obj, offset, startWith){
					var arr = startWith||[];
					for(var x = offset || 0; x < obj.length; x++){
						arr.push(obj[x]);
					}
					return arr;
				}
				return function(obj){
					return ((obj.item) ? slow : efficient).apply(this, arguments);
				};
			})() : efficient,
		/*=====
		 _toArray: function(obj, offset, startWith){
			 // summary:
			 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
			 //		array. Returns a new Array with the elements of obj.
			 // obj: Object
			 //		the object to "arrayify". We expect the object to have, at a
			 //		minimum, a length property which corresponds to integer-indexed
			 //		properties.
			 // offset: Number?
			 //		the location in obj to start iterating from. Defaults to 0.
			 //		Optional.
			 // startWith: Array?
			 //		An array to pack with the properties of obj. If provided,
			 //		properties in obj are appended at the end of startWith and
			 //		startWith is the returned array.
		 },
		 =====*/

		partial: function(/*Function|String*/ method /*, ...*/){
			// summary:
			//		similar to hitch() except that the scope object is left to be
			//		whatever the execution context eventually becomes.
			// description:
			//		Calling lang.partial is the functional equivalent of calling:
			//		|	lang.hitch(null, funcName, ...);
			// method:
			//		The function to "wrap"
			var arr = [ null ];
			return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
		},

		clone: function(/*anything*/ src){
			// summary:
			//		Clones objects (including DOM nodes) and all children.
			//		Warning: do not clone cyclic structures.
			// src:
			//		The object to clone
			if(!src || typeof src != "object" || lang.isFunction(src)){
				// null, undefined, any non-object, or function
				return src;	// anything
			}
			if(src.nodeType && "cloneNode" in src){
				// DOM Node
				return src.cloneNode(true); // Node
			}
			if(src instanceof Date){
				// Date
				return new Date(src.getTime());	// Date
			}
			if(src instanceof RegExp){
				// RegExp
				return new RegExp(src);   // RegExp
			}
			var r, i, l;
			if(lang.isArray(src)){
				// array
				r = [];
				for(i = 0, l = src.length; i < l; ++i){
					if(i in src){
						r[i] = lang.clone(src[i]);
					}
				}
				// we don't clone functions for performance reasons
				//		}else if(d.isFunction(src)){
				//			// function
				//			r = function(){ return src.apply(this, arguments); };
			}else{
				// generic objects
				r = src.constructor ? new src.constructor() : {};
			}
			return lang._mixin(r, src, lang.clone);
		},


		trim: String.prototype.trim ?
			function(str){ return str.trim(); } :
			function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
		/*=====
		 trim: function(str){
			 // summary:
			 //		Trims whitespace from both sides of the string
			 // str: String
			 //		String to be trimmed
			 // returns: String
			 //		Returns the trimmed string
			 // description:
			 //		This version of trim() was selected for inclusion into the base due
			 //		to its compact size and relatively good performance
			 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
			 //		Uses String.prototype.trim instead, if available.
			 //		The fastest but longest version of this function is located at
			 //		lang.string.trim()
		 },
		 =====*/

		replace: function(tmpl, map, pattern){
			// summary:
			//		Performs parameterized substitutions on a string. Throws an
			//		exception if any parameter is unmatched.
			// tmpl: String
			//		String to be used as a template.
			// map: Object|Function
			//		If an object, it is used as a dictionary to look up substitutions.
			//		If a function, it is called for every substitution with following parameters:
			//		a whole match, a name, an offset, and the whole template
			//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
			//		for more details).
			// pattern: RegEx?
			//		Optional regular expression objects that overrides the default pattern.
			//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
			//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
			//		of characters, which doesn't include "}".
			// returns: String
			//		Returns the substituted string.
			// example:
			//	|	// uses a dictionary for substitutions:
			//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
			//	|		{
			//	|			nick: "Bob",
			//	|			name: {
			//	|				first:	"Robert",
			//	|				middle: "X",
			//	|				last:		"Cringely"
			//	|			}
			//	|		});
			//	|	// returns: Hello, Robert Cringely AKA Bob!
			// example:
			//	|	// uses an array for substitutions:
			//	|	lang.replace("Hello, {0} {2}!",
			//	|		["Robert", "X", "Cringely"]);
			//	|	// returns: Hello, Robert Cringely!
			// example:
			//	|	// uses a function for substitutions:
			//	|	function sum(a){
			//	|		var t = 0;
			//	|		arrayforEach(a, function(x){ t += x; });
			//	|		return t;
			//	|	}
			//	|	lang.replace(
			//	|		"{count} payments averaging {avg} USD per payment.",
			//	|		lang.hitch(
			//	|			{ payments: [11, 16, 12] },
			//	|			function(_, key){
			//	|				switch(key){
			//	|					case "count": return this.payments.length;
			//	|					case "min":		return Math.min.apply(Math, this.payments);
			//	|					case "max":		return Math.max.apply(Math, this.payments);
			//	|					case "sum":		return sum(this.payments);
			//	|					case "avg":		return sum(this.payments) / this.payments.length;
			//	|				}
			//	|			}
			//	|		)
			//	|	);
			//	|	// prints: 3 payments averaging 13 USD per payment.
			// example:
			//	|	// uses an alternative PHP-like pattern for substitutions:
			//	|	lang.replace("Hello, ${0} ${2}!",
			//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
			//	|	// returns: Hello, Robert Cringely!

			return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
				map : function(_, k){ return lang.getObject(k, false, map); });
		}
	};

	 1  && lang.mixin(dojo, lang);

	return lang;
});

},
'dojo/request/util':function(){
define([
	'exports',
	'../errors/RequestError',
	'../errors/CancelError',
	'../Deferred',
	'../io-query',
	'../_base/array',
	'../_base/lang',
	'../promise/Promise',
	'../has'
], function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise, has){

	function isArrayBuffer(value) {
		return has('native-arraybuffer') && value instanceof ArrayBuffer
	}

	function isBlob(value) {
		return has('native-blob') && value instanceof Blob
	}
	
	function isFormElement(value) {
		if(typeof HTMLFormElement !== 'undefined') { //all other
			return value instanceof HTMLFormElement;
		} else { //IE<=7
			value.tagName === "FORM"
		}
	}

	function isFormData(value) {
		return has('native-formdata') && value instanceof FormData;
	}

	function shouldDeepCopy(value) {
		return value &&
			typeof value === 'object' &&
			!isFormData(value) &&
			!isFormElement(value) &&
			!isBlob(value) &&
			!isArrayBuffer(value)
	}

	exports.deepCopy = function(target, source) {
		for (var name in source) {
			var tval = target[name],
  			    sval = source[name];
			if (tval !== sval) {
				if (shouldDeepCopy(sval)) {
					if (Object.prototype.toString.call(sval) === '[object Date]') { // use this date test to handle crossing frame boundaries
						target[name] = new Date(sval);
					} else if (lang.isArray(sval)) {
 						  target[name] = exports.deepCopyArray(sval);
					} else {
						if (tval && typeof tval === 'object') {
							exports.deepCopy(tval, sval);
						} else {
							target[name] = exports.deepCopy({}, sval);
						}
					}
				} else {
					target[name] = sval;
				}
			}
		}
		return target;
	};

	exports.deepCopyArray = function(source) {
		var clonedArray = [];
		for (var i = 0, l = source.length; i < l; i++) {
			var svalItem = source[i];
			if (typeof svalItem === 'object') {
				clonedArray.push(exports.deepCopy({}, svalItem));
			} else {
				clonedArray.push(svalItem);
			}
		}

		return clonedArray;
	};

	exports.deepCreate = function deepCreate(source, properties){
		properties = properties || {};
		var target = lang.delegate(source),
			name, value;

		for(name in source){
			value = source[name];

			if(value && typeof value === 'object'){
				target[name] = exports.deepCreate(value, properties[name]);
			}
		}
		return exports.deepCopy(target, properties);
	};

	var freeze = Object.freeze || function(obj){ return obj; };
	function okHandler(response){
		return freeze(response);
	}
	function dataHandler (response) {
		return response.data !== undefined ? response.data : response.text;
	}

	exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
		var def = new Deferred(function(reason){
			cancel && cancel(def, response);

			if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
				return new CancelError('Request canceled', response);
			}
			return reason;
		});

		def.response = response;
		def.isValid = isValid;
		def.isReady = isReady;
		def.handleResponse = handleResponse;

		function errHandler(error){
			error.response = response;
			throw error;
		}
		var responsePromise = def.then(okHandler).otherwise(errHandler);

		if(exports.notify){
			responsePromise.then(
				lang.hitch(exports.notify, 'emit', 'load'),
				lang.hitch(exports.notify, 'emit', 'error')
			);
		}

		var dataPromise = responsePromise.then(dataHandler);

		// http://bugs.dojotoolkit.org/ticket/16794
		// The following works around a leak in IE9 through the
		// prototype using lang.delegate on dataPromise and
		// assigning the result a property with a reference to
		// responsePromise.
		var promise = new Promise();
		for (var prop in dataPromise) {
			if (dataPromise.hasOwnProperty(prop)) {
				promise[prop] = dataPromise[prop];
			}
		}
		promise.response = responsePromise;
		freeze(promise);
		// End leak fix


		if(last){
			def.then(function(response){
				last.call(def, response);
			}, function(error){
				last.call(def, response, error);
			});
		}

		def.promise = promise;
		def.then = promise.then;

		return def;
	};

	exports.addCommonMethods = function addCommonMethods(provider, methods){
		array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
			provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
				options = lang.delegate(options||{});
				options.method = method;
				return provider(url, options);
			};
		});
	};

	exports.parseArgs = function parseArgs(url, options, skipData){
		var data = options.data,
			query = options.query;

		if(data && !skipData){
			if(typeof data === 'object' && (!(has('native-xhr2')) || !(isArrayBuffer(data) || isBlob(data) ))){
				options.data = ioQuery.objectToQuery(data);
			}
		}

		if(query){
			if(typeof query === 'object'){
				query = ioQuery.objectToQuery(query);
			}
			if(options.preventCache){
				query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
			}
		}else if(options.preventCache){
			query = 'request.preventCache=' + (+(new Date));
		}

		if(url && query){
			url += (~url.indexOf('?') ? '&' : '?') + query;
		}

		return {
			url: url,
			options: options,
			getHeader: function(headerName){ return null; }
		};
	};

	exports.checkStatus = function(stat){
		stat = stat || 0;
		return (stat >= 200 && stat < 300) || // allow any 2XX response code
			stat === 304 ||                 // or, get it out of the cache
			stat === 1223 ||                // or, Internet Explorer mangled the status code
			!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
	};
});

},
'dojo/Evented':function(){
define(["./aspect", "./on"], function(aspect, on){
	// module:
	//		dojo/Evented

 	"use strict";
 	var after = aspect.after;
	function Evented(){
		// summary:
		//		A class that can be used as a mixin or base class,
		//		to add on() and emit() methods to a class
		//		for listening for events and emitting events:
		// example:
		//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
		//		|	], function(Evented, declare, Stateful){
		//		|		var EventedStateful = declare([Evented, Stateful], {...});
		//		|		var instance = new EventedStateful();
		//		|		instance.on("open", function(event){
		//		|		... do something with event
		//		|	 });
		//		|
		//		|	instance.emit("open", {name:"some event", ...});
	}
	Evented.prototype = {
		on: function(type, listener){
			return on.parse(this, type, listener, function(target, type){
				return after(target, 'on' + type, listener, true);
			});
		},
		emit: function(type, event){
			var args = [this];
			args.push.apply(args, arguments);
			return on.emit.apply(on, args);
		}
	};
	return Evented;
});

},
'dojo/mouse':function(){
define(["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function(dojo, on, has, dom, win){

	// module:
	//		dojo/mouse

    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
	has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
	has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);

	var mouseButtons;
	if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
		mouseButtons = {
			LEFT:   1,
			MIDDLE: 4,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button & button; },
			isLeft:   function(e){ return e.button & 1; },
			isMiddle: function(e){ return e.button & 4; },
			isRight:  function(e){ return e.button & 2; }
		};
	}else{
		mouseButtons = {
			LEFT:   0,
			MIDDLE: 1,
			RIGHT:  2,
			// helper functions
			isButton: function(e, button){ return e.button == button; },
			isLeft:   function(e){ return e.button == 0; },
			isMiddle: function(e){ return e.button == 1; },
			isRight:  function(e){ return e.button == 2; }
		};
	}
	dojo.mouseButtons = mouseButtons;

/*=====
	dojo.mouseButtons = {
		// LEFT: Number
		//		Numeric value of the left mouse button for the platform.
		LEFT:   0,
		// MIDDLE: Number
		//		Numeric value of the middle mouse button for the platform.
		MIDDLE: 1,
		// RIGHT: Number
		//		Numeric value of the right mouse button for the platform.
		RIGHT:  2,

		isButton: function(e, button){
			// summary:
			//		Checks an event object for a pressed button
			// e: Event
			//		Event object to examine
			// button: Number
			//		The button value (example: dojo.mouseButton.LEFT)
			return e.button == button; // Boolean
		},
		isLeft: function(e){
			// summary:
			//		Checks an event object for the pressed left button
			// e: Event
			//		Event object to examine
			return e.button == 0; // Boolean
		},
		isMiddle: function(e){
			// summary:
			//		Checks an event object for the pressed middle button
			// e: Event
			//		Event object to examine
			return e.button == 1; // Boolean
		},
		isRight: function(e){
			// summary:
			//		Checks an event object for the pressed right button
			// e: Event
			//		Event object to examine
			return e.button == 2; // Boolean
		}
	};
=====*/

	function eventHandler(type, selectHandler){
		// emulation of mouseenter/leave with mouseover/out using descendant checking
		var handler = function(node, listener){
			return on(node, type, function(evt){
				if(selectHandler){
					return selectHandler(evt, listener);
				}
				if(!dom.isDescendant(evt.relatedTarget, node)){
					return listener.call(this, evt);
				}
			});
		};
		handler.bubble = function(select){
			return eventHandler(type, function(evt, listener){
				// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
				var target = select(evt.target);
				var relatedTarget = evt.relatedTarget;
				if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
					return listener.call(target, evt);
				} 
			});
		};
		return handler;
	}
	var wheel;
	if(has("events-mousewheel")){
		wheel = 'mousewheel';
	}else{ //firefox
		wheel = function(node, listener){
			return on(node, 'DOMMouseScroll', function(evt){
				evt.wheelDelta = -evt.detail;
				listener.call(this, evt);
			});
		};
	}
	return {
		// summary:
		//		This module provide mouse event handling utility functions and exports
		//		mouseenter and mouseleave event emulation.
		// example:
		//		To use these events, you register a mouseenter like this:
		//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
		//		|		on(targetNode, mouse.enter, function(event){
		//		|			dojo.addClass(targetNode, "highlighted");
		//		|		});
		//		|		on(targetNode, mouse.leave, function(event){
		//		|			dojo.removeClass(targetNode, "highlighted");
		//		|		});

		_eventHandler: eventHandler,		// for dojo/touch

		// enter: Synthetic Event
		//		This is an extension event for the mouseenter that IE provides, emulating the
		//		behavior on other browsers.
		enter: eventHandler("mouseover"),

		// leave: Synthetic Event
		//		This is an extension event for the mouseleave that IE provides, emulating the
		//		behavior on other browsers.
		leave: eventHandler("mouseout"),

		// wheel: Normalized Mouse Wheel Event
		//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
		//		emulating the behavior on Mozilla based browsers.
		wheel: wheel,

		isLeft: mouseButtons.isLeft,
		/*=====
		isLeft: function(){
			// summary:
			//		Test an event object (from a mousedown event) to see if the left button was pressed.
		},
		=====*/

		isMiddle: mouseButtons.isMiddle,
		/*=====
		 isMiddle: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
		 },
		 =====*/

		isRight: mouseButtons.isRight
		/*=====
		 , isRight: function(){
			 // summary:
			 //		Test an event object (from a mousedown event) to see if the right button was pressed.
		 }
		 =====*/
	};
});

},
'dojo/topic':function(){
define(["./Evented"], function(Evented){

	// module:
	//		dojo/topic

	var hub = new Evented;
	return {
		// summary:
		//		Pubsub hub.
		// example:
		//		| 	topic.subscribe("some/topic", function(event){
		//		|	... do something with event
		//		|	});
		//		|	topic.publish("some/topic", {name:"some event", ...});

		publish: function(topic, event){
			// summary:
			//		Publishes a message to a topic on the pub/sub hub. All arguments after
			//		the first will be passed to the subscribers, so any number of arguments
			//		can be provided (not just event).
			// topic: String
			//		The name of the topic to publish to
			// event: Object
			//		An event to distribute to the topic listeners
			return hub.emit.apply(hub, arguments);
		},

		subscribe: function(topic, listener){
			// summary:
			//		Subscribes to a topic on the pub/sub hub
			// topic: String
			//		The topic to subscribe to
			// listener: Function
			//		A function to call when a message is published to the given topic
			return hub.on.apply(hub, arguments);
		}
	};
});

},
'dojo/_base/xhr':function(){
define([
	"./kernel",
	"./sniff",
	"require",
	"../io-query",
	/*===== "./declare", =====*/
	"../dom",
	"../dom-form",
	"./Deferred",
	"./config",
	"./json",
	"./lang",
	"./array",
	"../on",
	"../aspect",
	"../request/watch",
	"../request/xhr",
	"../request/util"
], function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
	// module:
	//		dojo/_base/xhr

	/*=====
	dojo._xhrObj = function(){
		// summary:
		//		does the work of portably generating a new XMLHTTPRequest object.
	};
	=====*/
	dojo._xhrObj = _xhr._create;

	var cfg = dojo.config;

	// mix in io-query and dom-form
	dojo.objectToQuery = ioq.objectToQuery;
	dojo.queryToObject = ioq.queryToObject;
	dojo.fieldToObject = domForm.fieldToObject;
	dojo.formToObject = domForm.toObject;
	dojo.formToQuery = domForm.toQuery;
	dojo.formToJson = domForm.toJson;

	// need to block async callbacks from snatching this thread as the result
	// of an async callback might call another sync XHR, this hangs khtml forever
	// must checked by watchInFlight()

	dojo._blockAsync = false;

	// MOW: remove dojo._contentHandlers alias in 2.0
	var handlers = dojo._contentHandlers = dojo.contentHandlers = {
		// summary:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls.
		// description:
		//		A map of available XHR transport handle types. Name matches the
		//		`handleAs` attribute passed to XHR calls. Each contentHandler is
		//		called, passing the xhr object for manipulation. The return value
		//		from the contentHandler will be passed to the `load` or `handle`
		//		functions defined in the original xhr call.
		// example:
		//		Creating a custom content-handler:
		//	|	xhr.contentHandlers.makeCaps = function(xhr){
		//	|		return xhr.responseText.toUpperCase();
		//	|	}
		//	|	// and later:
		//	|	dojo.xhrGet({
		//	|		url:"foo.txt",
		//	|		handleAs:"makeCaps",
		//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
		//	|	});

		"text": function(xhr){
			// summary:
			//		A contentHandler which simply returns the plaintext response data
			return xhr.responseText;
		},
		"json": function(xhr){
			// summary:
			//		A contentHandler which returns a JavaScript object created from the response data
			return json.fromJson(xhr.responseText || null);
		},
		"json-comment-filtered": function(xhr){
			// summary:
			//		A contentHandler which expects comment-filtered JSON.
			// description:
			//		A contentHandler which expects comment-filtered JSON.
			//		the json-comment-filtered option was implemented to prevent
			//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
			//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
			//
			//		Will throw a notice suggesting to use application/json mimetype, as
			//		json-commenting can introduce security issues. To decrease the chances of hijacking,
			//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
			//
			//		use djConfig.useCommentedJson = true to turn off the notice
			if(!config.useCommentedJson){
				console.warn("Consider using the standard mimetype:application/json."
					+ " json-commenting can introduce security issues. To"
					+ " decrease the chances of hijacking, use the standard the 'json' handler and"
					+ " prefix your json with: {}&&\n"
					+ "Use djConfig.useCommentedJson=true to turn off this message.");
			}

			var value = xhr.responseText;
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if(cStartIdx == -1 || cEndIdx == -1){
				throw new Error("JSON was not comment filtered");
			}
			return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
		},
		"javascript": function(xhr){
			// summary:
			//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript

			// FIXME: try Moz and IE specific eval variants?
			return dojo.eval(xhr.responseText);
		},
		"xml": function(xhr){
			// summary:
			//		A contentHandler returning an XML Document parsed from the response data
			var result = xhr.responseXML;

			if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
			}

			if(has("ie")){
				if((!result || !result.documentElement)){
					//WARNING: this branch used by the xml handling in dojo.io.iframe,
					//so be sure to test dojo.io.iframe if making changes below.
					var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
					var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
					array.some(dp, function(p){
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(xhr.responseText);
							result = dom;
						}catch(e){ return false; }
						return true;
					});
				}
			}
			return result; // DOMDocument
		},
		"json-comment-optional": function(xhr){
			// summary:
			//		A contentHandler which checks the presence of comment-filtered JSON and
			//		alternates between the `json` and `json-comment-filtered` contentHandlers.
			if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
				return handlers["json-comment-filtered"](xhr);
			}else{
				return handlers["json"](xhr);
			}
		}
	};

	/*=====

	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
	// because they are used by dojo/io modules too

	dojo.__IoArgs = declare(null, {
		// url: String
		//		URL to server endpoint.
		// content: Object?
		//		Contains properties with string values. These
		//		properties will be serialized as name1=value2 and
		//		passed in the request.
		// timeout: Integer?
		//		Milliseconds to wait for the response. If this time
		//		passes, the then error callbacks are called.
		// form: DOMNode?
		//		DOM node for a form. Used to extract the form values
		//		and send to the server.
		// preventCache: Boolean?
		//		Default is false. If true, then a
		//		"dojo.preventCache" parameter is sent in the request
		//		with a value that changes with each request
		//		(timestamp). Useful only with GET-type requests.
		// handleAs: String?
		//		Acceptable values depend on the type of IO
		//		transport (see specific IO calls for more information).
		// rawBody: String?
		//		Sets the raw body for an HTTP request. If this is used, then the content
		//		property is ignored. This is mostly useful for HTTP methods that have
		//		a body to their requests, like PUT or POST. This property can be used instead
		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
		// ioPublish: Boolean?
		//		Set this explicitly to false to prevent publishing of topics related to
		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
		//		will be published via dojo/topic.publish() for different phases of an IO operation.
		//		See dojo/main.__IoPublish for a list of topics that are published.

		load: function(response, ioArgs){
			// summary:
			//		This function will be
			//		called on a successful HTTP response code.
	 		// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		error: function(response, ioArgs){
			// summary:
			//		This function will
			//		be called when the request fails due to a network or server error, the url
			//		is invalid, etc. It will also be called if the load or handle callback throws an
			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
			//		to continue to run even when a logic error happens in the callback, while making
			//		it easier to troubleshoot while in debug mode.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
			// response: Object
			//		The response in the format as defined with handleAs.
		},

		handle: function(loadOrError, response, ioArgs){
			// summary:
	 		//		This function will
	 		//		be called at the end of every request, whether or not an error occurs.
			// loadOrError: String
			//		Provides a string that tells you whether this function
			//		was called because of success (load) or failure (error).
			// response: Object
			//		The response in the format as defined with handleAs.
			// ioArgs: dojo/main.__IoCallbackArgs
			//		Provides additional information about the request.
		}
	});

	dojo.__IoCallbackArgs = declare(null, {
		// args: Object
		//		the original object argument to the IO call.
		// xhr: XMLHttpRequest
		//		For XMLHttpRequest calls only, the
		//		XMLHttpRequest object that was used for the
		//		request.
		// url: String
		//		The final URL used for the call. Many times it
		//		will be different than the original args.url
		//		value.
		// query: String
		//		For non-GET requests, the
		//		name1=value1&name2=value2 parameters sent up in
		//		the request.
		// handleAs: String
		//		The final indicator on how the response will be
		//		handled.
		// id: String
		//		For dojo/io/script calls only, the internal
		//		script ID used for the request.
		// canDelete: Boolean
		//		For dojo/io/script calls only, indicates
		//		whether the script tag that represents the
		//		request can be deleted after callbacks have
		//		been called. Used internally to know when
		//		cleanup can happen on JSONP-type requests.
		// json: Object
		//		For dojo/io/script calls only: holds the JSON
		//		response for JSONP-type requests. Used
		//		internally to hold on to the JSON responses.
		//		You should not need to access it directly --
		//		the same object should be passed to the success
		//		callbacks directly.
	});

	dojo.__IoPublish = declare(null, {
		// summary:
		//		This is a list of IO topics that can be published
		//		if djConfig.ioPublish is set to true. IO topics can be
		//		published for any Input/Output, network operation. So,
		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
		//		trigger these topics to be published.
		// start: String
		//		"/dojo/io/start" is sent when there are no outstanding IO
		//		requests, and a new IO request is started. No arguments
		//		are passed with this topic.
		// send: String
		//		"/dojo/io/send" is sent whenever a new IO request is started.
		//		It passes the dojo.Deferred for the request with the topic.
		// load: String
		//		"/dojo/io/load" is sent whenever an IO request has loaded
		//		successfully. It passes the response and the dojo.Deferred
		//		for the request with the topic.
		// error: String
		//		"/dojo/io/error" is sent whenever an IO request has errored.
		//		It passes the error and the dojo.Deferred
		//		for the request with the topic.
		// done: String
		//		"/dojo/io/done" is sent whenever an IO request has completed,
		//		either by loading or by erroring. It passes the error and
		//		the dojo.Deferred for the request with the topic.
		// stop: String
		//		"/dojo/io/stop" is sent when all outstanding IO requests have
		//		finished. No arguments are passed with this topic.
	});
	=====*/


	dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
			/*Function*/canceller,
			/*Function*/okHandler,
			/*Function*/errHandler){
		// summary:
		//		sets up the Deferred and ioArgs property on the Deferred so it
		//		can be used in an io call.
		// args:
		//		The args object passed into the public io call. Recognized properties on
		//		the args object are:
		// canceller:
		//		The canceller function used for the Deferred object. The function
		//		will receive one argument, the Deferred object that is related to the
		//		canceller.
		// okHandler:
		//		The first OK callback to be registered with Deferred. It has the opportunity
		//		to transform the OK response. It will receive one argument -- the Deferred
		//		object returned from this function.
		// errHandler:
		//		The first error callback to be registered with Deferred. It has the opportunity
		//		to do cleanup on an error. It will receive two arguments: error (the
		//		Error object) and dfd, the Deferred object returned from this function.

		var ioArgs = {args: args, url: args.url};

		//Get values from form if requested.
		var formObject = null;
		if(args.form){
			var form = dom.byId(args.form);
			//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
			//so use it for all. See #2844
			var actnNode = form.getAttributeNode("action");
			ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : (dojo.doc ? dojo.doc.URL : null));
			formObject = domForm.toObject(form);
		}

		// set up the query params
		var miArgs = {};

		if(formObject){
			// potentially over-ride url-provided params w/ form values
			lang.mixin(miArgs, formObject);
		}
		if(args.content){
			// stuff in content over-rides what's set by form
			lang.mixin(miArgs, args.content);
		}
		if(args.preventCache){
			miArgs["dojo.preventCache"] = new Date().valueOf();
		}
		ioArgs.query = ioq.objectToQuery(miArgs);

		// .. and the real work of getting the deferred in order, etc.
		ioArgs.handleAs = args.handleAs || "text";
		var d = new Deferred(function(dfd){
			dfd.canceled = true;
			canceller && canceller(dfd);

			var err = dfd.ioArgs.error;
			if(!err){
				err = new Error("request cancelled");
				err.dojoType="cancel";
				dfd.ioArgs.error = err;
			}
			return err;
		});
		d.addCallback(okHandler);

		//Support specifying load, error and handle callback functions from the args.
		//For those callbacks, the "this" object will be the args object.
		//The callbacks will get the deferred result value as the
		//first argument and the ioArgs object as the second argument.
		var ld = args.load;
		if(ld && lang.isFunction(ld)){
			d.addCallback(function(value){
				return ld.call(args, value, ioArgs);
			});
		}
		var err = args.error;
		if(err && lang.isFunction(err)){
			d.addErrback(function(value){
				return err.call(args, value, ioArgs);
			});
		}
		var handle = args.handle;
		if(handle && lang.isFunction(handle)){
			d.addBoth(function(value){
				return handle.call(args, value, ioArgs);
			});
		}

		// Attach error handler last (not including topic publishing)
		// to catch any errors that may have been generated from load
		// or handle functions.
		d.addErrback(function(error){
			return errHandler(error, d);
		});

		//Plug in topic publishing, if dojo.publish is loaded.
		if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
			d.addCallbacks(
				function(res){
					dojo.publish("/dojo/io/load", [d, res]);
					return res;
				},
				function(res){
					dojo.publish("/dojo/io/error", [d, res]);
					return res;
				}
			);
			d.addBoth(function(res){
				dojo.publish("/dojo/io/done", [d, res]);
				return res;
			});
		}

		d.ioArgs = ioArgs;

		// FIXME: need to wire up the xhr object's abort method to something
		// analogous in the Deferred
		return d;
	};

	var _deferredOk = function(/*Deferred*/dfd){
		// summary:
		//		okHandler function for dojo._ioSetArgs call.

		var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
		return ret === undefined ? null : ret;
	};
	var _deferError = function(/*Error*/error, /*Deferred*/dfd){
		// summary:
		//		errHandler function for dojo._ioSetArgs call.

		if(!dfd.ioArgs.args.failOk){
			console.error(error);
		}
		return error;
	};

	//Use a separate count for knowing if we are starting/stopping io calls.
	var _checkPubCount = function(dfd){
		if(_pubCount <= 0){
			_pubCount = 0;
			if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
				dojo.publish("/dojo/io/stop");
			}
		}
	};

	var _pubCount = 0;
	aspect.after(watch, "_onAction", function(){
		_pubCount -= 1;
	});
	aspect.after(watch, "_onInFlight", _checkPubCount);

	dojo._ioCancelAll = watch.cancelAll;
	/*=====
	dojo._ioCancelAll = function(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		//		(xhr, script, iframe).
	};
	=====*/

	dojo._ioNotifyStart = function(/*Deferred*/dfd){
		// summary:
		//		If dojo.publish is available, publish topics
		//		about the start of a request queue and/or the
		//		the beginning of request.
		//
		//		Used by IO transports. An IO transport should
		//		call this method before making the network connection.
		if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
			if(!_pubCount){
				dojo.publish("/dojo/io/start");
			}
			_pubCount += 1;
			dojo.publish("/dojo/io/send", [dfd]);
		}
	};

	dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.

		var args = dfd.ioArgs.options = dfd.ioArgs.args;
		lang.mixin(dfd, {
			response: dfd.ioArgs,
			isValid: function(response){
				return validCheck(dfd);
			},
			isReady: function(response){
				return ioCheck(dfd);
			},
			handleResponse: function(response){
				return resHandle(dfd);
			}
		});
		watch(dfd);

		_checkPubCount(dfd);
	};

	var _defaultContentType = "application/x-www-form-urlencoded";

	dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
		// summary:
		//		Adds query params discovered by the io deferred construction to the URL.
		//		Only use this for operations which are fundamentally GET-type operations.
		if(ioArgs.query.length){
			ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
			ioArgs.query = null;
		}
	};

	/*=====
	dojo.__XhrArgs = declare(dojo.__IoArgs, {
		// summary:
		//		In addition to the properties listed for the dojo._IoArgs type,
		//		the following properties are allowed for dojo.xhr* methods.
		// handleAs: String?
		//		Acceptable values are: text (default), json, json-comment-optional,
		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
	 	// sync: Boolean?
		//		false is default. Indicates whether the request should
		//		be a synchronous (blocking) request.
		// headers: Object?
		//		Additional HTTP headers to send in the request.
		// failOk: Boolean?
		//		false is default. Indicates whether a request should be
		//		allowed to fail (and therefore no console error message in
		//		the event of a failure)
		// contentType: String|Boolean
		//		"application/x-www-form-urlencoded" is default. Set to false to
		//		prevent a Content-Type header from being sent, or to a string
		//		to send a different Content-Type.
	 });
	=====*/

	dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
		// summary:
		//		Deprecated.   Use dojo/request instead.
		// description:
		//		Sends an HTTP request with the given method.
		//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
		//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
		//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
		// method:
		//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
		// hasBody:
		//		If the request has an HTTP body, then pass true for hasBody.

		var rDfd;
		//Make the Deferred object for this xhr request.
		var dfd = dojo._ioSetArgs(args, function(dfd){
			rDfd && rDfd.cancel();
		}, _deferredOk, _deferError);
		var ioArgs = dfd.ioArgs;

		//Allow for specifying the HTTP body completely.
		if("postData" in args){
			ioArgs.query = args.postData;
		}else if("putData" in args){
			ioArgs.query = args.putData;
		}else if("rawBody" in args){
			ioArgs.query = args.rawBody;
		}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
			//Check for hasBody being passed. If no hasBody,
			//then only append query string if not a POST or PUT request.
			dojo._ioAddQueryToUrl(ioArgs);
		}

		var options = {
			method: method,
			handleAs: "text",
			timeout: args.timeout,
			withCredentials: args.withCredentials,
			ioArgs: ioArgs
		};

		if(typeof args.headers !== 'undefined'){
			options.headers = args.headers;
		}
		if(typeof args.contentType !== 'undefined'){
			if(!options.headers){
				options.headers = {};
			}
			options.headers['Content-Type'] = args.contentType;
		}
		if(typeof ioArgs.query !== 'undefined'){
			options.data = ioArgs.query;
		}
		if(typeof args.sync !== 'undefined'){
			options.sync = args.sync;
		}

		dojo._ioNotifyStart(dfd);
		try{
			rDfd = _xhr(ioArgs.url, options, true);
		}catch(e){
			// If XHR creation fails, dojo/request/xhr throws
			// When this happens, cancel the deferred
			dfd.cancel();
			return dfd;
		}

		// sync ioArgs
		dfd.ioArgs.xhr = rDfd.response.xhr;

		rDfd.then(function(){
			dfd.resolve(dfd);
		}).otherwise(function(error){
			ioArgs.error = error;
			if(error.response){
				error.status = error.response.status;
				error.responseText = error.response.text;
				error.xhr = error.response.xhr;
			}
			dfd.reject(error);
		});
		return dfd; // dojo/_base/Deferred
	};

	dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP GET request to the server.
		return dojo.xhr("GET", args); // dojo/_base/Deferred
	};

	dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP POST request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// postData:
		//		String. Send raw data in the body of the POST request.
		return dojo.xhr("POST", args, true); // dojo/_base/Deferred
	};

	dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP PUT request to the server. In addition to the properties
		//		listed for the dojo.__XhrArgs type, the following property is allowed:
		// putData:
		//		String. Send raw data in the body of the PUT request.
		return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
	};

	dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
		// summary:
		//		Sends an HTTP DELETE request to the server.
		return dojo.xhr("DELETE", args); // dojo/_base/Deferred
	};

	/*
	dojo.wrapForm = function(formNode){
		// summary:
		//		A replacement for FormBind, but not implemented yet.

		// FIXME: need to think harder about what extensions to this we might
		// want. What should we allow folks to do w/ this? What events to
		// set/send?
		throw new Error("dojo.wrapForm not yet implemented");
	}
	*/

	dojo._isDocumentOk = function(x){
		return util.checkStatus(x.status);
	};

	dojo._getText = function(url){
		var result;
		dojo.xhrGet({url:url, sync:true, load:function(text){
			result = text;
		}});
		return result;
	};

	// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
	lang.mixin(dojo.xhr, {
		_xhrObj: dojo._xhrObj,
		fieldToObject: domForm.fieldToObject,
		formToObject: domForm.toObject,
		objectToQuery: ioq.objectToQuery,
		formToQuery: domForm.toQuery,
		formToJson: domForm.toJson,
		queryToObject: ioq.queryToObject,
		contentHandlers: handlers,
		_ioSetArgs: dojo._ioSetArgs,
		_ioCancelAll: dojo._ioCancelAll,
		_ioNotifyStart: dojo._ioNotifyStart,
		_ioWatch: dojo._ioWatch,
		_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
		_isDocumentOk: dojo._isDocumentOk,
		_getText: dojo._getText,
		get: dojo.xhrGet,
		post: dojo.xhrPost,
		put: dojo.xhrPut,
		del: dojo.xhrDelete	// because "delete" is a reserved word
	});

	return dojo.xhr;
});

},
'dojo/_base/unload':function(){
define(["./kernel", "./lang", "../on"], function(dojo, lang, on){

// module:
//		dojo/unload

var win = window;

var unload = {
	// summary:
	//		This module contains the document and window unload detection API.
	//		This module is deprecated.  Use on(window, "unload", func)
	//		and on(window, "beforeunload", func) instead.

	addOnWindowUnload: function(/*Object|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when window.onunload fires.
		//		Deprecated, use on(window, "unload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnWindowUnload is called Dojo
		//		will register a page listener to trigger your unload
		//		handler with. Note that registering these handlers may
		//		destroy "fastback" page caching in browsers that support
		//		it. Be careful trying to modify the DOM or access
		//		JavaScript properties during this phase of page unloading:
		//		they may not always be available. Consider
		//		addOnUnload() if you need to modify the DOM or do
		//		heavy JavaScript work since it fires at the equivalent of
		//		the page's "onbeforeunload" event.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnWindowUnload(afunc);
		//	|		unload.addOnWindowUnload(foo, "bar");
		//	|		unload.addOnWindowUnload(foo, function(){console.log("", this.data);});
		//	|	});

		if (!dojo.windowUnloaded){
			on(win, "unload", (dojo.windowUnloaded = function(){
				// summary:
				//		signal fired by impending window destruction. You may use
				//		dojo.addOnWindowUnload() to register a listener for this
				//		event. NOTE: if you wish to dojo.connect() to this method
				//		to perform page/application cleanup, be aware that this
				//		event WILL NOT fire if no handler has been registered with
				//		addOnWindowUnload(). This behavior started in Dojo 1.3.
				//		Previous versions always triggered windowUnloaded(). See
				//		addOnWindowUnload for more info.
			}));
		}
		on(win, "unload", lang.hitch(obj, functionName));
	},

	addOnUnload: function(/*Object?|Function?*/ obj, /*String|Function?*/ functionName){
		// summary:
		//		Registers a function to be triggered when the page unloads.
		//		Deprecated, use on(window, "beforeunload", lang.hitch(obj, functionName)) instead.
		// description:
		//		The first time that addOnUnload is called Dojo will
		//		register a page listener to trigger your unload handler
		//		with.
		//
		//		In a browser environment, the functions will be triggered
		//		during the window.onbeforeunload event. Be careful of doing
		//		too much work in an unload handler. onbeforeunload can be
		//		triggered if a link to download a file is clicked, or if
		//		the link is a javascript: link. In these cases, the
		//		onbeforeunload event fires, but the document is not
		//		actually destroyed. So be careful about doing destructive
		//		operations in a dojo.addOnUnload callback.
		//
		//		Further note that calling dojo.addOnUnload will prevent
		//		browsers from using a "fast back" cache to make page
		//		loading via back button instantaneous.
		// example:
		//	|	var afunc = function() {console.log("global function");};
		//	|	require(["dojo/_base/unload"], function(unload) {
		//	|		var foo = {bar: function(){ console.log("bar unloading...");}, 
		//	|		           data: "mydata"};
		//	|		unload.addOnUnload(afunc);
		//	|		unload.addOnUnload(foo, "bar");
		//	|		unload.addOnUnload(foo, function(){console.log("", this.data);});
		//	|	});

		on(win, "beforeunload", lang.hitch(obj, functionName));
	}
};

dojo.addOnWindowUnload = unload.addOnWindowUnload;
dojo.addOnUnload = unload.addOnUnload;

return unload;

});

},
'dojo/Deferred':function(){
define([
	"./has",
	"./_base/lang",
	"./errors/CancelError",
	"./promise/Promise",
	"./promise/instrumentation"
], function(has, lang, CancelError, Promise, instrumentation){
	"use strict";

	// module:
	//		dojo/Deferred

	var PROGRESS = 0,
			RESOLVED = 1,
			REJECTED = 2;
	var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";

	var freezeObject = Object.freeze || function(){};

	var signalWaiting = function(waiting, type, result, rejection, deferred){
		if( 1 ){
			if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
				Deferred.instrumentRejected(result, false, rejection, deferred);
			}
		}

		for(var i = 0; i < waiting.length; i++){
			signalListener(waiting[i], type, result, rejection);
		}
	};

	var signalListener = function(listener, type, result, rejection){
		var func = listener[type];
		var deferred = listener.deferred;
		if(func){
			try{
				var newResult = func(result);
				if(type === PROGRESS){
					if(typeof newResult !== "undefined"){
						signalDeferred(deferred, type, newResult);
					}
				}else{
					if(newResult && typeof newResult.then === "function"){
						listener.cancel = newResult.cancel;
						newResult.then(
								// Only make resolvers if they're actually going to be used
								makeDeferredSignaler(deferred, RESOLVED),
								makeDeferredSignaler(deferred, REJECTED),
								makeDeferredSignaler(deferred, PROGRESS));
						return;
					}
					signalDeferred(deferred, RESOLVED, newResult);
				}
			}catch(error){
				signalDeferred(deferred, REJECTED, error);
			}
		}else{
			signalDeferred(deferred, type, result);
		}

		if( 1 ){
			if(type === REJECTED && Deferred.instrumentRejected){
				Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
			}
		}
	};

	var makeDeferredSignaler = function(deferred, type){
		return function(value){
			signalDeferred(deferred, type, value);
		};
	};

	var signalDeferred = function(deferred, type, result){
		if(!deferred.isCanceled()){
			switch(type){
				case PROGRESS:
					deferred.progress(result);
					break;
				case RESOLVED:
					deferred.resolve(result);
					break;
				case REJECTED:
					deferred.reject(result);
					break;
			}
		}
	};

	var Deferred = function(canceler){
		// summary:
		//		Creates a new deferred. This API is preferred over
		//		`dojo/_base/Deferred`.
		// description:
		//		Creates a new deferred, as an abstraction over (primarily)
		//		asynchronous operations. The deferred is the private interface
		//		that should not be returned to calling code. That's what the
		//		`promise` is for. See `dojo/promise/Promise`.
		// canceler: Function?
		//		Will be invoked if the deferred is canceled. The canceler
		//		receives the reason the deferred was canceled as its argument.
		//		The deferred is rejected with its return value, or a new
		//		`dojo/errors/CancelError` instance.

		// promise: dojo/promise/Promise
		//		The public promise object that clients can add callbacks to. 
		var promise = this.promise = new Promise();

		var deferred = this;
		var fulfilled, result, rejection;
		var canceled = false;
		var waiting = [];

		if( 1  && Error.captureStackTrace){
			Error.captureStackTrace(deferred, Deferred);
			Error.captureStackTrace(promise, Deferred);
		}

		this.isResolved = promise.isResolved = function(){
			// summary:
			//		Checks whether the deferred has been resolved.
			// returns: Boolean

			return fulfilled === RESOLVED;
		};

		this.isRejected = promise.isRejected = function(){
			// summary:
			//		Checks whether the deferred has been rejected.
			// returns: Boolean

			return fulfilled === REJECTED;
		};

		this.isFulfilled = promise.isFulfilled = function(){
			// summary:
			//		Checks whether the deferred has been resolved or rejected.
			// returns: Boolean

			return !!fulfilled;
		};

		this.isCanceled = promise.isCanceled = function(){
			// summary:
			//		Checks whether the deferred has been canceled.
			// returns: Boolean

			return canceled;
		};

		this.progress = function(update, strict){
			// summary:
			//		Emit a progress update on the deferred.
			// description:
			//		Emit a progress update on the deferred. Progress updates
			//		can be used to communicate updates about the asynchronous
			//		operation before it has finished.
			// update: any
			//		The progress update. Passed to progbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently no progress can be emitted.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				signalWaiting(waiting, PROGRESS, update, null, deferred);
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.resolve = function(value, strict){
			// summary:
			//		Resolve the deferred.
			// description:
			//		Resolve the deferred, putting it in a success state.
			// value: any
			//		The result of the deferred. Passed to callbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be resolved.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				// Set fulfilled, store value. After signaling waiting listeners unset
				// waiting.
				signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		var reject = this.reject = function(error, strict){
			// summary:
			//		Reject the deferred.
			// description:
			//		Reject the deferred, putting it in an error state.
			// error: any
			//		The error result of the deferred. Passed to errbacks.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be rejected.
			// returns: dojo/promise/Promise
			//		Returns the original promise for the deferred.

			if(!fulfilled){
				if( 1  && Error.captureStackTrace){
					Error.captureStackTrace(rejection = {}, reject);
				}
				signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
				waiting = null;
				return promise;
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}else{
				return promise;
			}
		};

		this.then = promise.then = function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the deferred.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			var listener = [progback, callback, errback];
			// Ensure we cancel the promise we're waiting for, or if callback/errback
			// have returned a promise, cancel that one.
			listener.cancel = promise.cancel;
			listener.deferred = new Deferred(function(reason){
				// Check whether cancel is really available, returned promises are not
				// required to expose `cancel`
				return listener.cancel && listener.cancel(reason);
			});
			if(fulfilled && !waiting){
				signalListener(listener, fulfilled, result, rejection);
			}else{
				waiting.push(listener);
			}
			return listener.deferred.promise;
		};

		this.cancel = promise.cancel = function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			if(!fulfilled){
				// Cancel can be called even after the deferred is fulfilled
				if(canceler){
					var returnedReason = canceler(reason);
					reason = typeof returnedReason === "undefined" ? reason : returnedReason;
				}
				canceled = true;
				if(!fulfilled){
					// Allow canceler to provide its own reason, but fall back to a CancelError
					if(typeof reason === "undefined"){
						reason = new CancelError();
					}
					reject(reason);
					return reason;
				}else if(fulfilled === REJECTED && result === reason){
					return reason;
				}
			}else if(strict === true){
				throw new Error(FULFILLED_ERROR_MESSAGE);
			}
		};

		freezeObject(promise);
	};

	Deferred.prototype.toString = function(){
		// returns: String
		//		Returns `[object Deferred]`.

		return "[object Deferred]";
	};

	if(instrumentation){
		instrumentation(Deferred);
	}

	return Deferred;
});

},
'dojo/_base/NodeList':function(){
define(["./kernel", "../query", "./array", "./html", "../NodeList-dom"], function(dojo, query, array){
	// module:
	//		dojo/_base/NodeList

	/*=====
	return {
		// summary:
		//		This module extends dojo/NodeList with the legacy connect(), coords(),
		//		blur(), focus(), change(), click(), error(), keydown(), keypress(),
		//		keyup(), load(), mousedown(), mouseenter(), mouseleave(), mousemove(),
		//		mouseout(), mouseover(), mouseup(), and submit() methods.
	};
	=====*/
 
	var NodeList = query.NodeList,
		nlp = NodeList.prototype;

	nlp.connect = NodeList._adaptAsForEach(function(){
		// don't bind early to dojo.connect since we no longer explicitly depend on it
		return dojo.connect.apply(this, arguments);
	});
	/*=====
	nlp.connect = function(methodName, objOrFunc, funcName){
		// summary:
		//		Attach event handlers to every item of the NodeList. Uses dojo.connect()
		//		so event properties are normalized.
		//
		//		Application must manually require() "dojo/_base/connect" before using this method.
		// methodName: String
		//		the name of the method to attach to. For DOM events, this should be
		//		the lower-case name of the event
		// objOrFunc: Object|Function|String
		//		if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
		//		reference a function or be the name of the function in the global
		//		namespace to attach. If 3 arguments are provided
		//		(methodName, objOrFunc, funcName), objOrFunc must be the scope to
		//		locate the bound function in
		// funcName: String?
		//		optional. A string naming the function in objOrFunc to bind to the
		//		event. May also be a function reference.
		// example:
		//		add an onclick handler to every button on the page
		//		|	query("div:nth-child(odd)").connect("onclick", function(e){
		//		|		console.log("clicked!");
		//		|	});
		// example:
		//		attach foo.bar() to every odd div's onmouseover
		//		|	query("div:nth-child(odd)").connect("onmouseover", foo, "bar");

		return null;	// NodeList
	};
	=====*/

	nlp.coords = NodeList._adaptAsMap(dojo.coords);
	/*=====
	nlp.coords = function(){
		// summary:
		//		Deprecated: Use position() for border-box x/y/w/h
		//		or marginBox() for margin-box w/h/l/t.
		//		Returns the box objects of all elements in a node list as
		//		an Array (*not* a NodeList). Acts like `domGeom.coords`, though assumes
		//		the node passed is each node in this list.

		return []; // Array
	};
	=====*/

	NodeList.events = [
		// summary:
		//		list of all DOM events used in NodeList
		"blur", "focus", "change", "click", "error", "keydown", "keypress",
		"keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove",
		"mouseout", "mouseover", "mouseup", "submit"
	];

	// FIXME: pseudo-doc the above automatically generated on-event functions

	// syntactic sugar for DOM events
	array.forEach(NodeList.events, function(evt){
			var _oe = "on" + evt;
			nlp[_oe] = function(a, b){
				return this.connect(_oe, a, b);
			};
				// FIXME: should these events trigger publishes?
				/*
				return (a ? this.connect(_oe, a, b) :
							this.forEach(function(n){
								// FIXME:
								//		listeners get buried by
								//		addEventListener and can't be dug back
								//		out to be triggered externally.
								// see:
								//		http://developer.mozilla.org/en/docs/DOM:element

								console.log(n, evt, _oe);

								// FIXME: need synthetic event support!
								var _e = { target: n, faux: true, type: evt };
								// dojo._event_listener._synthesizeEvent({}, { target: n, faux: true, type: evt });
								try{ n[evt](_e); }catch(e){ console.log(e); }
								try{ n[_oe](_e); }catch(e){ console.log(e); }
							})
				);
				*/
		}
	);

	dojo.NodeList = NodeList;
	return NodeList;
});

},
'dojo/_base/Color':function(){
define(["./kernel", "./lang", "./array", "./config"], function(dojo, lang, ArrayUtil, config){

	var Color = dojo.Color = function(/*Array|String|Object*/ color){
		// summary:
		//		Takes a named string, hex string, array of rgb or rgba values,
		//		an object with r, g, b, and a properties, or another `Color` object
		//		and creates a new Color instance to work from.
		//
		// example:
		//		Work with a Color instance:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var c = new Color();
		//	|		c.setColor([0,0,0]); // black
		//	|		var hex = c.toHex(); // #000000
		//	|	});
		//
		// example:
		//		Work with a node's color:
		//	| 
		//	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
		//	|		var color = domStyle("someNode", "backgroundColor");
		//	|		var n = new Color(color);
		//	|		// adjust the color some
		//	|		n.r *= .5;
		//	|		console.log(n.toString()); // rgb(128, 255, 255);
		//	|	});
		if(color){ this.setColor(color); }
	};

	// FIXME:
	// there's got to be a more space-efficient way to encode or discover
	// these!! Use hex?
	Color.named = {
		// summary:
		//		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
		"black":  [0,0,0],
		"silver": [192,192,192],
		"gray":	  [128,128,128],
		"white":  [255,255,255],
		"maroon": [128,0,0],
		"red":	  [255,0,0],
		"purple": [128,0,128],
		"fuchsia":[255,0,255],
		"green":  [0,128,0],
		"lime":	  [0,255,0],
		"olive":  [128,128,0],
		"yellow": [255,255,0],
		"navy":	  [0,0,128],
		"blue":	  [0,0,255],
		"teal":	  [0,128,128],
		"aqua":	  [0,255,255],
		"transparent": config.transparentColor || [0,0,0,0]
	};

	lang.extend(Color, {
		r: 255, g: 255, b: 255, a: 1,
		_set: function(r, g, b, a){
			var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
		},
		setColor: function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `Color` object
			//		and sets this color instance to that value.
			//
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color(); // no color
			//	|		c.setColor("#ededed"); // greyish
			//	|	});
			if(lang.isString(color)){
				Color.fromString(color, this);
			}else if(lang.isArray(color)){
				Color.fromArray(color, this);
			}else{
				this._set(color.r, color.g, color.b, color.a);
				if(!(color instanceof Color)){ this.sanitize(); }
			}
			return this;	// Color
		},
		sanitize: function(){
			// summary:
			//		Ensures the object has correct attributes
			// description:
			//		the default implementation does nothing, include dojo.colors to
			//		augment it with real checks
			return this;	// Color
		},
		toRgb: function(){
			// summary:
			//		Returns 3 component array of rgb values
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#000000");
			//	|		console.log(c.toRgb()); // [0,0,0]
			//	|	});
			var t = this;
			return [t.r, t.g, t.b]; // Array
		},
		toRgba: function(){
			// summary:
			//		Returns a 4 component array of rgba values from the color
			//		represented by this object.
			var t = this;
			return [t.r, t.g, t.b, t.a];	// Array
		},
		toHex: function(){
			// summary:
			//		Returns a CSS color string in hexadecimal representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		console.log(new Color([0,0,0]).toHex()); // #000000
			//	|	});
			var arr = ArrayUtil.map(["r", "g", "b"], function(x){
				var s = this[x].toString(16);
				return s.length < 2 ? "0" + s : s;
			}, this);
			return "#" + arr.join("");	// String
		},
		toCss: function(/*Boolean?*/ includeAlpha){
			// summary:
			//		Returns a css color string in rgb(a) representation
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color("#FFF").toCss();
			//	|		console.log(c); // rgb('255','255','255')
			//	|	});
			var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
			return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
		},
		toString: function(){
			// summary:
			//		Returns a visual representation of the color
			return this.toCss(true); // String
		}
	});

	Color.blendColors = dojo.blendColors = function(
		/*Color*/ start,
		/*Color*/ end,
		/*Number*/ weight,
		/*Color?*/ obj
	){
		// summary:
		//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
		//		can reuse a previously allocated Color object for the result
		var t = obj || new Color();
		t.r = Math.round(start.r + (end.r - start.r) * weight);
		t.g = Math.round(start.g + (end.g - start.g) * weight);
		t.b = Math.round(start.b + (end.b - start.b) * weight);
		t.a = start.a + (end.a - start.a) * weight;
		return t.sanitize();	// Color
	};

	Color.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Returns a `Color` instance from a string of the form
		//		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
		//		object to update with the parsed value and return instead of
		//		creating a new object.
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
		return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);	// Color
	};

	Color.fromHex = dojo.colorFromHex = function(/*String*/ color, /*Color?*/ obj){
		// summary:
		//		Converts a hex string with a '#' prefix to a color object.
		//		Supports 12-bit #rgb shorthand. Optionally accepts a
		//		`Color` object to update with the parsed value.
		//
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		//
		// example:
		//	|	require(["dojo/_base/color"], function(Color){
		//	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
		//	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
		//	|	});
		var t = obj || new Color(),
			bits = (color.length == 4) ? 4 : 8,
			mask = (1 << bits) - 1;
		color = Number("0x" + color.substr(1));
		if(isNaN(color)){
			return null; // Color
		}
		ArrayUtil.forEach(["b", "g", "r"], function(x){
			var c = color & mask;
			color >>= bits;
			t[x] = bits == 4 ? 17 * c : c;
		});
		t.a = 1;
		return t;	// Color
	};

	Color.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*Color?*/ obj){
		// summary:
		//		Builds a `Color` from a 3 or 4 element array, mapping each
		//		element in sequence to the rgb(a) values of the color.
		// example:
		//		|	require(["dojo/_base/color"], function(Color){
		//		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
		//		|	});
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var t = obj || new Color();
		t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
		if(isNaN(t.a)){ t.a = 1; }
		return t.sanitize();	// Color
	};

	Color.fromString = dojo.colorFromString = function(/*String*/ str, /*Color?*/ obj){
		// summary:
		//		Parses `str` for a color value. Accepts hex, rgb, and rgba
		//		style color values.
		// description:
		//		Acceptable input values for str may include arrays of any form
		//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
		//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
		//		10, 50)"
		// returns:
		//		A Color object. If obj is passed, it will be the return value.
		var a = Color.named[str];
		return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);	// Color
	};

	return Color;
});

},
'dojo/promise/instrumentation':function(){
define([
	"./tracer",
	"../has",
	"../_base/lang",
	"../_base/array"
], function(tracer, has, lang, arrayUtil){
	has.add("config-useDeferredInstrumentation", "report-unhandled-rejections");

	function logError(error, rejection, deferred){
		if(error && error.log === false){
			return;
		}
		var stack = "";
		if(error && error.stack){
			stack += error.stack;
		}
		if(rejection && rejection.stack){
			stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ");
		}
		if(deferred && deferred.stack){
			stack += "\n    ----------------------------------------\n" + deferred.stack;
		}
		console.error(error, stack);
	}

	function reportRejections(error, handled, rejection, deferred){
		if(!handled){
			logError(error, rejection, deferred);
		}
	}

	var errors = [];
	var activeTimeout = false;
	var unhandledWait = 1000;
	function trackUnhandledRejections(error, handled, rejection, deferred){
		// try to find the existing tracking object
		if(!arrayUtil.some(errors, function(obj){
			if(obj.error === error){
				// found the tracking object for this error
				if(handled){
					// if handled, update the state
					obj.handled = true;
				}
				return true;
			}
		})){
			// no tracking object has been setup, create one
			errors.push({
				error: error,
				rejection: rejection,
				handled: handled,
				deferred: deferred,
				timestamp: new Date().getTime()
			});
		}

		if(!activeTimeout){
			activeTimeout = setTimeout(logRejected, unhandledWait);
		}
	}

	function logRejected(){
		var now = new Date().getTime();
		var reportBefore = now - unhandledWait;
		errors = arrayUtil.filter(errors, function(obj){
			// only report the error if we have waited long enough and
			// it hasn't been handled
			if(obj.timestamp < reportBefore){
				if(!obj.handled){
					logError(obj.error, obj.rejection, obj.deferred);
				}
				return false;
			}
			return true;
		});

		if(errors.length){
			activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);
		}else{
			activeTimeout = false;
		}
	}

	return function(Deferred){
		// summary:
		//		Initialize instrumentation for the Deferred class.
		// description:
		//		Initialize instrumentation for the Deferred class.
		//		Done automatically by `dojo/Deferred` if the
		//		`deferredInstrumentation` and `useDeferredInstrumentation`
		//		config options are set.
		//
		//		Sets up `dojo/promise/tracer` to log to the console.
		//
		//		Sets up instrumentation of rejected deferreds so unhandled
		//		errors are logged to the console.

		var usage = has("config-useDeferredInstrumentation");
		if(usage){
			tracer.on("resolved", lang.hitch(console, "log", "resolved"));
			tracer.on("rejected", lang.hitch(console, "log", "rejected"));
			tracer.on("progress", lang.hitch(console, "log", "progress"));

			var args = [];
			if(typeof usage === "string"){
				args = usage.split(",");
				usage = args.shift();
			}
			if(usage === "report-rejections"){
				Deferred.instrumentRejected = reportRejections;
			}else if(usage === "report-unhandled-rejections" || usage === true || usage === 1){
				Deferred.instrumentRejected = trackUnhandledRejections;
				unhandledWait = parseInt(args[0], 10) || unhandledWait;
			}else{
				throw new Error("Unsupported instrumentation usage <" + usage + ">");
			}
		}
	};
});

},
'dojo/selector/_loader':function(){
define(["../has", "require"],
		function(has, require){

"use strict";
if (typeof document !== "undefined") {
	var testDiv = document.createElement("div");
	has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
	has.add("dom-qsa3", function(){
		// test to see if we have a reasonable native selector engine available
		try{
			testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
			// Safari can't handle uppercase or unicode characters when
			// in quirks mode, IE8 can't handle pseudos like :empty
			return testDiv.querySelectorAll(".TEST:empty").length == 1;
		}catch(e){}
	});
}

var fullEngine;
var acme = "./acme", lite = "./lite";
return {
	// summary:
	//		This module handles loading the appropriate selector engine for the given browser

	load: function(id, parentRequire, loaded, config){
		if (config && config.isBuild) {
			//Indicate that the optimizer should not wait
			//for this resource any more and complete optimization.
			//This resource will be resolved dynamically during
			//run time in the web browser.
			loaded();
			return;
		}

		var req = require;
		// here we implement the default logic for choosing a selector engine
		id = id == "default" ? has("config-selectorEngine") || "css3" : id;
		id = id == "css2" || id == "lite" ? lite :
				id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
				id == "css3" ? has("dom-qsa3") ? lite : acme :
				id == "acme" ? acme : (req = parentRequire) && id;
		if(id.charAt(id.length-1) == '?'){
			id = id.substring(0,id.length - 1);
			var optionalLoad = true;
		}
		// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
		if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
			return loaded(fullEngine);
		}
		// load the referenced selector engine
		req([id], function(engine){
			if(id != "./lite"){
				fullEngine = engine;
			}
			loaded(engine);
		});
	}
};
});

},
'dojo/promise/Promise':function(){
define([
	"../_base/lang"
], function(lang){
	"use strict";

	// module:
	//		dojo/promise/Promise

	function throwAbstract(){
		throw new TypeError("abstract");
	}

	return lang.extend(function Promise(){
		// summary:
		//		The public interface to a deferred.
		// description:
		//		The public interface to a deferred. All promises in Dojo are
		//		instances of this class.
	}, {
		then: function(callback, errback, progback){
			// summary:
			//		Add new callbacks to the promise.
			// description:
			//		Add new callbacks to the deferred. Callbacks can be added
			//		before or after the deferred is fulfilled.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved.
			//		Receives the resolution value.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			//		Receives the rejection error.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress
			//		update. Receives the progress update.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback(s).
			//		This can be used for chaining many asynchronous operations.

			throwAbstract();
		},

		cancel: function(reason, strict){
			// summary:
			//		Inform the deferred it may cancel its asynchronous operation.
			// description:
			//		Inform the deferred it may cancel its asynchronous operation.
			//		The deferred's (optional) canceler is invoked and the
			//		deferred will be left in a rejected state. Can affect other
			//		promises that originate with the same deferred.
			// reason: any
			//		A message that may be sent to the deferred's canceler,
			//		explaining why it's being canceled.
			// strict: Boolean?
			//		If strict, will throw an error if the deferred has already
			//		been fulfilled and consequently cannot be canceled.
			// returns: any
			//		Returns the rejection reason if the deferred was canceled
			//		normally.

			throwAbstract();
		},

		isResolved: function(){
			// summary:
			//		Checks whether the promise has been resolved.
			// returns: Boolean

			throwAbstract();
		},

		isRejected: function(){
			// summary:
			//		Checks whether the promise has been rejected.
			// returns: Boolean

			throwAbstract();
		},

		isFulfilled: function(){
			// summary:
			//		Checks whether the promise has been resolved or rejected.
			// returns: Boolean

			throwAbstract();
		},

		isCanceled: function(){
			// summary:
			//		Checks whether the promise has been canceled.
			// returns: Boolean

			throwAbstract();
		},

		always: function(callbackOrErrback){
			// summary:
			//		Add a callback to be invoked when the promise is resolved
			//		or rejected.
			// callbackOrErrback: Function?
			//		A function that is used both as a callback and errback.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the callback/errback.

			return this.then(callbackOrErrback, callbackOrErrback);
		},

		"catch": function(errback){
		    // summary:
		    //		Add new errbacks to the promise. Follows ECMA specification naming.
		    // errback: Function?
		    //		Callback to be invoked when the promise is rejected.
		    // returns: dojo/promise/Promise
		    //		Returns a new promise for the result of the errback.

		    return this.then(null, errback);
		},

		otherwise: function(errback){
			// summary:
			//		Add new errbacks to the promise.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// returns: dojo/promise/Promise
			//		Returns a new promise for the result of the errback.

			return this.then(null, errback);
		},

		trace: function(){
			return this;
		},

		traceRejected: function(){
			return this;
		},

		toString: function(){
			// returns: string
			//		Returns `[object Promise]`.

			return "[object Promise]";
		}
	});
});

},
'dojo/request/watch':function(){
define([
	'./util',
	'../errors/RequestTimeoutError',
	'../errors/CancelError',
	'../_base/array',
	'../_base/window',
	'../has!host-browser?dom-addeventlistener?:../on:'
], function(util, RequestTimeoutError, CancelError, array, win, on){
	// avoid setting a timer per request. It degrades performance on IE
	// something fierece if we don't use unified loops.
	var _inFlightIntvl = null,
		_inFlight = [];

	function watchInFlight(){
		// summary:
		//		internal method that checks each inflight XMLHttpRequest to see
		//		if it has completed or if the timeout situation applies.

		var now = +(new Date);

		// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
		for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
			var response = dfd.response,
				options = response.options;
			if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
				_inFlight.splice(i--, 1);
				watch._onAction && watch._onAction();
			}else if(dfd.isReady && dfd.isReady(response)){
				_inFlight.splice(i--, 1);
				dfd.handleResponse(response);
				watch._onAction && watch._onAction();
			}else if(dfd.startTime){
				// did we timeout?
				if(dfd.startTime + (options.timeout || 0) < now){
					_inFlight.splice(i--, 1);
					// Cancel the request so the io module can do appropriate cleanup.
					dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
					watch._onAction && watch._onAction();
				}
			}
		}

		watch._onInFlight && watch._onInFlight(dfd);

		if(!_inFlight.length){
			clearInterval(_inFlightIntvl);
			_inFlightIntvl = null;
		}
	}

	function watch(dfd){
		// summary:
		//		Watches the io request represented by dfd to see if it completes.
		// dfd: Deferred
		//		The Deferred object to watch.
		// response: Object
		//		The object used as the value of the request promise.
		// validCheck: Function
		//		Function used to check if the IO request is still valid. Gets the dfd
		//		object as its only argument.
		// ioCheck: Function
		//		Function used to check if basic IO call worked. Gets the dfd
		//		object as its only argument.
		// resHandle: Function
		//		Function used to process response. Gets the dfd
		//		object as its only argument.
		if(dfd.response.options.timeout){
			dfd.startTime = +(new Date);
		}

		if(dfd.isFulfilled()){
			// bail out if the deferred is already fulfilled
			return;
		}

		_inFlight.push(dfd);
		if(!_inFlightIntvl){
			_inFlightIntvl = setInterval(watchInFlight, 50);
		}

		// handle sync requests separately from async:
		// http://bugs.dojotoolkit.org/ticket/8467
		if(dfd.response.options.sync){
			watchInFlight();
		}
	}

	watch.cancelAll = function cancelAll(){
		// summary:
		//		Cancels all pending IO requests, regardless of IO type
		try{
			array.forEach(_inFlight, function(dfd){
				try{
					dfd.cancel(new CancelError('All requests canceled.'));
				}catch(e){}
			});
		}catch(e){}
	};

	if(win && on && win.doc.attachEvent){
		// Automatically call cancel all io calls on unload in IE
		// http://bugs.dojotoolkit.org/ticket/2357
		on(win.global, 'unload', function(){
			watch.cancelAll();
		});
	}

	return watch;
});

},
'dojo/selector/lite':function(){
define(["../has", "../_base/kernel"], function(has, dojo){
"use strict";

var testDiv = document.createElement("div");
var matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
var querySelectorAll = testDiv.querySelectorAll;
var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
has.add("dom-matches-selector", !!matchesSelector);
has.add("dom-qsa", !!querySelectorAll); 

// this is a simple query engine. It has handles basic selectors, and for simple
// common selectors is extremely fast
var liteEngine = function(selector, root){
	// summary:
	//		A small lightweight query selector engine that implements CSS2.1 selectors
	//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors

	if(combine && selector.indexOf(',') > -1){
		return combine(selector, root);
	}
	// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
	// that we don't use dojo/_base/window's doc to reduce dependencies, and 
	// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
	// presumably we will have a better way to do this in 2.0 
	var doc = root ? root.ownerDocument || root : dojo.doc || document, 
		match = (querySelectorAll ? 
			/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
			/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
			.exec(selector);
	root = root || doc;
	if(match){
		var isInsideDomTree = has('ie') === 8 && has('quirks')?
			root.nodeType === doc.nodeType:
			root.parentNode !== null && root.nodeType !== 9 && root.parentNode === doc;

		// fast path regardless of whether or not querySelectorAll exists
		if(match[2] && isInsideDomTree){
			// an #id
			// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
			var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
			if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
				// if there is a tag qualifer and it doesn't match, no matches
				return [];
			}
			if(root != doc){
				// there is a root element, make sure we are a child of it
				var parent = found;
				while(parent != root){
					parent = parent.parentNode;
					if(!parent){
						return [];
					}
				}
			}
			return match[3] ?
					liteEngine(match[3], found) 
					: [found];
		}
		if(match[3] && root.getElementsByClassName){
			// a .class
			return root.getElementsByClassName(match[4]);
		}
		var found;
		if(match[5]){
			// a tag
			found = root.getElementsByTagName(match[5]);
			if(match[4] || match[6]){
				selector = (match[4] || "") + match[6];
			}else{
				// that was the entirety of the query, return results
				return found;
			}
		}
	}
	if(querySelectorAll){
		// qSA works strangely on Element-rooted queries
		// We can work around this by specifying an extra ID on the root
		// and working up from there (Thanks to Andrew Dupont for the technique)
		// IE 8 doesn't work on object elements
		if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
			return useRoot(root, selector, root.querySelectorAll);
		}else{
			// we can use the native qSA
			return root.querySelectorAll(selector);
		}
	}else if(!found){
		// search all children and then filter
		found = root.getElementsByTagName("*");
	}
	// now we filter the nodes that were found using the matchesSelector
	var results = [];
	for(var i = 0, l = found.length; i < l; i++){
		var node = found[i];
		if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
			// keep the nodes that match the selector
			results.push(node);
		}
	}
	return results;
};
var useRoot = function(context, query, method){
	// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
	var oldContext = context,
		old = context.getAttribute("id"),
		nid = old || "__dojo__",
		hasParent = context.parentNode,
		relativeHierarchySelector = /^\s*[+~]/.test(query);

	if(relativeHierarchySelector && !hasParent){
		return [];
	}
	if(!old){
		context.setAttribute("id", nid);
	}else{
		nid = nid.replace(/'/g, "\\$&");
	}
	if(relativeHierarchySelector && hasParent){
		context = context.parentNode;
	}
	var selectors = query.match(unionSplit);
	for(var i = 0; i < selectors.length; i++){
		selectors[i] = "[id='" + nid + "'] " + selectors[i];
	}
	query = selectors.join(",");

	try{
		return method.call(context, query);
	}finally{
		if(!old){
			oldContext.removeAttribute("id");
		}
	}
};

if(!has("dom-matches-selector")){
	var jsMatchesSelector = (function(){
		// a JS implementation of CSS selector matching, first we start with the various handlers
		var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
		var selectorTypes = {
			"": function(tagName){
				tagName = tagName[caseFix]();
				return function(node){
					return node.tagName == tagName;
				};
			},
			".": function(className){
				var classNameSpaced = ' ' + className + ' ';
				return function(node){
					return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
				};
			},
			"#": function(id){
				return function(node){
					return node.id == id;
				};
			}
		};
		var attrComparators = {
			"^=": function(attrValue, value){
				return attrValue.indexOf(value) == 0;
			},
			"*=": function(attrValue, value){
				return attrValue.indexOf(value) > -1;
			},
			"$=": function(attrValue, value){
				return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
			},
			"~=": function(attrValue, value){
				return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
			},
			"|=": function(attrValue, value){
				return (attrValue + '-').indexOf(value + '-') == 0;
			},
			"=": function(attrValue, value){
				return attrValue == value;
			},
			"": function(attrValue, value){
				return true;
			}
		};
		function attr(name, value, type){
			var firstChar = value.charAt(0);
			if(firstChar == '"' || firstChar == "'"){
				// it is quoted, remove the quotes
				value = value.slice(1, -1);
			}
			value = value.replace(/\\/g,'');
			var comparator = attrComparators[type || ""];
			return function(node){
				var attrValue = node.getAttribute(name);
				return attrValue && comparator(attrValue, value);
			};
		}
		function ancestor(matcher){
			return function(node, root){
				while((node = node.parentNode) != root){
					if(matcher(node, root)){
						return true;
					}
				}
			};
		}
		function parent(matcher){
			return function(node, root){
				node = node.parentNode;
				return matcher ? 
					node != root && matcher(node, root)
					: node == root;
			};
		}
		var cache = {};
		function and(matcher, next){
			return matcher ?
				function(node, root){
					return next(node) && matcher(node, root);
				}
				: next;
		}
		return function(node, selector, root){
			// this returns true or false based on if the node matches the selector (optionally within the given root)
			var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
			if(!matcher){
				// create a matcher function for the given selector
				// parse the selectors
				if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
					if(value){
						matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
					}
					else if(combinator){
						matcher = (combinator == " " ? ancestor : parent)(matcher);
					}
					else if(attrName){
						matcher = and(matcher, attr(attrName, attrValue, attrType));
					}
					return "";
				})){
					throw new Error("Syntax error in query");
				}
				if(!matcher){
					return true;
				}
				cache[selector] = matcher;
			}
			// now run the matcher function on the node
			return matcher(node, root);
		};
	})();
}
if(!has("dom-qsa")){
	var combine = function(selector, root){
		// combined queries
		var selectors = selector.match(unionSplit);
		var indexed = [];
		// add all results and keep unique ones, this only runs in IE, so we take advantage 
		// of known IE features, particularly sourceIndex which is unique and allows us to 
		// order the results 
		for(var i = 0; i < selectors.length; i++){
			selector = new String(selectors[i].replace(/\s*$/,''));
			selector.indexOf = escape; // keep it from recursively entering combine
			var results = liteEngine(selector, root);
			for(var j = 0, l = results.length; j < l; j++){
				var node = results[j];
				indexed[node.sourceIndex] = node;
			}
		}
		// now convert from a sparse array to a dense array
		var totalResults = [];
		for(i in indexed){
			totalResults.push(indexed[i]);
		}
		return totalResults;
	};
}

liteEngine.match = matchesSelector ? function(node, selector, root){
	if(root && root.nodeType != 9){
		// doesn't support three args, use rooted id trick
		return useRoot(root, selector, function(query){
			return matchesSelector.call(node, query);
		});
	}
	// we have a native matchesSelector, use that
	return matchesSelector.call(node, selector);
} : jsMatchesSelector; // otherwise use the JS matches impl

return liteEngine;
});

},
'dojo/on':function(){
define(["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function(aspect, dojo, has){

	"use strict";
	if( 1 ){ // check to make sure we are in a browser, this module should work anywhere
		var major = window.ScriptEngineMajorVersion;
		has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
		has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
		has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
		has.add("event-focusin", function(global, doc, element){
			return 'onfocusin' in element;
		});

		if(has("touch")){
			has.add("touch-can-modify-event-delegate", function(){
				// This feature test checks whether deleting a property of an event delegate works
				// for a touch-enabled device. If it works, event delegation can be used as fallback
				// for browsers such as Safari in older iOS where deleting properties of the original
				// event does not work.
				var EventDelegate = function(){};
				EventDelegate.prototype =
					document.createEvent("MouseEvents"); // original event
				// Attempt to modify a property of an event delegate and check if
				// it succeeds. Depending on browsers and on whether dojo/on's
				// strict mode is stripped in a Dojo build, there are 3 known behaviors:
				// it may either succeed, or raise an error, or fail to set the property
				// without raising an error.
				try{
					var eventDelegate = new EventDelegate;
					eventDelegate.target = null;
					return eventDelegate.target === null;
				}catch(e){
					return false; // cannot use event delegation
				}
			});
		}
	}
	var on = function(target, type, listener, dontFix){
		// summary:
		//		A function that provides core event listening functionality. With this function
		//		you can provide a target, event type, and listener to be notified of
		//		future matching events that are fired.
		// target: Element|Object
		//		This is the target object or DOM element that to receive events from
		// type: String|Function
		//		This is the name of the event to listen for or an extension event type.
		// listener: Function
		//		This is the function that should be called when the event fires.
		// returns: Object
		//		An object with a remove() method that can be used to stop listening for this
		//		event.
		// description:
		//		To listen for "click" events on a button node, we can do:
		//		|	define(["dojo/on"], function(on){
		//		|		on(button, "click", clickHandler);
		//		|		...
		//		Evented JavaScript objects can also have their own events.
		//		|	var obj = new Evented;
		//		|	on(obj, "foo", fooHandler);
		//		And then we could publish a "foo" event:
		//		|	on.emit(obj, "foo", {key: "value"});
		//		We can use extension events as well. For example, you could listen for a tap gesture:
		//		|	define(["dojo/on", "dojo/gesture/tap", function(on, tap){
		//		|		on(button, tap, tapHandler);
		//		|		...
		//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
		//		|	obj.onfoo({key:"value"});
		//		If you use on.emit on a DOM node, it will use native event dispatching when possible.

		if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
			// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
			// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
			// Element prototype
			return target.on(type, listener);
		}
		// delegate to main listener code
		return on.parse(target, type, listener, addListener, dontFix, this);
	};
	on.pausable =  function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but with pausable functionality. The
		//		returned signal object has pause() and resume() functions. Calling the
		//		pause() method will cause the listener to not be called for future events. Calling the
		//		resume() method will cause the listener to again be called for future events.
		var paused;
		var signal = on(target, type, function(){
			if(!paused){
				return listener.apply(this, arguments);
			}
		}, dontFix);
		signal.pause = function(){
			paused = true;
		};
		signal.resume = function(){
			paused = false;
		};
		return signal;
	};
	on.once = function(target, type, listener, dontFix){
		// summary:
		//		This function acts the same as on(), but will only call the listener once. The
		//		listener will be called for the first
		//		event that takes place and then listener will automatically be removed.
		var signal = on(target, type, function(){
			// remove this listener
			signal.remove();
			// proceed to call the listener
			return listener.apply(this, arguments);
		});
		return signal;
	};
	on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
		var events;
		if(type.call){
			// event handler function
			// on(node, touch.press, touchListener);
			return type.call(matchesTarget, target, listener);
		}

		if(type instanceof Array){
			// allow an array of event names (or event handler functions)
			events = type;
		}else if(type.indexOf(",") > -1){
			// we allow comma delimited event names, so you can register for multiple events at once
			events = type.split(/\s*,\s*/);
		}
		if(events){
			var handles = [];
			var i = 0;
			var eventName;
			while(eventName = events[i++]){ // intentional assignment
				handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
			}
			handles.remove = function(){
				for(var i = 0; i < handles.length; i++){
					handles[i].remove();
				}
			};
			return handles;
		}
		return addListener(target, type, listener, dontFix, matchesTarget);
	};
	var touchEvents = /^touch/;
	function addListener(target, type, listener, dontFix, matchesTarget){
		// event delegation:
		var selector = type.match(/(.*):(.*)/);
		// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
		if(selector){
			type = selector[2];
			selector = selector[1];
			// create the extension event for selectors and directly call it
			return on.selector(selector, type).call(matchesTarget, target, listener);
		}
		// test to see if it a touch event right now, so we don't have to do it every time it fires
		if(has("touch")){
			if(touchEvents.test(type)){
				// touch event, fix it
				listener = fixTouchListener(listener);
			}
			if(!has("event-orientationchange") && (type == "orientationchange")){
				//"orientationchange" not supported <= Android 2.1,
				//but works through "resize" on window
				type = "resize";
				target = window;
				listener = fixTouchListener(listener);
			}
		}
		if(addStopImmediate){
			// add stopImmediatePropagation if it doesn't exist
			listener = addStopImmediate(listener);
		}
		// normal path, the target is |this|
		if(target.addEventListener){
			// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
			// check for capture conversions
			var capture = type in captures,
				adjustedType = capture ? captures[type] : type;
			target.addEventListener(adjustedType, listener, capture);
			// create and return the signal
			return {
				remove: function(){
					target.removeEventListener(adjustedType, listener, capture);
				}
			};
		}
		type = "on" + type;
		if(fixAttach && target.attachEvent){
			return fixAttach(target, type, listener);
		}
		throw new Error("Target must be an event emitter");
	}
	on.matches = function(node, selector, context, children, matchesTarget) {
		// summary:
		//		Check if a node match the current selector within the constraint of a context
		// node: DOMNode
		//		The node that originate the event
		// selector: String
		//		The selector to check against
		// context: DOMNode
		//		The context to search in.
		// children: Boolean
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// matchesTarget: Object|dojo/query?
		//		An object with a property "matches" as a function. Default is dojo/query.
		//		Matching DOMNodes will be done against this function
		//		The function must return a Boolean.
		//		It will have 3 arguments: "node", "selector" and "context"
		//		True is expected if "node" is matching the current "selector" in the passed "context"
		// returns: DOMNode?
		//		The matching node, if any. Else you get false

		// see if we have a valid matchesTarget or default to dojo/query
		matchesTarget = matchesTarget && (typeof matchesTarget.matches == "function") ? matchesTarget : dojo.query;
		children = children !== false;
		// there is a selector, so make sure it matches
		if(node.nodeType != 1){
			// text node will fail in native match selector
			node = node.parentNode;
		}
		while(!matchesTarget.matches(node, selector, context)){
			if(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment
				return false;
			}
		}
		return node;
	};
	on.selector = function(selector, eventType, children){
		// summary:
		//		Creates a new extension event with event delegation. This is based on
		//		the provided event type (can be extension event) that
		//		only calls the listener when the CSS selector matches the target of the event.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		// selector:
		//		The CSS selector to use for filter events and determine the |this| of the event listener.
		// eventType:
		//		The event to listen for
		// children:
		//		Indicates if children elements of the selector should be allowed. This defaults to
		//		true
		// example:
		// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(on, mouse){
		// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
		return function(target, listener){
			// if the selector is function, use it to select the node, otherwise use the matches method
			var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
				bubble = eventType.bubble;
			function select(eventTarget){
				return on.matches(eventTarget, selector, target, children, matchesTarget);
			}
			if(bubble){
				// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
				return on(target, bubble(select), listener);
			}
			// standard event delegation
			return on(target, eventType, function(event){
				// call select to see if we match
				var eventTarget = select(event.target);
				// if it matches we call the listener
				if (eventTarget) {
					// We save the matching target into the event, so it can be accessed even when hitching (see #18355)
					event.selectorTarget = eventTarget;
					return listener.call(eventTarget, event);
				}
			});
		};
	};

	function syntheticPreventDefault(){
		this.cancelable = false;
		this.defaultPrevented = true;
	}
	function syntheticStopPropagation(){
		this.bubbles = false;
	}
	var slice = [].slice,
		syntheticDispatch = on.emit = function(target, type, event){
		// summary:
		//		Fires an event on the target object.
		// target:
		//		The target object to fire the event on. This can be a DOM element or a plain
		//		JS object. If the target is a DOM element, native event emitting mechanisms
		//		are used when possible.
		// type:
		//		The event type name. You can emulate standard native events like "click" and
		//		"mouseover" or create custom events like "open" or "finish".
		// event:
		//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
		//		for some of the properties. These properties are copied to the event object.
		//		Of particular importance are the cancelable and bubbles properties. The
		//		cancelable property indicates whether or not the event has a default action
		//		that can be cancelled. The event is cancelled by calling preventDefault() on
		//		the event object. The bubbles property indicates whether or not the
		//		event will bubble up the DOM tree. If bubbles is true, the event will be called
		//		on the target and then each parent successively until the top of the tree
		//		is reached or stopPropagation() is called. Both bubbles and cancelable
		//		default to false.
		// returns:
		//		If the event is cancelable and the event is not cancelled,
		//		emit will return true. If the event is cancelable and the event is cancelled,
		//		emit will return false.
		// details:
		//		Note that this is designed to emit events for listeners registered through
		//		dojo/on. It should actually work with any event listener except those
		//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
		//		doesn't support custom event types). It should work with all events registered
		//		through dojo/on. Also note that the emit method does do any default
		//		action, it only returns a value to indicate if the default action should take
		//		place. For example, emitting a keypress event would not cause a character
		//		to appear in a textbox.
		// example:
		//		To fire our own click event
		//	|	require(["dojo/on", "dojo/dom"
		//	|	], function(on, dom){
		//	|		on.emit(dom.byId("button"), "click", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			screenX: 33,
		//	|			screenY: 44
		//	|		});
		//		We can also fire our own custom events:
		//	|		on.emit(dom.byId("slider"), "slide", {
		//	|			cancelable: true,
		//	|			bubbles: true,
		//	|			direction: "left-to-right"
		//	|		});
		//	|	});
		var args = slice.call(arguments, 2);
		var method = "on" + type;
		if("parentNode" in target){
			// node (or node-like), create event controller methods
			var newEvent = args[0] = {};
			for(var i in event){
				newEvent[i] = event[i];
			}
			newEvent.preventDefault = syntheticPreventDefault;
			newEvent.stopPropagation = syntheticStopPropagation;
			newEvent.target = target;
			newEvent.type = type;
			event = newEvent;
		}
		do{
			// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
			target[method] && target[method].apply(target, args);
			// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
		}while(event && event.bubbles && (target = target.parentNode));
		return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
	};
	var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
	if(!has("event-stopimmediatepropagation")){
		var stopImmediatePropagation =function(){
			this.immediatelyStopped = true;
			this.modified = true; // mark it as modified so the event will be cached in IE
		};
		var addStopImmediate = function(listener){
			return function(event){
				if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
					event.stopImmediatePropagation = stopImmediatePropagation;
					return listener.apply(this, arguments);
				}
			};
		};
	}
	if(has("dom-addeventlistener")){
		// emitter that works with native event handling
		on.emit = function(target, type, event){
			if(target.dispatchEvent && document.createEvent){
				// use the native event emitting mechanism if it is available on the target object
				// create a generic event
				// we could create branch into the different types of event constructors, but
				// that would be a lot of extra code, with little benefit that I can see, seems
				// best to use the generic constructor and copy properties over, making it
				// easy to have events look like the ones created with specific initializers
				var ownerDocument = target.ownerDocument || document;
				var nativeEvent = ownerDocument.createEvent("HTMLEvents");
				nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
				// and copy all our properties over
				for(var i in event){
					if(!(i in nativeEvent)){
						nativeEvent[i] = event[i];
					}
				}
				return target.dispatchEvent(nativeEvent) && nativeEvent;
			}
			return syntheticDispatch.apply(on, arguments); // emit for a non-node
		};
	}else{
		// no addEventListener, basically old IE event normalization
		on._fixEvent = function(evt, sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt:
			//		native event object
			// sender:
			//		node to treat as "currentTarget"
			if(!evt){
				var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
				evt = w.event;
			}
			if(!evt){return evt;}
			try{
				if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
					// should be same event, reuse event object (so it can be augmented);
					// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
					evt = lastEvent;
				}
			}catch(e){
				// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
				// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
			}
			if(!evt.target){ // check to see if it has been fixed yet
				evt.target = evt.srcElement;
				evt.currentTarget = (sender || evt.srcElement);
				if(evt.type == "mouseover"){
					evt.relatedTarget = evt.fromElement;
				}
				if(evt.type == "mouseout"){
					evt.relatedTarget = evt.toElement;
				}
				if(!evt.stopPropagation){
					evt.stopPropagation = stopPropagation;
					evt.preventDefault = preventDefault;
				}
				switch(evt.type){
					case "keypress":
						var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
						if (c==10){
							// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
							c=0;
							evt.keyCode = 13;
						}else if(c==13||c==27){
							c=0; // Mozilla considers ENTER and ESC non-printable
						}else if(c==3){
							c=99; // Mozilla maps CTRL-BREAK to CTRL-c
						}
						// Mozilla sets keyCode to 0 when there is a charCode
						// but that stops the event on IE.
						evt.charCode = c;
						_setKeyChar(evt);
						break;
				}
			}
			return evt;
		};
		var lastEvent, IESignal = function(handle){
			this.handle = handle;
		};
		IESignal.prototype.remove = function(){
			delete _dojoIEListeners_[this.handle];
		};
		var fixListener = function(listener){
			// this is a minimal function for closing on the previous listener with as few as variables as possible
			return function(evt){
				evt = on._fixEvent(evt, this);
				var result = listener.call(this, evt);
				if(evt.modified){
					// cache the last event and reuse it if we can
					if(!lastEvent){
						setTimeout(function(){
							lastEvent = null;
						});
					}
					lastEvent = evt;
				}
				return result;
			};
		};
		var fixAttach = function(target, type, listener){
			listener = fixListener(listener);
			if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||
						has("jscript") < 5.8) &&
					!has("config-_allow_leaks")){
				// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
				// Here we use global redirection to solve the memory leaks
				if(typeof _dojoIEListeners_ == "undefined"){
					_dojoIEListeners_ = [];
				}
				var emitter = target[type];
				if(!emitter || !emitter.listeners){
					var oldListener = emitter;
					emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
					emitter.listeners = [];
					target[type] = emitter;
					emitter.global = this;
					if(oldListener){
						emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
					}
				}
				var handle;
				emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
				return new IESignal(handle);
			}
			return aspect.after(target, type, listener, true);
		};

		var _setKeyChar = function(evt){
			evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
			evt.charOrCode = evt.keyChar || evt.keyCode;	// TODO: remove for 2.0
		};
		// Called in Event scope
		var stopPropagation = function(){
			this.cancelBubble = true;
		};
		var preventDefault = on._preventDefault = function(){
			// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
			// ctrl-combinations that correspond to menu accelerator keys).
			// Otoh, it prevents upstream listeners from getting this information
			// Try to split the difference here by clobbering keyCode only for ctrl
			// combinations. If you still need to access the key upstream, bubbledKeyCode is
			// provided as a workaround.
			this.bubbledKeyCode = this.keyCode;
			if(this.ctrlKey){
				try{
					// squelch errors when keyCode is read-only
					// (e.g. if keyCode is ctrl or shift)
					this.keyCode = 0;
				}catch(e){
				}
			}
			this.defaultPrevented = true;
			this.returnValue = false;
			this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
		};
	}
	if(has("touch")){
		var EventDelegate = function(){};
		var windowOrientation = window.orientation;
		var fixTouchListener = function(listener){
			return function(originalEvent){
				//Event normalization(for ontouchxxx and resize):
				//1.incorrect e.pageX|pageY in iOS
				//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
				//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY

				// see if it has already been corrected
				var event = originalEvent.corrected;
				if(!event){
					var type = originalEvent.type;
					try{
						delete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable
					}catch(e){}
					if(originalEvent.type){
						// Deleting the property of the original event did not work (this is the case of
						// browsers such as older Safari iOS), hence fallback:
						if(has("touch-can-modify-event-delegate")){
							// If deleting properties of delegated event works, use event delegation:
							EventDelegate.prototype = originalEvent;
							event = new EventDelegate;
						}else{
							// Otherwise last fallback: other browsers, such as mobile Firefox, do not like
							// delegated properties, so we have to copy
							event = {};
							for(var name in originalEvent){
								event[name] = originalEvent[name];
							}
						}
						// have to delegate methods to make them work
						event.preventDefault = function(){
							originalEvent.preventDefault();
						};
						event.stopPropagation = function(){
							originalEvent.stopPropagation();
						};
					}else{
						// deletion worked, use property as is
						event = originalEvent;
						event.type = type;
					}
					originalEvent.corrected = event;
					if(type == 'resize'){
						if(windowOrientation == window.orientation){
							return null;//double tap causes an unexpected 'resize' in Android
						}
						windowOrientation = window.orientation;
						event.type = "orientationchange";
						return listener.call(this, event);
					}
					// We use the original event and augment, rather than doing an expensive mixin operation
					if(!("rotation" in event)){ // test to see if it has rotation
						event.rotation = 0;
						event.scale = 1;
					}
					if (window.TouchEvent && originalEvent instanceof TouchEvent) {
						// use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
						var firstChangeTouch = event.changedTouches[0];
						for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
							delete event[i]; // delete it first to make it mutable
							event[i] = firstChangeTouch[i];
						}
					}
				}
				return listener.call(this, event);
			};
		};
	}
	return on;
});

},
'dojo/_base/sniff':function(){
define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
	// module:
	//		dojo/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated.   New code should use dojo/sniff.
		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
	};
	=====*/

	if(! 1 ){
		return has;
	}

	// no idea what this is for, or if it's used
	dojo._name = "browser";

	lang.mixin(dojo, {
		// isBrowser: Boolean
		//		True if the client is a web-browser
		isBrowser: true,

		// isFF: Number|undefined
		//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
		//		major detected FireFox version (1.5, 2, 3, etc.)
		isFF: has("ff"),

		// isIE: Number|undefined
		//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
		//		major detected IE version (6, 7, 8, etc.)
		isIE: has("ie"),

		// isKhtml: Number|undefined
		//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
		//		detected version.
		isKhtml: has("khtml"),

		// isWebKit: Number|undefined
		//		Version as a Number if client is a WebKit-derived browser (Konqueror,
		//		Safari, Chrome, etc.). undefined otherwise.
		isWebKit: has("webkit"),

		// isMozilla: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMozilla: has("mozilla"),
		// isMoz: Number|undefined
		//		Version as a Number if client is a Mozilla-based browser (Firefox,
		//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
		isMoz: has("mozilla"),

		// isOpera: Number|undefined
		//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
		//		major detected version.
		isOpera: has("opera"),

		// isSafari: Number|undefined
		//		Version as a Number if client is Safari or iPhone. undefined otherwise.
		isSafari: has("safari"),

		// isChrome: Number|undefined
		//		Version as a Number if client is Chrome browser. undefined otherwise.
		isChrome: has("chrome"),

		// isMac: Boolean
		//		True if the client runs on Mac
		isMac: has("mac"),

		// isIos: Number|undefined
		//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
		isIos: has("ios"),

		// isAndroid: Number|undefined
		//		Version as a Number if client is android browser. undefined otherwise.
		isAndroid: has("android"),

		// isWii: Boolean
		//		True if client is Wii
		isWii: has("wii"),

		// isQuirks: Boolean
		//		Page is in quirks mode.
		isQuirks: has("quirks"),

		// isAir: Boolean
		//		True if client is Adobe Air
		isAir: has("air")
	});

	return has;
});

},
'dojo/errors/create':function(){
define(["../_base/lang"], function(lang){
	return function(name, ctor, base, props){
		base = base || Error;

		var ErrorCtor = function(message){
			if(base === Error){
				if(Error.captureStackTrace){
					Error.captureStackTrace(this, ErrorCtor);
				}

				// Error.call() operates on the returned error
				// object rather than operating on |this|
				var err = Error.call(this, message),
					prop;

				// Copy own properties from err to |this|
				for(prop in err){
					if(err.hasOwnProperty(prop)){
						this[prop] = err[prop];
					}
				}

				// messsage is non-enumerable in ES5
				this.message = message;
				// stack is non-enumerable in at least Firefox
				this.stack = err.stack;
			}else{
				base.apply(this, arguments);
			}
			if(ctor){
				ctor.apply(this, arguments);
			}
		};

		ErrorCtor.prototype = lang.delegate(base.prototype, props);
		ErrorCtor.prototype.name = name;
		ErrorCtor.prototype.constructor = ErrorCtor;

		return ErrorCtor;
	};
});

},
'dojo/_base/array':function(){
define(["./kernel", "../has", "./lang"], function(dojo, has, lang){
	// module:
	//		dojo/_base/array

	// our old simple function builder stuff
	var cache = {}, u;

	function buildFn(fn){
		return cache[fn] = new Function("item", "index", "array", fn); // Function
	}
	// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);

	// every & some

	function everyOrSome(some){
		var every = !some;
		return function(a, fn, o){
			var i = 0, l = a && a.length || 0, result;
			if(l && typeof a == "string") a = a.split("");
			if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
			if(o){
				for(; i < l; ++i){
					result = !fn.call(o, a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}else{
				for(; i < l; ++i){
					result = !fn(a[i], i, a);
					if(some ^ result){
						return !result;
					}
				}
			}
			return every; // Boolean
		};
	}

	// indexOf, lastIndexOf

	function index(up){
		var delta = 1, lOver = 0, uOver = 0;
		if(!up){
			delta = lOver = uOver = -1;
		}
		return function(a, x, from, last){
			if(last && delta > 0){
				// TODO: why do we use a non-standard signature? why do we need "last"?
				return array.lastIndexOf(a, x, from);
			}
			var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
			if(from === u){
				i = up ? lOver : l + uOver;
			}else{
				if(from < 0){
					i = l + from;
					if(i < 0){
						i = lOver;
					}
				}else{
					i = from >= l ? l + uOver : from;
				}
			}
			if(l && typeof a == "string") a = a.split("");
			for(; i != end; i += delta){
				if(a[i] == x){
					return i; // Number
				}
			}
			return -1; // Number
		};
	}

	var array = {
		// summary:
		//		The Javascript v1.6 array extensions.

		every: everyOrSome(false),
		/*=====
		 every: function(arr, callback, thisObject){
			 // summary:
			 //		Determines whether or not every item in arr satisfies the
			 //		condition implemented by callback.
			 // arr: Array|String
			 //		the array to iterate on. If a string, operates on individual characters.
			 // callback: Function|String
			 //		a function is invoked with three arguments: item, index,
			 //		and array and returns true if the condition is met.
			 // thisObject: Object?
			 //		may be used to scope the call to callback
			 // returns: Boolean
			 // description:
			 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
			 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
			 //		For more details, see:
			 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
			 // example:
			 //	|	// returns false
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
			 // example:
			 //	|	// returns true
			 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
		 },
		 =====*/

		some: everyOrSome(true),
		/*=====
		some: function(arr, callback, thisObject){
			// summary:
			//		Determines whether or not any item in arr satisfies the
			//		condition implemented by callback.
			// arr: Array|String
			//		the array to iterate over. If a string, operates on individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments: item, index,
			//		and array and returns true if the condition is met.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Boolean
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
			// example:
			//	| // is true
			//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
			// example:
			//	| // is false
			//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
		},
		=====*/

		indexOf: index(true),
		/*=====
		indexOf: function(arr, value, fromIndex, findLast){
			// summary:
			//		locates the first index of the provided value in the
			//		passed array. If the value is not found, -1 is returned.
			// description:
			//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
			//
			//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
			//		2. uses equality (==) rather than strict equality (===)
			//
			//		For details on this method, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
			// arr: Array
			// value: Object
			// fromIndex: Integer?
			// findLast: Boolean?
			//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
			// returns: Number
		},
		=====*/

		lastIndexOf: index(false),
		/*=====
		lastIndexOf: function(arr, value, fromIndex){
			// summary:
			//		locates the last index of the provided value in the passed
			//		array. If the value is not found, -1 is returned.
			// description:
		 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
		 	//
		 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
		 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
		 	//		2. uses equality (==) rather than strict equality (===)
		 	//
		 	//		For details on this method, see:
		 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
			// arr: Array,
			// value: Object,
			// fromIndex: Integer?
			// returns: Number
		},
		=====*/

		forEach: function(arr, callback, thisObject){
			// summary:
			//		for every item in arr, callback is invoked. Return values are ignored.
			//		If you want to break out of the loop, consider using array.every() or array.some().
			//		forEach does not allow breaking out of the loop over the items in arr.
			// arr:
			//		the array to iterate over. If a string, operates on individual characters.
			// callback:
			//		a function is invoked with three arguments: item, index, and array
			// thisObject:
			//		may be used to scope the call to callback
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
			// example:
			//	| // log out all members of the array:
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item){
			//	|			console.log(item);
			//	|		}
			//	| );
			// example:
			//	| // log out the members and their indexes
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		function(item, idx, arr){
			//	|			console.log(item, "at index:", idx);
			//	|		}
			//	| );
			// example:
			//	| // use a scoped object member as the callback
			//	|
			//	| var obj = {
			//	|		prefix: "logged via obj.callback:",
			//	|		callback: function(item){
			//	|			console.log(this.prefix, item);
			//	|		}
			//	| };
			//	|
			//	| // specifying the scope function executes the callback in that scope
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		obj.callback,
			//	|		obj
			//	| );
			//	|
			//	| // alternately, we can accomplish the same thing with lang.hitch()
			//	| array.forEach(
			//	|		[ "thinger", "blah", "howdy", 10 ],
			//	|		lang.hitch(obj, "callback")
			//	| );
			// arr: Array|String
			// callback: Function|String
			// thisObject: Object?

			var i = 0, l = arr && arr.length || 0;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					callback(arr[i], i, arr);
				}
			}
		},

		map: function(arr, callback, thisObject, Ctr){
			// summary:
			//		applies callback to each element of arr and returns
			//		an Array with the results
			// arr: Array|String
			//		the array to iterate on. If a string, operates on
			//		individual characters.
			// callback: Function|String
			//		a function is invoked with three arguments, (item, index,
			//		array),	 and returns a value
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
			// example:
			//	| // returns [2, 3, 4, 5]
			//	| array.map([1, 2, 3, 4], function(item){ return item+1 });

			// TODO: why do we have a non-standard signature here? do we need "Ctr"?
			var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					out[i] = callback.call(thisObject, arr[i], i, arr);
				}
			}else{
				for(; i < l; ++i){
					out[i] = callback(arr[i], i, arr);
				}
			}
			return out; // Array
		},

		filter: function(arr, callback, thisObject){
			// summary:
			//		Returns a new Array with those items from arr that match the
			//		condition implemented by callback.
			// arr: Array
			//		the array to iterate over.
			// callback: Function|String
			//		a function that is invoked with three arguments (item,
			//		index, array). The return of this function is expected to
			//		be a boolean which determines whether the passed-in item
			//		will be included in the returned array.
			// thisObject: Object?
			//		may be used to scope the call to callback
			// returns: Array
			// description:
			//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
			//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
			//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
			//		For more details, see:
			//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
			// example:
			//	| // returns [2, 3, 4]
			//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });

			// TODO: do we need "Ctr" here like in map()?
			var i = 0, l = arr && arr.length || 0, out = [], value;
			if(l && typeof arr == "string") arr = arr.split("");
			if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
			if(thisObject){
				for(; i < l; ++i){
					value = arr[i];
					if(callback.call(thisObject, value, i, arr)){
						out.push(value);
					}
				}
			}else{
				for(; i < l; ++i){
					value = arr[i];
					if(callback(value, i, arr)){
						out.push(value);
					}
				}
			}
			return out; // Array
		},

		clearCache: function(){
			cache = {};
		}
	};


	 1  && lang.mixin(dojo, array);

	return array;
});

},
'dojo/_base/json':function(){
define(["./kernel", "../json"], function(dojo, json){

// module:
//		dojo/_base/json

/*=====
return {
	// summary:
	//		This module defines the dojo JSON API.
};
=====*/

dojo.fromJson = function(/*String*/ js){
	// summary:
	//		Parses a JavaScript expression and returns a JavaScript value.
	// description:
	//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
	//		always delegates to eval(). The content passed to this method must therefore come
	//		from a trusted source.
	//		It is recommend that you use dojo/json's parse function for an
	//		implementation uses the (faster) native JSON parse when available.
	// js:
	//		a string literal of a JavaScript expression, for instance:
	//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`

	return eval("(" + js + ")"); // Object
};

/*=====
dojo._escapeString = function(){
	// summary:
	//		Adds escape sequences for non-visual characters, double quote and
	//		backslash and surrounds with double quotes to form a valid string
	//		literal.
};
=====*/
dojo._escapeString = json.stringify; // just delegate to json.stringify

dojo.toJsonIndentStr = "\t";
dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
	// summary:
	//		Returns a [JSON](http://json.org) serialization of an object.
	// description:
	//		Returns a [JSON](http://json.org) serialization of an object.
	//		Note that this doesn't check for infinite recursion, so don't do that!
	//		It is recommend that you use dojo/json's stringify function for an lighter
	//		and faster implementation that matches the native JSON API and uses the
	//		native JSON serializer when available.
	// it:
	//		an object to be serialized. Objects may define their own
	//		serialization via a special "__json__" or "json" function
	//		property. If a specialized serializer has been defined, it will
	//		be used as a fallback.
	//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
	//		since it is not supported by native JSON serializer.
	// prettyPrint:
	//		if true, we indent objects and arrays to make the output prettier.
	//		The variable `dojo.toJsonIndentStr` is used as the indent string --
	//		to use something other than the default (tab), change that variable
	//		before calling dojo.toJson().
	//		Note that if native JSON support is available, it will be used for serialization,
	//		and native implementations vary on the exact spacing used in pretty printing.
	// returns:
	//		A JSON string serialization of the passed-in object.
	// example:
	//		simple serialization of a trivial object
	//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
	//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
	// example:
	//		a custom serializer for an objects of a particular class:
	//		|	dojo.declare("Furby", null, {
	//		|		furbies: "are strange",
	//		|		furbyCount: 10,
	//		|		__json__: function(){
	//		|		},
	//		|	});

	// use dojo/json
	return json.stringify(it, function(key, value){
		if(value){
			var tf = value.__json__||value.json;
			if(typeof tf == "function"){
				return tf.call(value);
			}
		}
		return value;
	}, prettyPrint && dojo.toJsonIndentStr);	// String
};

return dojo;
});

},
'dojo/_base/window':function(){
define(["./kernel", "./lang", "../sniff"], function(dojo, lang, has){
// module:
//		dojo/_base/window

var ret = {
	// summary:
	//		API to save/set/restore the global/document scope.

	global: dojo.global,
	/*=====
	 global: {
		 // summary:
		 //		Alias for the current window. 'global' can be modified
		 //		for temporary context shifting. See also withGlobal().
		 // description:
		 //		Use this rather than referring to 'window' to ensure your code runs
		 //		correctly in managed contexts.
	 },
	 =====*/

	doc: dojo.global["document"] || null,
	/*=====
	doc: {
		// summary:
		//		Alias for the current document. 'doc' can be modified
		//		for temporary context shifting. See also withDoc().
		// description:
		//		Use this rather than referring to 'window.document' to ensure your code runs
		//		correctly in managed contexts.
		// example:
		//	|	n.appendChild(dojo.doc.createElement('div'));
	},
	=====*/

	body: function(/*Document?*/ doc){
		// summary:
		//		Return the body element of the specified document or of dojo/_base/window::doc.
		// example:
		//	|	win.body().appendChild(dojo.doc.createElement('div'));

		// Note: document.body is not defined for a strict xhtml document
		// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
		doc = doc || dojo.doc;
		return doc.body || doc.getElementsByTagName("body")[0]; // Node
	},

	setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
		//		are modified as a result of calling this function and the result of
		//		`dojo.body()` likewise differs.
		dojo.global = ret.global = globalObject;
		dojo.doc = ret.doc = globalDocument;
	},

	withGlobal: function(	/*Object*/ globalObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc.
		// description:
		//		Invoke callback with globalObject as dojo.global and
		//		globalObject.document as dojo.doc. If provided, globalObject
		//		will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo.global
		//		and dojo.doc will be restored to its previous state.

		var oldGlob = dojo.global;
		try{
			dojo.global = ret.global = globalObject;
			return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
		}finally{
			dojo.global = ret.global = oldGlob;
		}
	},

	withDoc: function(	/*DocumentElement*/ documentObject,
						/*Function*/ callback,
						/*Object?*/ thisObject,
						/*Array?*/ cbArguments){
		// summary:
		//		Invoke callback with documentObject as dojo/_base/window::doc.
		// description:
		//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
		//		callback will be executed in the context of object thisObject
		//		When callback() returns or throws an error, the dojo/_base/window::doc will
		//		be restored to its previous state.

		var oldDoc = ret.doc,
			oldQ = has("quirks"),
			oldIE = has("ie"), isIE, mode, pwin;

		try{
			dojo.doc = ret.doc = documentObject;
			// update dojo.isQuirks and the value of the has feature "quirks".
			// remove setting dojo.isQuirks and dojo.isIE for 2.0
			dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only

			if(has("ie")){
				if((pwin = documentObject.parentWindow) && pwin.navigator){
					// re-run IE detection logic and update dojo.isIE / has("ie")
					// (the only time parentWindow/navigator wouldn't exist is if we were not
					// passed an actual legitimate document object)
					isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
					mode = documentObject.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
					dojo.isIE = has.add("ie", isIE, true, true);
				}
			}

			if(thisObject && typeof callback == "string"){
				callback = thisObject[callback];
			}

			return callback.apply(thisObject, cbArguments || []);
		}finally{
			dojo.doc = ret.doc = oldDoc;
			dojo.isQuirks = has.add("quirks", oldQ, true, true);
			dojo.isIE = has.add("ie", oldIE, true, true);
		}
	}
};

 1  && lang.mixin(dojo, ret);

return ret;

});

},
'dojo/dom-class':function(){
define(["./_base/lang", "./_base/array", "./dom"], function(lang, array, dom){
	// module:
	//		dojo/dom-class

	var className = "className";

	/* Part I of classList-based implementation is preserved here for posterity
	var classList = "classList";
	has.add("dom-classList", function(){
		return classList in document.createElement("p");
	});
	*/

	// =============================
	// (CSS) Class Functions
	// =============================

	var cls, // exports object
		spaces = /\s+/, a1 = [""];

	function str2array(s){
		if(typeof s == "string" || s instanceof String){
			if(s && !spaces.test(s)){
				a1[0] = s;
				return a1;
			}
			var a = s.split(spaces);
			if(a.length && !a[0]){
				a.shift();
			}
			if(a.length && !a[a.length - 1]){
				a.pop();
			}
			return a;
		}
		// assumed to be an array
		if(!s){
			return [];
		}
		return array.filter(s, function(x){ return x; });
	}

	/* Part II of classList-based implementation is preserved here for posterity
	if(has("dom-classList")){
		// new classList version
		cls = {
			contains: function containsClass(node, classStr){
				var clslst = classStr && dom.byId(node)[classList];
				return clslst && clslst.contains(classStr); // Boolean
			},

			add: function addClass(node, classStr){
				node = dom.byId(node);
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length; i < len; ++i){
					node[classList].add(classStr[i]);
				}
			},

			remove: function removeClass(node, classStr){
				node = dom.byId(node);
				if(classStr === undefined){
					node[className] = "";
				}else{
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].remove(classStr[i]);
					}
				}
			},

			replace: function replaceClass(node, addClassStr, removeClassStr){
				node = dom.byId(node);
				if(removeClassStr === undefined){
					node[className] = "";
				}else{
					removeClassStr = str2array(removeClassStr);
					for(var i = 0, len = removeClassStr.length; i < len; ++i){
						node[classList].remove(removeClassStr[i]);
					}
				}
				addClassStr = str2array(addClassStr);
				for(i = 0, len = addClassStr.length; i < len; ++i){
					node[classList].add(addClassStr[i]);
				}
			},

			toggle: function toggleClass(node, classStr, condition){
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].toggle(classStr[i]);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		}
	}
	*/

	// regular DOM version
	var fakeNode = {};  // for effective replacement
	cls = {
		// summary:
		//		This module defines the core dojo DOM class API.

		contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
			// summary:
			//		Returns whether or not the specified classes are a portion of the
			//		class list currently applied to the node.
			// node: String|DOMNode
			//		String ID or DomNode reference to check the class for.
			// classStr: String
			//		A string class name to look for.
			// example:
			//		Do something if a node with id="someNode" has class="aSillyClassName" present
			//	|	if(domClass.contains("someNode","aSillyClassName")){ ... }

			return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
		},

		add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
			// summary:
			//		Adds the specified classes to the end of the class list on the
			//		passed node. Will not re-apply duplicate classes.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to add a class string too
			//
			// classStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//		Add a class to some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "anewClass");
			//	|	});
			//
			// example:
			//		Add two classes at once:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Add two classes at once (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple additions
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").addClass("firstLevel");
			//	|	});

			node = dom.byId(node);
			classStr = str2array(classStr);
			var cls = node[className], oldLen;
			cls = cls ? " " + cls + " " : " ";
			oldLen = cls.length;
			for(var i = 0, len = classStr.length, c; i < len; ++i){
				c = classStr[i];
				if(c && cls.indexOf(" " + c + " ") < 0){
					cls += c + " ";
				}
			}
			if(oldLen < cls.length){
				node[className] = cls.substr(1, cls.length - 2);
			}
		},

		remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
			// summary:
			//		Removes the specified classes from node. No `contains()`
			//		check is required.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// classStr: String|Array
			//		An optional String class name to remove, or several space-separated
			//		class names, or an array of class names. If omitted, all class names
			//		will be deleted.
			//
			// example:
			//		Remove a class from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", "firstClass secondClass");
			//	|	});
			//
			// example:
			//		Remove two classes from some node (using array):
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
			//	|	});
			//
			// example:
			//		Remove all classes from some node:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.remove("someNode");
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple removal
			//	|	require(["dojo/query"], function(query){
			//	|		query("ul > li").removeClass("foo");
			//	|	});

			node = dom.byId(node);
			var cls;
			if(classStr !== undefined){
				classStr = str2array(classStr);
				cls = " " + node[className] + " ";
				for(var i = 0, len = classStr.length; i < len; ++i){
					cls = cls.replace(" " + classStr[i] + " ", " ");
				}
				cls = lang.trim(cls);
			}else{
				cls = "";
			}
			if(node[className] != cls){ node[className] = cls; }
		},

		replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
			// summary:
			//		Replaces one or more classes on a node if not present.
			//		Operates more quickly than calling domClass.remove and domClass.add
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to remove the class from.
			//
			// addClassStr: String|Array
			//		A String class name to add, or several space-separated class names,
			//		or an array of class names.
			//
			// removeClassStr: String|Array?
			//		A String class name to remove, or several space-separated class names,
			//		or an array of class names.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
			//	|	});
			//
			// example:
			//	Replace all classes with addMe
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.replace("someNode", "addMe");
			//	|	});
			//
			// example:
			//	Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".findMe").replaceClass("addMe", "removeMe");
			//	|	});

			node = dom.byId(node);
			fakeNode[className] = node[className];
			cls.remove(fakeNode, removeClassStr);
			cls.add(fakeNode, addClassStr);
			if(node[className] !== fakeNode[className]){
				node[className] = fakeNode[className];
			}
		},

		toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
			// summary:
			//		Adds a class to node if not present, or removes if present.
			//		Pass a boolean condition if you want to explicitly add or remove.
			//		Returns the condition that was specified directly or indirectly.
			//
			// node: String|DOMNode
			//		String ID or DomNode reference to toggle a class string
			//
			// classStr: String|Array
			//		A String class name to toggle, or several space-separated class names,
			//		or an array of class names.
			//
			// condition:
			//		If passed, true means to add the class, false means to remove.
			//		Otherwise domClass.contains(node, classStr) is used to detect the class presence.
			//
			// example:
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered");
			//	|	});
			//
			// example:
			//		Forcefully add a class
			//	|	require(["dojo/dom-class"], function(domClass){
			//	|		domClass.toggle("someNode", "hovered", true);
			//	|	});
			//
			// example:
			//		Available in `dojo/NodeList` for multiple toggles
			//	|	require(["dojo/query"], function(query){
			//	|		query(".toggleMe").toggleClass("toggleMe");
			//	|	});

			node = dom.byId(node);
			if(condition === undefined){
				classStr = str2array(classStr);
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					cls[cls.contains(node, c) ? "remove" : "add"](node, c);
				}
			}else{
				cls[condition ? "add" : "remove"](node, classStr);
			}
			return condition;   // Boolean
		}
	};

	return cls;
});

},
'dojo/_base/config':function(){
define(["../global", "../has", "require"], function(global, has, require){
	// module:
	//		dojo/_base/config

/*=====
return {
	// summary:
	//		This module defines the user configuration during bootstrap.
	// description:
	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
	//		as a module allows for specifying unique, per-instance configurations.
	// example:
	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
	//		dojo.js are already loaded).
	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
	//		|	require({
	//		|		packages:[{
	//		|			name:"myDojo",
	//		|			location:".", //assume baseUrl points to dojo.js
	//		|		}]
	//		|	});
	//		|
	//		|	// specify a configuration for the myDojo instance
	//		|	define("myDojo/config", {
	//		|		// normal configuration variables go here, e.g.,
	//		|		locale:"fr-ca"
	//		|	});
	//		|
	//		|	// load and use the new instance of dojo
	//		|	require(["myDojo"], function(dojo){
	//		|		// dojo is the new instance of dojo
	//		|		// use as required
	//		|	});

	// isDebug: Boolean
	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
	//		extended debugging feedback to the console.
	isDebug: false,

	// locale: String
	//		The locale to assume for loading localized resources in this page,
	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
	//		for details on loading localized resources. If no locale is specified,
	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
	//		or `navigator.language` properties.
	locale: undefined,

	// extraLocale: Array
	//		No default value. Specifies additional locales whose
	//		resources should also be loaded alongside the default locale when
	//		calls to `dojo.requireLocalization()` are processed.
	extraLocale: undefined,

	// baseUrl: String
	//		The directory in which `dojo.js` is located. Under normal
	//		conditions, Dojo auto-detects the correct location from which it
	//		was loaded. You may need to manually configure `baseUrl` in cases
	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
	//		either the value of `djConfig.baseUrl` if one is provided or the
	//		auto-detected root if not. Other modules are located relative to
	//		this path. The path should end in a slash.
	baseUrl: undefined,

	// modulePaths: [deprecated] Object
	//		A map of module names to paths relative to `dojo.baseUrl`. The
	//		key/value pairs correspond directly to the arguments which
	//		`dojo.registerModulePath` accepts. Specifying
	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
	//		modules may be configured via `djConfig.modulePaths`.
	modulePaths: {},

	// addOnLoad: Function|Array
	//		Adds a callback via dojo/ready. Useful when Dojo is added after
	//		the page loads and djConfig.afterOnLoad is true. Supports the same
	//		arguments as dojo/ready. When using a function reference, use
	//		`djConfig.addOnLoad = function(){};`. For object with function name use
	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
	//		function reference use
	//		`djConfig.addOnLoad = [myObject, function(){}];`
	addOnLoad: null,

	// parseOnLoad: Boolean
	//		Run the parser after the page is loaded
	parseOnLoad: false,

	// require: String[]
	//		An array of module names to be loaded immediately after dojo.js has been included
	//		in a page.
	require: [],

	// defaultDuration: Number
	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
	//		Assigned to dijit.defaultDuration.
	defaultDuration: 200,

	// dojoBlankHtmlUrl: String
	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
	//		controls do not bleed through the popups. Normally this configuration variable
	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
	//		to the path on your domain your copy of blank.html.
	dojoBlankHtmlUrl: undefined,

	// ioPublish: Boolean?
	//		Set this to true to enable publishing of topics for the different phases of
	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
	//		of topics that are published.
	ioPublish: false,

	// transparentColor: Array
	//		Array containing the r, g, b components used as transparent color in dojo.Color;
	//		if undefined, [255,255,255] (white) will be used.
	transparentColor: undefined,
	
	// deps: Function|Array
	//		Defines dependencies to be used before the loader has been loaded.
	//		When provided, they cause the loader to execute require(deps, callback) 
	//		once it has finished loading. Should be used with callback.
	deps: undefined,
	
	// callback: Function|Array
	//		Defines a callback to be used when dependencies are defined before 
	//		the loader has been loaded. When provided, they cause the loader to 
	//		execute require(deps, callback) once it has finished loading. 
	//		Should be used with deps.
	callback: undefined,
	
	// deferredInstrumentation: Boolean
	//		Whether deferred instrumentation should be loaded or included
	//		in builds.
	deferredInstrumentation: true,

	// useDeferredInstrumentation: Boolean|String
	//		Whether the deferred instrumentation should be used.
	//
	//		* `"report-rejections"`: report each rejection as it occurs.
	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
	//			in an attempt to detect unhandled rejections.
	useDeferredInstrumentation: "report-unhandled-rejections"
};
=====*/

	var result = {};
	if( 1 ){
		// must be the dojo loader; take a shallow copy of require.rawConfig
		var src = require.rawConfig, p;
		for(p in src){
			result[p] = src[p];
		}
	}else{
		var adviseHas = function(featureSet, prefix, booting){
			for(p in featureSet){
				p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
			}
		};
		result =  1  ?
			// must be a built version of the dojo loader; all config stuffed in require.rawConfig
			require.rawConfig :
			// a foreign loader
			global.dojoConfig || global.djConfig || {};
		adviseHas(result, "config", 1);
		adviseHas(result.has, "", 1);
	}

	if(!result.locale && typeof navigator != "undefined"){
		// Default locale for browsers (ensure it's read from user-settings not download locale).
		var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
			(navigator.language || navigator.userLanguage);
		if(language){
			result.locale = language.toLowerCase();
		}
	}

	return result;
});


},
'dojo/_base/event':function(){
define(["./kernel", "../on", "../has", "../dom-geometry"], function(dojo, on, has, dom){
	// module:
	//		dojo/_base/event

	if(on._fixEvent){
		var fixEvent = on._fixEvent;
		on._fixEvent = function(evt, se){
			// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
			evt = fixEvent(evt, se);
			if(evt){
				dom.normalizeEvent(evt);
			}
			return evt;
		};		
	}
	
	var ret = {
		// summary:
		//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
		//		evt.preventDefault(), rather than this module.

		fix: function(/*Event*/ evt, /*DOMNode*/ sender){
			// summary:
			//		normalizes properties on the event object including event
			//		bubbling methods, keystroke normalization, and x/y positions
			// evt: Event
			//		native event object
			// sender: DOMNode
			//		node to treat as "currentTarget"
			if(on._fixEvent){
				return on._fixEvent(evt, sender);
			}
			return evt;	// Event
		},
	
		stop: function(/*Event*/ evt){
			// summary:
			//		prevents propagation and clobbers the default action of the
			//		passed event
			// evt: Event
			//		The event object. If omitted, window.event is used on IE.
			if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
				evt.preventDefault();
				evt.stopPropagation();
			}else{
				evt = evt || window.event;
				evt.cancelBubble = true;
				on._preventDefault.call(evt);
			}
		}
	};

	if( 1 ){
		dojo.fixEvent = ret.fix;
		dojo.stopEvent = ret.stop;
	}

	return ret;
});

},
'dojo/main':function(){
define([
	"./_base/kernel",	// kernel.isAsync
	"./has",
	"require",
	"./sniff",
	"./_base/lang",
	"./_base/array",
	"./_base/config",
	"./ready",
	"./_base/declare",
	"./_base/connect",
	"./_base/Deferred",
	"./_base/json",
	"./_base/Color",
	"./has!dojo-firebug?./_firebug/firebug",
	"./_base/browser",
	"require"
], function(kernel, has, require, sniff, lang, array, config, ready){
	// module:
	//		dojo/main
	// summary:
	//		This is the package main module for the dojo package; it loads dojo base appropriate for the execution environment.

	// Load code to fix IE's console
	if(config.isDebug){
		require(["./_firebug/firebug"]);
	}

	// dojoConfig.require is deprecated; use the loader configuration property deps
	 1 || has.add("dojo-config-require", 1);
	if( 1 ){
		var deps= config.require;
		if(deps){
			// config.require may be dot notation
			deps= array.map(lang.isArray(deps) ? deps : [deps], function(item){ return item.replace(/\./g, "/"); });
			if(kernel.isAsync){
				require(deps);
			}else{
				// this is a bit janky; in 1.6- dojo is defined before these requires are applied; but in 1.7+
				// dojo isn't defined until returning from this module; this is only a problem in sync mode
				// since we're in sync mode, we know we've got our loader with its priority ready queue
				ready(1, function(){require(deps);});
			}
		}
	}

	return kernel;
});

},
'dojo/sniff':function(){
define(["./has"], function(has){
	// module:
	//		dojo/sniff

	/*=====
	return function(){
		// summary:
		//		This module sets has() flags based on the current browser.
		//		It returns the has() function.
	};
	=====*/

	if( 1 ){
		var n = navigator,
			dua = n.userAgent,
			dav = n.appVersion,
			tv = parseFloat(dav);
		has.add("air", dua.indexOf("AdobeAIR") >= 0);
		has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
		has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
		has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
		has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
		has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
		// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
		has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
			&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
		has.add("chrome", !has("edge") && !has("opr")
				&& parseFloat(dua.split("Chrome/")[1]) || undefined);
		has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& parseFloat(dua.split("Android ")[1]) || undefined);
		has.add("safari", dav.indexOf("Safari") >= 0
				&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
				&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
			parseFloat(dav.split("Version/")[1]) : undefined);
		has.add("mac", dav.indexOf("Macintosh") >= 0);
		has.add("quirks", document.compatMode == "BackCompat");
		if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
				&& dua.match(/(iPhone|iPod|iPad)/)){
			var p = RegExp.$1.replace(/P/, "p");
			var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
			var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
			has.add(p, os);		// "iphone", "ipad" or "ipod"
			has.add("ios", os);
		}
		has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
		has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);

		has.add("svg", typeof SVGAngle !== "undefined");

		if(!has("webkit")){
			// Opera
			if(dua.indexOf("Opera") >= 0){
				// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
				// 9.8 has both styles; <9.8, 9.9 only old style
				has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
			}

			// Mozilla and firefox
			if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
					&& !has("khtml") && !has("trident") && !has("edge")){
				has.add("mozilla", tv);
			}
			if(has("mozilla")){
				//We really need to get away from this. Consider a sane isGecko approach for the future.
				has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
			}

			// IE
			if(document.all && !has("opera")){
				var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;

				//In cases where the page has an HTTP header or META tag with
				//X-UA-Compatible, then it is in emulation mode.
				//Make sure isIE reflects the desired version.
				//document.documentMode of 5 means quirks mode.
				//Only switch the value if documentMode's major version
				//is different from isIE's major version.
				var mode = document.documentMode;
				if(mode && mode != 5 && Math.floor(isIE) != mode){
					isIE = mode;
				}

				has.add("ie", isIE);
			}

			// Wii
			has.add("wii", typeof opera != "undefined" && opera.wiiremote);
		}
	}

	return has;
});

},
'dojo/request/handlers':function(){
define([
	'../json',
	'../_base/kernel',
	'../_base/array',
	'../has',
	'../selector/_loader' // only included for has() qsa tests
], function(JSON, kernel, array, has){
	has.add('activex', typeof ActiveXObject !== 'undefined');
	has.add('dom-parser', function(global){
		return 'DOMParser' in global;
	});

	var handleXML;
	if(has('activex')){
		// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
		var dp = [
			'Msxml2.DOMDocument.6.0',
			'Msxml2.DOMDocument.4.0',
			'MSXML2.DOMDocument.3.0',
			'MSXML.DOMDocument' // 2.0
		];
		var lastParser;

		handleXML = function(response){
			var result = response.data;
			var text = response.text;

			if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
				// http://bugs.dojotoolkit.org/ticket/15631
				// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
				// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
				// the fuller-featured implementation and avoid bugs caused by the inconsistency
				result = new DOMParser().parseFromString(text, 'application/xml');
			}

			function createDocument(p) {
					try{
						var dom = new ActiveXObject(p);
						dom.async = false;
						dom.loadXML(text);
						result = dom;
						lastParser = p;
					}catch(e){ return false; }
					return true;
			}

			if(!result || !result.documentElement){
				// The creation of an ActiveX object is expensive, so we cache the
				// parser type to avoid trying all parser types each time we handle a
				// document. There is some concern that some parser types might fail
				// depending on the document being parsed. If parsing using the cached
				// parser type fails, we do the more expensive operation of finding one
				// that works for the given document.
				// https://bugs.dojotoolkit.org/ticket/15246
				if(!lastParser || !createDocument(lastParser)) {
					array.some(dp, createDocument);
				}
			}

			return result;
		};
	}

	var handleNativeResponse = function(response) {
		if(!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined'){
			return new Blob([ response.xhr.response ], { type: response.xhr.getResponseHeader('Content-Type') });
		}

		return response.xhr.response;
	}

	var handlers = {
		'javascript': function(response){
			return kernel.eval(response.text || '');
		},
		'json': function(response){
			return JSON.parse(response.text || null);
		},
		'xml': handleXML,
		'blob': handleNativeResponse,
		'arraybuffer': handleNativeResponse,
		'document': handleNativeResponse
	};

	function handle(response){
		var handler = handlers[response.options.handleAs];

		response.data = handler ? handler(response) : (response.data || response.text);

		return response;
	}

	handle.register = function(name, handler){
		handlers[name] = handler;
	};

	return handle;
});

},
'dojo/ready':function(){
define(["./_base/kernel", "./has", "require", "./domReady", "./_base/lang"], function(dojo, has, require, domReady, lang){
	// module:
	//		dojo/ready
	// note:
	//		This module should be unnecessary in dojo 2.0

	var
		// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved
		isDomReady = 0,

		// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied
		loadQ = [],

		// prevent recursion in onLoad
		onLoadRecursiveGuard = 0,

		handleDomReady = function(){
			isDomReady = 1;
			dojo._postLoad = dojo.config.afterOnLoad = true;
			onEvent();
		},

		onEvent = function(){
			// Called when some state changes:
			//		- dom ready
			//		- dojo/domReady has finished processing everything in its queue
			//		- task added to loadQ
			//		- require() has finished loading all currently requested modules
			//
			// Run the functions queued with dojo.ready if appropriate.


			//guard against recursions into this function
			if(onLoadRecursiveGuard){
				return;
			}
			onLoadRecursiveGuard = 1;

			// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no
			// pending tasks registered via domReady().
			// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the
			// domReady() calls inside of dojo.	  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8
			// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.
			while(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){
				var f = loadQ.shift();
				try{
					f();
				}catch(e){
					// force the dojo.js on("error") handler do display the message
					e.info = e.message;
					if(require.signal){
						require.signal("error", e);
					}else{
						throw e;
					}
				}
			}

			onLoadRecursiveGuard = 0;
		};

	// Check if we should run the next queue operation whenever require() finishes loading modules or domReady
	// finishes processing it's queue.
	require.on && require.on("idle", onEvent);
	if(domReady){
		domReady._onQEmpty = onEvent;
	}

	var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){
		// summary:
		//		Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
		//		In most cases, the `domReady` plug-in should suffice and this method should not be needed.
		//
		//		When called in a non-browser environment, just checks that all requested modules have arrived and been
		//		evaluated.
		// priority: Integer?
		//		The order in which to exec this callback relative to other callbacks, defaults to 1000
		// context: Object?|Function
		//		The context in which to run execute callback, or a callback if not using context
		// callback: Function?
		//		The function to execute.
		//
		// example:
		//	Simple DOM and Modules ready syntax
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(function(){ alert("Dom ready!"); });
		//	|	});
		//
		// example:
		//	Using a priority
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(2, function(){ alert("low priority ready!"); })
		//	|	});
		//
		// example:
		//	Using context
		//	|	require(["dojo/ready"], function(ready){
		//	|		ready(foo, function(){
		//	|			// in here, this == foo
		//	|		});
		//	|	});
		//
		// example:
		//	Using dojo/hitch style args:
		//	|	require(["dojo/ready"], function(ready){
		//	|		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
		//	|		ready(foo, "dojoReady");
		//	|	});

		var hitchArgs = lang._toArray(arguments);
		if(typeof priority != "number"){
			callback = context;
			context = priority;
			priority = 1000;
		}else{
			hitchArgs.shift();
		}
		callback = callback ?
			lang.hitch.apply(dojo, hitchArgs) :
			function(){
				context();
			};
		callback.priority = priority;
		for(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}
		loadQ.splice(i, 0, callback);
		onEvent();
	};

	 1 || has.add("dojo-config-addOnLoad", 1);
	if( 1 ){
		var dca = dojo.config.addOnLoad;
		if(dca){
			ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
		}
	}

	if( false  && dojo.config.parseOnLoad && !dojo.isAsync){
		ready(99, function(){
			if(!dojo.parser){
				dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
				require(["dojo/parser"]);
			}
		});
	}

	if(domReady){
		domReady(handleDomReady);
	}else{
		handleDomReady();
	}

	return ready;
});

},
'dojo/aspect':function(){
define([], function(){

	// module:
	//		dojo/aspect

	"use strict";
	var undefined;
	function advise(dispatcher, type, advice, receiveArguments){
		var previous = dispatcher[type];
		var around = type == "around";
		var signal;
		if(around){
			var advised = advice(function(){
				return previous.advice(this, arguments);
			});
			signal = {
				remove: function(){
					if(advised){
						advised = dispatcher = advice = null;
					}
				},
				advice: function(target, args){
					return advised ?
						advised.apply(target, args) :  // called the advised function
						previous.advice(target, args); // cancelled, skip to next one
				}
			};
		}else{
			// create the remove handler
			signal = {
				remove: function(){
					if(signal.advice){
						var previous = signal.previous;
						var next = signal.next;
						if(!next && !previous){
							delete dispatcher[type];
						}else{
							if(previous){
								previous.next = next;
							}else{
								dispatcher[type] = next;
							}
							if(next){
								next.previous = previous;
							}
						}

						// remove the advice to signal that this signal has been removed
						dispatcher = advice = signal.advice = null;
					}
				},
				id: dispatcher.nextId++,
				advice: advice,
				receiveArguments: receiveArguments
			};
		}
		if(previous && !around){
			if(type == "after"){
				// add the listener to the end of the list
				// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
				while(previous.next && (previous = previous.next)){}
				previous.next = signal;
				signal.previous = previous;
			}else if(type == "before"){
				// add to beginning
				dispatcher[type] = signal;
				signal.next = previous;
				previous.previous = signal;
			}
		}else{
			// around or first one just replaces
			dispatcher[type] = signal;
		}
		return signal;
	}
	function aspect(type){
		return function(target, methodName, advice, receiveArguments){
			var existing = target[methodName], dispatcher;
			if(!existing || existing.target != target){
				// no dispatcher in place
				target[methodName] = dispatcher = function(){
					var executionId = dispatcher.nextId;
					// before advice
					var args = arguments;
					var before = dispatcher.before;
					while(before){
						if(before.advice){
							args = before.advice.apply(this, args) || args;
						}
						before = before.next;
					}
					// around advice
					if(dispatcher.around){
						var results = dispatcher.around.advice(this, args);
					}
					// after advice
					var after = dispatcher.after;
					while(after && after.id < executionId){
						if(after.advice){
							if(after.receiveArguments){
								var newResults = after.advice.apply(this, args);
								// change the return value only if a new value was returned
								results = newResults === undefined ? results : newResults;
							}else{
								results = after.advice.call(this, results, args);
							}
						}
						after = after.next;
					}
					return results;
				};
				if(existing){
					dispatcher.around = {advice: function(target, args){
						return existing.apply(target, args);
					}};
				}
				dispatcher.target = target;
				dispatcher.nextId = dispatcher.nextId || 0;
			}
			var results = advise((dispatcher || existing), type, advice, receiveArguments);
			advice = null;
			return results;
		};
	}

	// TODOC: after/before/around return object

	var after = aspect("after");
	/*=====
	after = function(target, methodName, advice, receiveArguments){
		// summary:
		//		The "after" export of the aspect module is a function that can be used to attach
		//		"after" advice to a method. This function will be executed after the original method
		//		is executed. By default the function will be called with a single argument, the return
		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
		//		The fourth (optional) argument can be set to true to so the function receives the original
		//		arguments (from when the original method was called) rather than the return value.
		//		If there are multiple "after" advisors, they are executed in the order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called after the original method
		// receiveArguments: Boolean?
		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
		//		was called) rather than the return value of the original/previous method.
		// returns:
		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
		//		stop the advice function from being executed.
	};
	=====*/

	var before = aspect("before");
	/*=====
	before = function(target, methodName, advice){
		// summary:
		//		The "before" export of the aspect module is a function that can be used to attach
		//		"before" advice to a method. This function will be executed before the original method
		//		is executed. This function will be called with the arguments used to call the method.
		//		This function may optionally return an array as the new arguments to use to call
		//		the original method (or the previous, next-to-execute before advice, if one exists).
		//		If the before method doesn't return anything (returns undefined) the original arguments
		//		will be preserved.
		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called before the original method
	};
	=====*/

	var around = aspect("around");
	/*=====
	 around = function(target, methodName, advice){
		// summary:
		//		The "around" export of the aspect module is a function that can be used to attach
		//		"around" advice to a method. The advisor function is immediately executed when
		//		the around() is called, is passed a single argument that is a function that can be
		//		called to continue execution of the original method (or the next around advisor).
		//		The advisor function should return a function, and this function will be called whenever
		//		the method is called. It will be called with the arguments used to call the method.
		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
		// example:
		//		If there are multiple "around" advisors, the most recent one is executed first,
		//		which can then delegate to the next one and so on. For example:
		//		|	around(obj, "foo", function(originalFoo){
		//		|		return function(){
		//		|			var start = new Date().getTime();
		//		|			var results = originalFoo.apply(this, arguments); // call the original
		//		|			var end = new Date().getTime();
		//		|			console.log("foo execution took " + (end - start) + " ms");
		//		|			return results;
		//		|		};
		//		|	});
		// target: Object
		//		This is the target object
		// methodName: String
		//		This is the name of the method to attach to.
		// advice: Function
		//		This is function to be called around the original method
	};
	=====*/

	return {
		// summary:
		//		provides aspect oriented programming functionality, allowing for
		//		one to add before, around, or after advice on existing methods.
		// example:
		//	|	define(["dojo/aspect"], function(aspect){
		//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
		//	|			this will be called when targetObject.methodName() is called, after the original function is called
		//	|		});
		//
		// example:
		//	The returned signal object can be used to cancel the advice.
		//	|	signal.remove(); // this will stop the advice from being executed anymore
		//	|	aspect.before(targetObject, "methodName", function(someArgument){
		//	|		// this will be called when targetObject.methodName() is called, before the original function is called
		//	|	 });

		before: before,
		around: around,
		after: after
	};
});

},
'dojo/_base/connect':function(){
define(["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
// module:
//		dojo/_base/connect

has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
	var testKeyEvent = {charCode: 0};
	try{
		testKeyEvent = document.createEvent("KeyboardEvent");
		(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
	}catch(e){}
	return testKeyEvent.charCode == 0 && !has("opera");
});

function connect_(obj, event, context, method, dontFix){
	method = lang.hitch(context, method);
	if(!obj || !(obj.addEventListener || obj.attachEvent)){
		// it is a not a DOM node and we are using the dojo.connect style of treating a
		// method like an event, must go right to aspect
		return aspect.after(obj || dojo.global, event, method, true);
	}
	if(typeof event == "string" && event.substring(0, 2) == "on"){
		event = event.substring(2);
	}
	if(!obj){
		obj = dojo.global;
	}
	if(!dontFix){
		switch(event){
			// dojo.connect has special handling for these event types
			case "keypress":
				event = keypress;
				break;
			case "mouseenter":
				event = mouse.enter;
				break;
			case "mouseleave":
				event = mouse.leave;
				break;
		}
	}
	return on(obj, event, method, dontFix);
}

var _punctMap = {
	106:42,
	111:47,
	186:59,
	187:43,
	188:44,
	189:45,
	190:46,
	191:47,
	192:96,
	219:91,
	220:92,
	221:93,
	222:39,
	229:113
};
var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";


var _synthesizeEvent = function(evt, props){
	var faux = lang.mixin({}, evt, props);
	setKeyChar(faux);
	// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
	// but it throws an error when preventDefault is invoked on Safari
	// does Event.preventDefault not support "apply" on Safari?
	faux.preventDefault = function(){ evt.preventDefault(); };
	faux.stopPropagation = function(){ evt.stopPropagation(); };
	return faux;
};
function setKeyChar(evt){
	evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
	evt.charOrCode = evt.keyChar || evt.keyCode;
}
var keypress;
if(has("events-keypress-typed")){
	// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
	var _trySetKeyCode = function(e, code){
		try{
			// squelch errors when keyCode is read-only
			// (e.g. if keyCode is ctrl or shift)
			return (e.keyCode = code);
		}catch(e){
			return 0;
		}
	};
	keypress = function(object, listener){
		var keydownSignal = on(object, "keydown", function(evt){
			// munge key/charCode
			var k=evt.keyCode;
			// These are Windows Virtual Key Codes
			// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
			var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
			// synthesize keypress for most unprintables and CTRL-keys
			if(unprintable||evt.ctrlKey){
				var c = unprintable ? 0 : k;
				if(evt.ctrlKey){
					if(k==3 || k==13){
						return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
					}else if(c>95 && c<106){
						c -= 48; // map CTRL-[numpad 0-9] to ASCII
					}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
						c += 32; // map CTRL-[A-Z] to lowercase
					}else{
						c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
					}
				}
				// simulate a keypress event
				var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
				listener.call(evt.currentTarget, faux);
				if(has("ie")){
					_trySetKeyCode(evt, faux.keyCode);
				}
			}
		});
		var keypressSignal = on(object, "keypress", function(evt){
			var c = evt.charCode;
			c = c>=32 ? c : 0;
			evt = _synthesizeEvent(evt, {charCode: c, faux: true});
			return listener.call(this, evt);
		});
		return {
			remove: function(){
				keydownSignal.remove();
				keypressSignal.remove();
			}
		};
	};
}else{
	if(has("opera")){
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				var c = evt.which;
				if(c==3){
					c=99; // Mozilla maps CTRL-BREAK to CTRL-c
				}
				// can't trap some keys at all, like INSERT and DELETE
				// there is no differentiating info between DELETE and ".", or INSERT and "-"
				c = c<32 && !evt.shiftKey ? 0 : c;
				if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
					// lowercase CTRL-[A-Z] keys
					c += 32;
				}
				return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
			});
		};
	}else{
		keypress = function(object, listener){
			return on(object, "keypress", function(evt){
				setKeyChar(evt);
				return listener.call(this, evt);
			});
		};
	}
}

var connect = {
	// summary:
	//		This module defines the dojo.connect API.
	//		This modules also provides keyboard event handling helpers.
	//		This module exports an extension event for emulating Firefox's keypress handling.
	//		However, this extension event exists primarily for backwards compatibility and
	//		is not recommended. WebKit and IE uses an alternate keypress handling (only
	//		firing for printable characters, to distinguish from keydown events), and most
	//		consider the WebKit/IE behavior more desirable.

	_keypress:keypress,

	connect:function(obj, event, context, method, dontFix){
		// summary:
		//		`dojo.connect` is a deprecated event handling and delegation method in
		//		Dojo. It allows one function to "listen in" on the execution of
		//		any other, triggering the second whenever the first is called. Many
		//		listeners may be attached to a function, and source functions may
		//		be either regular function calls or DOM events.
		//
		// description:
		//		Connects listeners to actions, so that after event fires, a
		//		listener is called with the same arguments passed to the original
		//		function.
		//
		//		Since `dojo.connect` allows the source of events to be either a
		//		"regular" JavaScript function or a DOM event, it provides a uniform
		//		interface for listening to all the types of events that an
		//		application is likely to deal with though a single, unified
		//		interface. DOM programmers may want to think of it as
		//		"addEventListener for everything and anything".
		//
		//		When setting up a connection, the `event` parameter must be a
		//		string that is the name of the method/event to be listened for. If
		//		`obj` is null, `kernel.global` is assumed, meaning that connections
		//		to global methods are supported but also that you may inadvertently
		//		connect to a global by passing an incorrect object name or invalid
		//		reference.
		//
		//		`dojo.connect` generally is forgiving. If you pass the name of a
		//		function or method that does not yet exist on `obj`, connect will
		//		not fail, but will instead set up a stub method. Similarly, null
		//		arguments may simply be omitted such that fewer than 4 arguments
		//		may be required to set up a connection See the examples for details.
		//
		//		The return value is a handle that is needed to
		//		remove this connection with `dojo.disconnect`.
		//
		// obj: Object?
		//		The source object for the event function.
		//		Defaults to `kernel.global` if null.
		//		If obj is a DOM node, the connection is delegated
		//		to the DOM event manager (unless dontFix is true).
		//
		// event: String
		//		String name of the event function in obj.
		//		I.e. identifies a property `obj[event]`.
		//
		// context: Object|null
		//		The object that method will receive as "this".
		//
		//		If context is null and method is a function, then method
		//		inherits the context of event.
		//
		//		If method is a string then context must be the source
		//		object object for method (context[method]). If context is null,
		//		kernel.global is used.
		//
		// method: String|Function
		//		A function reference, or name of a function in context.
		//		The function identified by method fires after event does.
		//		method receives the same arguments as the event.
		//		See context argument comments for information on method's scope.
		//
		// dontFix: Boolean?
		//		If obj is a DOM node, set dontFix to true to prevent delegation
		//		of this connection to the DOM event manager.
		//
		// example:
		//		When obj.onchange(), do ui.update():
		//	|	dojo.connect(obj, "onchange", ui, "update");
		//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
		//
		// example:
		//		Using return value for disconnect:
		//	|	var link = dojo.connect(obj, "onchange", ui, "update");
		//	|	...
		//	|	dojo.disconnect(link);
		//
		// example:
		//		When onglobalevent executes, watcher.handler is invoked:
		//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked:
		//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
		//
		// example:
		//		When ob.onCustomEvent executes, customEventHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
		//
		// example:
		//		When globalEvent executes, globalHandler is invoked
		//		with the same scope (this):
		//	|	dojo.connect(null, "globalEvent", null, globalHandler);
		//	|	dojo.connect("globalEvent", globalHandler); // same

		// normalize arguments
		var a=arguments, args=[], i=0;
		// if a[0] is a String, obj was omitted
		args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
		// if the arg-after-next is a String or Function, context was NOT omitted
		var a1 = a[i+1];
		args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
		// absorb any additional arguments
		for(var l=a.length; i<l; i++){	args.push(a[i]); }
		return connect_.apply(this, args);
	},

	disconnect:function(handle){
		// summary:
		//		Remove a link created by dojo.connect.
		// description:
		//		Removes the connection between event and the method referenced by handle.
		// handle: Handle
		//		the return value of the dojo.connect call that created the connection.

		if(handle){
			handle.remove();
		}
	},

	subscribe:function(topic, context, method){
		// summary:
		//		Attach a listener to a named topic. The listener function is invoked whenever the
		//		named topic is published (see: dojo.publish).
		//		Returns a handle which is needed to unsubscribe this listener.
		// topic: String
		//		The topic to which to subscribe.
		// context: Object?
		//		Scope in which method will be invoked, or null for default scope.
		// method: String|Function
		//		The name of a function in context, or a function reference. This is the function that
		//		is invoked when topic is published.
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.subscribe(topic, lang.hitch(context, method));
	},

	publish:function(topic, args){
		// summary:
		//		Invoke all listener method subscribed to topic.
		// topic: String
		//		The name of the topic to publish.
		// args: Array?
		//		An array of arguments. The arguments will be applied
		//		to each topic subscriber (as first class parameters, via apply).
		// example:
		//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
		return hub.publish.apply(hub, [topic].concat(args));
	},

	connectPublisher:function(topic, obj, event){
		// summary:
		//		Ensure that every time obj.event() is called, a message is published
		//		on the topic. Returns a handle which can be passed to
		//		dojo.disconnect() to disable subsequent automatic publication on
		//		the topic.
		// topic: String
		//		The name of the topic to publish.
		// obj: Object?
		//		The source object for the event function. Defaults to kernel.global
		//		if null.
		// event: String
		//		The name of the event function in obj.
		//		I.e. identifies a property obj[event].
		// example:
		//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
		var pf = function(){ connect.publish(topic, arguments); };
		return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
	},

	isCopyKey: function(e){
		// summary:
		//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
		// e: Event
		//		Event object to examine
		return e[evtCopyKey];	// Boolean
	}
};

connect.unsubscribe = connect.disconnect;
/*=====
 connect.unsubscribe = function(handle){
	 // summary:
	 //		Remove a topic listener.
	 // handle: Handle
	 //		The handle returned from a call to subscribe.
	 // example:
	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
	 //	|	...
	 //	|	dojo.unsubscribe(alerter);
 };
 =====*/

 1  && lang.mixin(dojo, connect);
return connect;

});



},
'dojo/errors/CancelError':function(){
define(["./create"], function(create){
	// module:
	//		dojo/errors/CancelError

	/*=====
	return function(){
		// summary:
		//		Default error if a promise is canceled without a reason.
	};
	=====*/

	return create("CancelError", null, null, { dojoType: "cancel", log: false });
});

}}});
require({cache:{
'com/huayun/webgis/geometry/Geometry':function(){
/**
 * 
 * @module com/huayun/webgis/geometry
 * @see com.huayun.webgis.geometry.Geometry
 */
define([], function () {
  /**
   * 
   * @constructor
   * @alias com.huayun.webgis.geometry.Geometry
   * @property {Object} extent  - 
   * @property {String} type  - 
   */
  function Geometry() {
    // todo
    this.extent = null;
    this.spatialReference = null;
    this.type = "";
    this.hasM = false;
    this.hasZ = false;
  }

  Geometry.prototype.clone = function () {
    // todo
  };

  Geometry.prototype.update = function () {};

  return Geometry;
});

},
'com/huayun/webgis/renderer/SimpleRenderer':function(){
define([
    "./FillRenderer",
    "./LineRenderer",
    "./CircleRenderer",
    "./ImageRenderer"
], function (FillRenderer, LineRenderer, CircleRenderer, ImageRenderer) {
    function SimpleRenderer() {
        this.lineRenderer = new LineRenderer();
        this.fillRenderer = new FillRenderer();
        this.circleRenderer = new CircleRenderer();
        this.imageRenderer = new ImageRenderer();
    }

    SimpleRenderer.prototype.add = function (view, graphic, geometry, symbol) {
        switch (symbol.type) {
            case "line":
                this.lineRenderer.add(view, graphic, geometry, symbol);
                break;
            case "polygon":
                this.fillRenderer.add(view, graphic, geometry, symbol);
                break;
            case "circle":
                this.circleRenderer.add(view, graphic, geometry, symbol);
                break;
            case "image":
                this.imageRenderer.add(view, graphic, geometry, symbol);
        }
    };

    SimpleRenderer.prototype.draw = function (view, graphic, geometry, symbol, layerView, index) {
        switch (symbol.type) {
            case "line":
                this.lineRenderer.draw(view, graphic, geometry, symbol, layerView, index);
                break;
            case "polygon":
                this.fillRenderer.draw(view, graphic, geometry, symbol, layerView, index);
                break;
            case "circle":
                this.circleRenderer.draw(view, graphic, geometry, symbol, layerView, index);
                break;
            case "image":
                this.imageRenderer.draw(view, graphic, geometry, symbol, layerView, index);
                break;
        }
    };

    SimpleRenderer.prototype.calculateExtent = function (view, graphic, geometry, symbol, result) {
        switch (symbol.type) {
            case "line":
                this.lineRenderer.calculateExtent(view, graphic, geometry, symbol, result);
                break;
            case "polygon":
                this.fillRenderer.calculateExtent(view, graphic, geometry, symbol, result);
                break;
            case "circle":
                this.circleRenderer.calculateExtent(view, graphic, geometry, symbol, result);
                break;
            case "image":
                this.imageRenderer.calculateExtent(view, graphic, geometry, symbol, result);
                break;
        }
    };

    return SimpleRenderer;
});

},
'com/huayun/webgis/data/bucket/ImageBucketSimplify':function(){
define([
    "../ArrayType",
    "../../gl/SegmentVector",
    "../../geometry/Anchor",
    "../../geometry/Point2D"
], function (ArrayType, SegmentVector, Anchor, Point) {
    function addVertex$1(array, anchorX, anchorY, ox, oy, tx, ty) {
        array.emplaceBack(
            anchorX,
            anchorY, // a_pos
            Math.round(ox * 32),
            Math.round(oy * 32),
            tx, // x coordinate of symbol on glyph atlas texture
            ty // y coordinate of symbol on glyph atlas texture // a_pos_offset
        );
    }

    function shapeIcon(width, height, iconOffset) {
        var dx = iconOffset[0],
          dy = iconOffset[1];

        var x1 = dx - width * 0.5;
        var x2 = x1 + width;
        var y1 = dy - height * 0.5;
        var y2 = y1 + height;
        return {top: y1, bottom: y2, left: x1, right: x2};
    }

    function getIconQuads(anchor, shapedIcon, width, height) {
        var top = shapedIcon.top;
        var left = shapedIcon.left;
        var bottom = shapedIcon.bottom;
        var right = shapedIcon.right;
        var tl, tr, br, bl;
        tl = new Point(left, top);
        tr = new Point(right, top);
        br = new Point(right, bottom);
        bl = new Point(left, bottom);
        return [{tl: tl, tr: tr, bl: bl, br: br, tex: {x: 0, y: 0, w: width, h: height}}];
    }

    var ImageBucket = function ImageBucket() {
        this.layoutVertexArray = new ArrayType.StructArrayLayout2f4ib16();
        this.indexArray = new ArrayType.StructArrayLayout3ui6();
        this.segments = new SegmentVector();
    };

    ImageBucket.prototype.destroy = function destroy() {
        if (!this.layoutVertexBuffer) {
            return;
        }
        this.layoutVertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.segments.destroy();
    };

    ImageBucket.prototype.addFeature = function(geometry, width, height, iconOffset) {
        var shapedIcon = shapeIcon(width, height, iconOffset);
        for (var i$6 = 0, list$6 = geometry; i$6 < list$6.length; i$6 += 1) {
            var points = list$6[i$6];
            for (var i = 0, list = points; i < list.length; i += 1) {
                var point = list[i];
                var anchor = new Anchor(point.x, point.y);
                var iconQuads = getIconQuads(anchor, shapedIcon, width, height);
                this.addSymbols(iconQuads, anchor);
            }
        }
    };

    ImageBucket.prototype.addSymbols = function addSymbols(quads, labelAnchor) {
        var indexArray = this.indexArray;
        var layoutVertexArray = this.layoutVertexArray;
        var segment = this.segments.prepareSegment(4 * quads.length, this.layoutVertexArray, this.indexArray);

        for (var i = 0, list = quads; i < list.length; i += 1) {
            var symbol = list[i];
            var tl = symbol.tl, tr = symbol.tr, bl = symbol.bl, br = symbol.br, tex = symbol.tex;
            var index = segment.vertexLength;
            addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, tl.x, tl.y, tex.x, tex.y);
            addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, tr.x, tr.y, tex.x + tex.w, tex.y);
            addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, bl.x, bl.y, tex.x, tex.y + tex.h);
            addVertex$1(layoutVertexArray, labelAnchor.x, labelAnchor.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h);
            indexArray.emplaceBack(index, index + 1, index + 2);
            indexArray.emplaceBack(index + 1, index + 2, index + 3);
            segment.vertexLength += 4;
            segment.primitiveLength += 2;
        }
    };

    ImageBucket.prototype.upload = function upload(context) {
        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, [
            {name: "a_pos", type: "Float32", components: 2, offset: 0},
            {name: "a_data", type: "Int16", components: 4, offset: 8}
        ]);
        this.indexBuffer = context.createIndexBuffer(this.indexArray);
    };

    return ImageBucket;
});
},
'dojo/text':function(){
define(["./_base/kernel", "require", "./has", "./request"], function (dojo, require, has, request) {
    // module:
    //		dojo/text

    var getText;
    if ( 1 ) {
        getText = function (url, sync, load) {
            request(url, {sync: !!sync, headers: {'X-Requested-With': null}}).then(load);
        };
    } else {
        // Path for node.js and rhino, to load from local file system.
        // TODO: use node.js native methods rather than depending on a require.getText() method to exist.
        if (require.getText) {
            getText = require.getText;
        } else {
            console.error("dojo/text plugin failed to load because loader does not support getText");
        }
    }

    var
        theCache = {},

        strip = function (text) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (text) {
                text = text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
                var matches = text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
                if (matches) {
                    text = matches[1];
                }
            } else {
                text = "";
            }
            return text;
        },

        notFound = {},

        pending = {};

    dojo.cache = function (/*String||Object*/module, /*String*/url, /*String||Object?*/value) {
        // summary:
        //		A getter and setter for storing the string content associated with the
        //		module and url arguments.
        // description:
        //		If module is a string that contains slashes, then it is interpretted as a fully
        //		resolved path (typically a result returned by require.toUrl), and url should not be
        //		provided. This is the preferred signature. If module is a string that does not
        //		contain slashes, then url must also be provided and module and url are used to
        //		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
        //		If value is specified, the cache value for the moduleUrl will be set to
        //		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
        //		in its internal cache and return that cached value for the URL. To clear
        //		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
        //		the URL contents, only modules on the same domain of the page can use this capability.
        //		The build system can inline the cache values though, to allow for xdomain hosting.
        // module: String||Object
        //		If a String with slashes, a fully resolved path; if a String without slashes, the
        //		module name to use for the base part of the URL, similar to module argument
        //		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
        //		generates a valid path for the cache item. For example, a dojo._Url object.
        // url: String
        //		The rest of the path to append to the path derived from the module argument. If
        //		module is an object, then this second argument should be the "value" argument instead.
        // value: String||Object?
        //		If a String, the value to use in the cache for the module/url combination.
        //		If an Object, it can have two properties: value and sanitize. The value property
        //		should be the value to use in the cache, and sanitize can be set to true or false,
        //		to indicate if XML declarations should be removed from the value and if the HTML
        //		inside a body tag in the value should be extracted as the real value. The value argument
        //		or the value property on the value argument are usually only used by the build system
        //		as it inlines cache content.
        // example:
        //		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
        //		of call is used to avoid an issue with the build system erroneously trying to intern
        //		this example. To get the build system to intern your dojo.cache calls, use the
        //		"dojo.cache" style of call):
        //		| //If template.html contains "<h1>Hello</h1>" that will be
        //		| //the value for the text variable.
        //		| //Note: This is pre-AMD, deprecated syntax
        //		| var text = dojo["cache"]("my.module", "template.html");
        // example:
        //		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
        //		 (the dojo["cache"] style of call is used to avoid an issue with the build system
        //		erroneously trying to intern this example. To get the build system to intern your
        //		dojo.cache calls, use the "dojo.cache" style of call):
        //		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
        //		| //text variable will contain just "<h1>Hello</h1>".
        //		| //Note: This is pre-AMD, deprecated syntax
        //		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
        // example:
        //		Same example as previous, but demonstrates how an object can be passed in as
        //		the first argument, then the value argument can then be the second argument.
        //		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
        //		| //text variable will contain just "<h1>Hello</h1>".
        //		| //Note: This is pre-AMD, deprecated syntax
        //		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

        //	 * (string string [value]) => (module, url, value)
        //	 * (object [value])        => (module, value), url defaults to ""
        //
        //	 * if module is an object, then it must be convertable to a string
        //	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
        //	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
        var key;
        if (typeof module == "string") {
            if (/\//.test(module)) {
                // module is a version 1.7+ resolved path
                key = module;
                value = url;
            } else {
                // module is a version 1.6- argument to dojo.moduleUrl
                key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
            }
        } else {
            key = module + "";
            value = url;
        }
        var
            val = (value != undefined && typeof value != "string") ? value.value : value,
            sanitize = value && value.sanitize;

        if (typeof val == "string") {
            //We have a string, set cache value
            theCache[key] = val;
            return sanitize ? strip(val) : val;
        } else if (val === null) {
            //Remove cached value
            delete theCache[key];
            return null;
        } else {
            //Allow cache values to be empty strings. If key property does
            //not exist, fetch it.
            if (!(key in theCache)) {
                getText(key, true, function (text) {
                    theCache[key] = text;
                });
            }
            return sanitize ? strip(theCache[key]) : theCache[key];
        }
    };

    return {
        // summary:
        //		This module implements the dojo/text! plugin and the dojo.cache API.
        // description:
        //		We choose to include our own plugin to leverage functionality already contained in dojo
        //		and thereby reduce the size of the plugin compared to various foreign loader implementations.
        //		Also, this allows foreign AMD loaders to be used without their plugins.
        //
        //		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
        //		loader. This feature is outside the scope of the CommonJS plugins specification.

        // the dojo/text caches it's own resources because of dojo.cache
        dynamic: true,

        normalize: function (id, toAbsMid) {
            // id is something like (path may be relative):
            //
            //	 "path/to/text.html"
            //	 "path/to/text.html!strip"
            var parts = id.split("!"),
                url = parts[0];
            return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
        },

        load: function (id, require, load) {
            // id: String
            //		Path to the resource.
            // require: Function
            //		Object that include the function toUrl with given id returns a valid URL from which to load the text.
            // load: Function
            //		Callback function which will be called, when the loading finished.

            // id is something like (path is always absolute):
            //
            //	 "path/to/text.html"
            //	 "path/to/text.html!strip"
            var
                parts = id.split("!"),
                stripFlag = parts.length > 1,
                absMid = parts[0],
                url = require.toUrl(parts[0]),
                requireCacheUrl = "url:" + url,
                text = notFound,
                finish = function (text) {
                    load(stripFlag ? strip(text) : text);
                };
            if (absMid in theCache) {
                text = theCache[absMid];
            } else if (require.cache && requireCacheUrl in require.cache) {
                text = require.cache[requireCacheUrl];
            } else if (url in theCache) {
                text = theCache[url];
            }
            if (text === notFound) {
                if (pending[url]) {
                    pending[url].push(finish);
                } else {
                    var pendingList = pending[url] = [finish];
                    getText(url, !require.async, function (text) {
                        theCache[absMid] = theCache[url] = text;
                        for (var i = 0; i < pendingList.length;) {
                            pendingList[i++](text);
                        }
                        delete pending[url];
                    });
                }
            } else {
                finish(text);
            }
        }
    };

});


},
'com/huayun/webgis/gl/uniform':function(){
define([
    "exports",
    "../utils/Color"
], function (exports, Color) {
    var Uniform = function Uniform(context, location) {
        this.gl = context.gl;
        this.location = location;
    };

    var Uniform1i = (function (Uniform) {
        function Uniform1i(context, location) {
            Uniform.call(this, context, location);
            this.current = 0;
        }
        if (Uniform) Uniform1i.__proto__ = Uniform;
        Uniform1i.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform1i.prototype.constructor = Uniform1i;
        Uniform1i.prototype.set = function set(v) {
            if (this.current !== v) {
                this.current = v;
                this.gl.uniform1i(this.location, v);
            }
        };
        return Uniform1i;
    }(Uniform));

    var Uniform1f = (function (Uniform) {
        function Uniform1f(context, location) {
            Uniform.call(this, context, location);
            this.current = 0;
        }

        if (Uniform) Uniform1f.__proto__ = Uniform;
        Uniform1f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform1f.prototype.constructor = Uniform1f;

        Uniform1f.prototype.set = function set(v) {
            if (this.current !== v) {
                this.current = v;
                this.gl.uniform1f(this.location, v);
            }
        };

        return Uniform1f;
    }(Uniform));

    var Uniform2f = (function (Uniform) {
        function Uniform2f(context, location) {
            Uniform.call(this, context, location);
            this.current = [0, 0];
        }

        if (Uniform) Uniform2f.__proto__ = Uniform;
        Uniform2f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform2f.prototype.constructor = Uniform2f;

        Uniform2f.prototype.set = function set(v) {
            if (v[0] !== this.current[0] || v[1] !== this.current[1]) {
                this.current = v;
                this.gl.uniform2f(this.location, v[0], v[1]);
            }
        };

        return Uniform2f;
    }(Uniform));

    var Uniform3f = (function (Uniform) {
        function Uniform3f(context, location) {
            Uniform.call(this, context, location);
            this.current = [0, 0, 0];
        }

        if (Uniform) Uniform3f.__proto__ = Uniform;
        Uniform3f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform3f.prototype.constructor = Uniform3f;

        Uniform3f.prototype.set = function set(v) {
            if (v[0] !== this.current[0] || v[1] !== this.current[1] || v[2] !== this.current[2]) {
                this.current = v;
                this.gl.uniform3f(this.location, v[0], v[1], v[2]);
            }
        };

        return Uniform3f;
    }(Uniform));

    var Uniform4f = (function (Uniform) {
        function Uniform4f(context, location) {
            Uniform.call(this, context, location);
            this.current = [0, 0, 0, 0];
        }

        if (Uniform) Uniform4f.__proto__ = Uniform;
        Uniform4f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform4f.prototype.constructor = Uniform4f;

        Uniform4f.prototype.set = function set(v) {
            if (v[0] !== this.current[0] || v[1] !== this.current[1] ||
                v[2] !== this.current[2] || v[3] !== this.current[3]) {
                this.current = v;
                this.gl.uniform4f(this.location, v[0], v[1], v[2], v[3]);
            }
        };

        return Uniform4f;
    }(Uniform));

    var UniformColor = (function (Uniform) {
        function UniformColor(context, location) {
            Uniform.call(this, context, location);
            this.current = Color.transparent;
        }

        if (Uniform) UniformColor.__proto__ = Uniform;
        UniformColor.prototype = Object.create(Uniform && Uniform.prototype);
        UniformColor.prototype.constructor = UniformColor;

        UniformColor.prototype.set = function set(v) {
            if (v.r !== this.current.r || v.g !== this.current.g ||
                v.b !== this.current.b || v.a !== this.current.a) {
                this.current = v;
                this.gl.uniform4f(this.location, v.r, v.g, v.b, v.a);
            }
        };

        return UniformColor;
    }(Uniform));

    var emptyMat4 = new Float32Array(16);
    var UniformMatrix4f = (function (Uniform) {
        function UniformMatrix4f(context, location) {
            Uniform.call(this, context, location);
            this.current = emptyMat4;
        }

        if (Uniform) UniformMatrix4f.__proto__ = Uniform;
        UniformMatrix4f.prototype = Object.create(Uniform && Uniform.prototype);
        UniformMatrix4f.prototype.constructor = UniformMatrix4f;

        UniformMatrix4f.prototype.set = function set(v) {
            if (v[12] !== this.current[12] || v[0] !== this.current[0]) {
                this.current = v;
                this.gl.uniformMatrix4fv(this.location, false, v);
                return;
            }
            for (var i = 1; i < 16; i++) {
                if (v[i] !== this.current[i]) {
                    this.current = v;
                    this.gl.uniformMatrix4fv(this.location, false, v);
                    break;
                }
            }
        };

        return UniformMatrix4f;
    }(Uniform));

    exports.Uniform1f = Uniform1f;
    exports.Uniform1i = Uniform1i;
    exports.Uniform2f = Uniform2f;
    exports.Uniform3f = Uniform3f;
    exports.Uniform4f = Uniform4f;
    exports.UniformMatrix4f = UniformMatrix4f;
    exports.UniformColor = UniformColor;
});
},
'com/huayun/webgis/data/ArrayType':function(){
define([
    "require",
    "exports",
    "./struct"
], function (e, f, struct) {
    Object.defineProperty(f, "__esModule", {value: !0});
    var DEFAULT_CAPACITY = 128;
    var RESIZE_MULTIPLIER = 5;
    e = function () {
        function StructArray() {
            this.isTransferred = false;
            this.capacity = -1;
            this.resize(0);
        }

        StructArray.serialize = function serialize(array, transferables) {
            array._trim();
            if (transferables) {
                array.isTransferred = true;
                transferables.push(array.arrayBuffer);
            }
            return {
                length: array.length,
                arrayBuffer: array.arrayBuffer
            };
        };
        /**
         * StructArray
         * @param input
         */
        StructArray.deserialize = function deserialize(input) {
            var structArray = Object.create(this.prototype);
            structArray.arrayBuffer = input.arrayBuffer;
            structArray.length = input.length;
            structArray.capacity = input.arrayBuffer.byteLength / structArray.bytesPerElement;
            structArray._refreshViews();
            return structArray;
        };
        /**
         * array
         */
        StructArray.prototype._trim = function _trim() {
            if (this.length !== this.capacity) {
                this.capacity = this.length;
                this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
                this._refreshViews();
            }
        };
        /**
         * 0
         */
        StructArray.prototype.clear = function clear() {
            this.length = 0;
        };
        /**
         * array
         * n
         * nn
         * @param {number} n 
         */
        StructArray.prototype.resize = function resize(n) {
            this.reserve(n);
            this.length = n;
        };
        /**
         * Indicate a planned increase in size, so that any necessary allocation may be done once, ahead of time.
         * @param {number} n .
         */
        StructArray.prototype.reserve = function reserve(n) {
            if (n > this.capacity) {
                this.capacity = Math.max(n, Math.floor(this.capacity * RESIZE_MULTIPLIER), DEFAULT_CAPACITY);
                this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                var oldUint8Array = this.uint8;
                this._refreshViews();
                if (oldUint8Array) {
                    this.uint8.set(oldUint8Array);
                }
            }
        };
        /**
         * Create TypedArray views for the current ArrayBuffer.
         */
        StructArray.prototype._refreshViews = function _refreshViews() {
            throw new Error('_refreshViews() must be implemented by each concrete StructArray layout');
        };

        return StructArray;
    }();
    f.StructArray = e;
    var array = function (StructArray) {
        function StructArrayLayout2i4() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i4.__proto__ = StructArray;
        StructArrayLayout2i4.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i4.prototype.constructor = StructArrayLayout2i4;

        StructArrayLayout2i4.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
        };

        StructArrayLayout2i4.prototype.emplaceBack = function emplaceBack(v0, v1) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1);
        };

        StructArrayLayout2i4.prototype.emplace = function emplace(i, v0, v1) {
            var o2 = i * 2;
            this.int16[o2] = v0;
            this.int16[o2 + 1] = v1;
            return i;
        };

        return StructArrayLayout2i4;
    }(e);
    array.prototype.bytesPerElement = 4;
    f.StructArrayLayout2i4 = array;

    array = function (StructArray) {
        function StructArrayLayout2ui4() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2ui4.__proto__ = StructArray;
        StructArrayLayout2ui4.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2ui4.prototype.constructor = StructArrayLayout2ui4;

        StructArrayLayout2ui4.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
        };

        StructArrayLayout2ui4.prototype.emplaceBack = function emplaceBack(v0, v1) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1);
        };

        StructArrayLayout2ui4.prototype.emplace = function emplace(i, v0, v1) {
            var o2 = i * 2;
            this.uint16[o2] = v0;
            this.uint16[o2 + 1] = v1;
            return i;
        };

        return StructArrayLayout2ui4;
    }(e);
    array.prototype.bytesPerElement = 4;
    f.StructArrayLayout2ui4 = array;

    array = function (StructArray) {
        function StructArrayLayout2i8() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i8.__proto__ = StructArray;
        StructArrayLayout2i8.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i8.prototype.constructor = StructArrayLayout2i8;

        StructArrayLayout2i8.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int32 = new Int32Array(this.arrayBuffer);
        };

        StructArrayLayout2i8.prototype.emplaceBack = function emplaceBack(v0, v1) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1);
        };

        StructArrayLayout2i8.prototype.emplace = function emplace(i, v0, v1) {
            var o2 = i * 2;
            this.int32[o2] = v0;
            this.int32[o2 + 1] = v1;
            return i;
        };

        return StructArrayLayout2i8;
    }(e);
    array.prototype.bytesPerElement = 8;
    f.StructArrayLayout2i8 = array;

    array = function (StructArray) {
        function StructArrayLayout2i4ub8() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i4ub8.__proto__ = StructArray;
        StructArrayLayout2i4ub8.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i4ub8.prototype.constructor = StructArrayLayout2i4ub8;

        StructArrayLayout2i4ub8.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
        };

        StructArrayLayout2i4ub8.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5);
        };

        StructArrayLayout2i4ub8.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
            var o2 = i * 4;
            var o1 = i * 8;
            this.int16[o2] = v0;
            this.int16[o2 + 1] = v1;
            this.uint8[o1 + 4] = v2;
            this.uint8[o1 + 5] = v3;
            this.uint8[o1 + 6] = v4;
            this.uint8[o1 + 7] = v5;
            return i;
        };

        return StructArrayLayout2i4ub8;
    }(e);
    array.prototype.bytesPerElement = 8;
    f.StructArrayLayout2i4ub8 = array;

    array = function (StructArray) {
        function StructArrayLayout4i4ui16() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout4i4ui16.__proto__ = StructArray;
        StructArrayLayout4i4ui16.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout4i4ui16.prototype.constructor = StructArrayLayout4i4ui16;

        StructArrayLayout4i4ui16.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
        };

        StructArrayLayout4i4ui16.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7);
        };

        StructArrayLayout4i4ui16.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7) {
            var o2 = i * 8;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            this.int16[o2 + 3] = v3;
            this.uint16[o2 + 4] = v4;
            this.uint16[o2 + 5] = v5;
            this.uint16[o2 + 6] = v6;
            this.uint16[o2 + 7] = v7;
            return i;
        };

        return StructArrayLayout4i4ui16;
    }(e);

    array.prototype.bytesPerElement = 16;
    f.StructArrayLayout4i4ui16 = array;

    array = function (StructArray) {
        function StructArrayLayout3ui6() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout3ui6.__proto__ = StructArray;
        StructArrayLayout3ui6.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout3ui6.prototype.constructor = StructArrayLayout3ui6;

        StructArrayLayout3ui6.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
        };

        StructArrayLayout3ui6.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2);
        };

        StructArrayLayout3ui6.prototype.emplace = function emplace(i, v0, v1, v2) {
            var o2 = i * 3;
            this.uint16[o2 + 0] = v0;
            this.uint16[o2 + 1] = v1;
            this.uint16[o2 + 2] = v2;
            return i;
        };

        return StructArrayLayout3ui6;
    }(e);
    array.prototype.bytesPerElement = 6;
    f.StructArrayLayout3ui6 = array;

    array = function (StructArray) {
        function StructArrayLayout3ui12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout3ui12.__proto__ = StructArray;
        StructArrayLayout3ui12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout3ui12.prototype.constructor = StructArrayLayout3ui12;

        StructArrayLayout3ui12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.uint32 = new Uint32Array(this.arrayBuffer);
        };

        StructArrayLayout3ui12.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2);
        };

        StructArrayLayout3ui12.prototype.emplace = function emplace(i, v0, v1, v2) {
            var o2 = i * 3;
            this.uint32[o2 + 0] = v0;
            this.uint32[o2 + 1] = v1;
            this.uint32[o2 + 2] = v2;
            return i;
        };

        return StructArrayLayout3ui12;
    }(e);
    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout3ui12 = array;

    array = function (StructArray) {
        function StructArrayLayout3f12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout3f12.__proto__ = StructArray;
        StructArrayLayout3f12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout3f12.prototype.constructor = StructArrayLayout3f12;

        StructArrayLayout3f12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout3f12.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2);
        };

        StructArrayLayout3f12.prototype.emplace = function emplace(i, v0, v1, v2) {
            var o4 = i * 3;
            this.float32[o4 + 0] = v0;
            this.float32[o4 + 1] = v1;
            this.float32[o4 + 2] = v2;
            return i;
        };

        return StructArrayLayout3f12;
    }(e);

    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout3f12 = array;

    array = function (StructArray) {
        function StructArrayLayout1ul4() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout1ul4.__proto__ = StructArray;
        StructArrayLayout1ul4.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout1ul4.prototype.constructor = StructArrayLayout1ul4;

        StructArrayLayout1ul4.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.uint32 = new Uint32Array(this.arrayBuffer);
        };

        StructArrayLayout1ul4.prototype.emplaceBack = function emplaceBack(v0) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0);
        };

        StructArrayLayout1ul4.prototype.emplace = function emplace(i, v0) {
            var o4 = i * 1;
            this.uint32[o4 + 0] = v0;
            return i;
        };

        return StructArrayLayout1ul4;
    }(e);

    array.prototype.bytesPerElement = 4;
    f.StructArrayLayout1ul4 = array;

    array = function (StructArray) {
        function StructArrayLayout2i4ub12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i4ub12.__proto__ = StructArray;
        StructArrayLayout2i4ub12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i4ub12.prototype.constructor = StructArrayLayout2i4ub12;

        StructArrayLayout2i4ub12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            // this.int16 = new Int16Array(this.arrayBuffer);
            this.int32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout2i4ub12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5);
        };

        StructArrayLayout2i4ub12.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
            var o2 = i * 3;
            var o1 = i * 12;
            this.int32[o2] = v0;
            this.int32[o2 + 1] = v1;
            this.uint8[o1 + 8] = v2;
            this.uint8[o1 + 9] = v3;
            this.uint8[o1 + 10] = v4;
            this.uint8[o1 + 11] = v5;
            return i;
        };

        return StructArrayLayout2i4ub12;
    }(e);
    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout2i4ub12 = array;

    array = function (StructArray) {
        function StructArrayLayout2i2ui3ul3ui2f2ub1ul44() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i2ui3ul3ui2f2ub1ul44.__proto__ = StructArray;
        StructArrayLayout2i2ui3ul3ui2f2ub1ul44.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i2ui3ul3ui2f2ub1ul44.prototype.constructor = StructArrayLayout2i2ui3ul3ui2f2ub1ul44;

        StructArrayLayout2i2ui3ul3ui2f2ub1ul44.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
            this.uint32 = new Uint32Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout2i2ui3ul3ui2f2ub1ul44.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
        };

        StructArrayLayout2i2ui3ul3ui2f2ub1ul44.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) {
            var o2 = i * 22;
            var o4 = i * 11;
            var o1 = i * 44;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.uint16[o2 + 2] = v2;
            this.uint16[o2 + 3] = v3;
            this.uint32[o4 + 2] = v4;
            this.uint32[o4 + 3] = v5;
            this.uint32[o4 + 4] = v6;
            this.uint16[o2 + 10] = v7;
            this.uint16[o2 + 11] = v8;
            this.uint16[o2 + 12] = v9;
            this.float32[o4 + 7] = v10;
            this.float32[o4 + 8] = v11;
            this.uint8[o1 + 36] = v12;
            this.uint8[o1 + 37] = v13;
            this.uint32[o4 + 10] = v14;
            return i;
        };

        return StructArrayLayout2i2ui3ul3ui2f2ub1ul44;
    }(e);

    array.prototype.bytesPerElement = 44;
    f.StructArrayLayout2i2ui3ul3ui2f2ub1ul44 = array;

    array = function (StructArray) {
        function StructArrayLayout2ub2f12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2ub2f12.__proto__ = StructArray;
        StructArrayLayout2ub2f12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2ub2f12.prototype.constructor = StructArrayLayout2ub2f12;

        StructArrayLayout2ub2f12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout2ub2f12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3);
        };

        StructArrayLayout2ub2f12.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
            var o1 = i * 12;
            var o4 = i * 3;
            this.uint8[o1 + 0] = v0;
            this.uint8[o1 + 1] = v1;
            this.float32[o4 + 1] = v2;
            this.float32[o4 + 2] = v3;
            return i;
        };

        return StructArrayLayout2ub2f12;
    }(e);

    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout2ub2f12 = array;

    array = (function (StructArray) {
        function StructArrayLayout2i2i2i12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i2i2i12.__proto__ = StructArray;
        StructArrayLayout2i2i2i12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i2i2i12.prototype.constructor = StructArrayLayout2i2i2i12;

        StructArrayLayout2i2i2i12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
        };

        StructArrayLayout2i2i2i12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5);
        };

        StructArrayLayout2i2i2i12.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
            var o2 = i * 6;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            this.int16[o2 + 3] = v3;
            this.int16[o2 + 4] = v4;
            this.int16[o2 + 5] = v5;
            return i;
        };

        return StructArrayLayout2i2i2i12;
    }(e));
    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout2i2i2i12 = array;

    array = function (StructArray) {
        function StructArrayLayout6fb24() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout6fb24.__proto__ = StructArray;
        StructArrayLayout6fb24.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout6fb24.prototype.constructor = StructArrayLayout6fb24;

        StructArrayLayout6fb24.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Float32Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout6fb24.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5);
        };

        StructArrayLayout6fb24.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
            var o1 = i * 6;
            this.float32[o1 + 0] = v0;
            this.float32[o1 + 1] = v1;
            this.float32[o1 + 2] = v2;
            this.float32[o1 + 3] = v3;
            this.float32[o1 + 4] = v4;
            this.float32[o1 + 5] = v5;
            return i;
        };

        return StructArrayLayout6fb24;
    }(e);
    array.prototype.bytesPerElement = 24;
    f.StructArrayLayout6fb24 = array;


    array = function (StructArray) {
        function StructArrayLayout6f2ib28() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout6f2ib28.__proto__ = StructArray;
        StructArrayLayout6f2ib28.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout6f2ib28.prototype.constructor = StructArrayLayout6f2ib28;

        StructArrayLayout6f2ib28.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Float32Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer)
        };

        StructArrayLayout6f2ib28.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7);
        };

        StructArrayLayout6f2ib28.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7) {
            var o1 = i * 7;
            var o2 = i * 14;
            this.float32[o1 + 0] = v0;
            this.float32[o1 + 1] = v1;
            this.float32[o1 + 2] = v2;
            this.float32[o1 + 3] = v3;
            this.float32[o1 + 4] = v4;
            this.float32[o1 + 5] = v5;
            this.int16[o2 + 12] = v6;
            this.int16[o2 + 13] = v7;
            return i;
        };

        return StructArrayLayout6f2ib28;
    }(e);
    array.prototype.bytesPerElement = 28;
    f.StructArrayLayout6f2ib28 = array;


    array = function (StructArray) {
        function StructArrayLayout7f2ib32() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout7f2ib32.__proto__ = StructArray;
        StructArrayLayout7f2ib32.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout7f2ib32.prototype.constructor = StructArrayLayout7f2ib32;

        StructArrayLayout7f2ib32.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Float32Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer)
        };

        StructArrayLayout7f2ib32.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8);
        };

        StructArrayLayout7f2ib32.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8) {
            var o1 = i * 8;
            var o2 = i * 16;
            this.float32[o1 + 0] = v0;
            this.float32[o1 + 1] = v1;
            this.float32[o1 + 2] = v2;
            this.float32[o1 + 3] = v3;
            this.float32[o1 + 4] = v4;
            this.float32[o1 + 5] = v5;
            this.float32[o1 + 6] = v6;
            this.int16[o2 + 14] = v7;
            this.int16[o2 + 15] = v8;
            return i;
        };

        return StructArrayLayout7f2ib32;
    }(e);
    array.prototype.bytesPerElement = 32;
    f.StructArrayLayout7f2ib32 = array;

    array = function (StructArray) {
        function StructArrayLayout7fb28() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout7fb28.__proto__ = StructArray;
        StructArrayLayout7fb28.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout7fb28.prototype.constructor = StructArrayLayout7fb28;

        StructArrayLayout7fb28.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Float32Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout7fb28.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6);
        };

        StructArrayLayout7fb28.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6) {
            var o1 = i * 7;
            this.float32[o1 + 0] = v0;
            this.float32[o1 + 1] = v1;
            this.float32[o1 + 2] = v2;
            this.float32[o1 + 3] = v3;
            this.float32[o1 + 4] = v4;
            this.float32[o1 + 5] = v5;
            this.float32[o1 + 6] = v6;
            return i;
        };

        return StructArrayLayout7fb28;
    }(e);
    array.prototype.bytesPerElement = 28;
    f.StructArrayLayout7fb28 = array;

    array = function (StructArray) {
        function StructArrayLayout6i1ul2ui2i24() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout6i1ul2ui2i24.__proto__ = StructArray;
        StructArrayLayout6i1ul2ui2i24.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout6i1ul2ui2i24.prototype.constructor = StructArrayLayout6i1ul2ui2i24;

        StructArrayLayout6i1ul2ui2i24.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
            this.uint32 = new Uint32Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
        };

        StructArrayLayout6i1ul2ui2i24.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
        };

        StructArrayLayout6i1ul2ui2i24.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) {
            var o2 = i * 12;
            var o4 = i * 6;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            this.int16[o2 + 3] = v3;
            this.int16[o2 + 4] = v4;
            this.int16[o2 + 5] = v5;
            this.uint32[o4 + 3] = v6;
            this.uint16[o2 + 8] = v7;
            this.uint16[o2 + 9] = v8;
            this.int16[o2 + 10] = v9;
            this.int16[o2 + 11] = v10;
            return i;
        };

        return StructArrayLayout6i1ul2ui2i24;
    }(e);

    array.prototype.bytesPerElement = 24;
    f.StructArrayLayout6i1ul2ui2i24 = array;

    array = (function (StructArray) {
        function StructArrayLayout1f4() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout1f4.__proto__ = StructArray;
        StructArrayLayout1f4.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout1f4.prototype.constructor = StructArrayLayout1f4;

        StructArrayLayout1f4.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout1f4.prototype.emplaceBack = function emplaceBack(v0) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0);
        };

        StructArrayLayout1f4.prototype.emplace = function emplace(i, v0) {
            var o4 = i * 1;
            this.float32[o4 + 0] = v0;
            return i;
        };

        return StructArrayLayout1f4;
    }(e));
    array.prototype.bytesPerElement = 4;
    f.StructArrayLayout1f4 = array;

    array = (function (StructArray) {
        function StructArrayLayout3i6() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout3i6.__proto__ = StructArray;
        StructArrayLayout3i6.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout3i6.prototype.constructor = StructArrayLayout3i6;

        StructArrayLayout3i6.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
        };

        StructArrayLayout3i6.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2);
        };

        StructArrayLayout3i6.prototype.emplace = function emplace(i, v0, v1, v2) {
            var o2 = i * 3;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            return i;
        };

        return StructArrayLayout3i6;
    }(e));
    array.prototype.bytesPerElement = 6;
    f.StructArrayLayout3i6 = array;

    array = (function (StructArray) {
        function StructArrayLayout6i9ui1ul2f44() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout6i9ui1ul2f44.__proto__ = StructArray;
        StructArrayLayout6i9ui1ul2f44.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout6i9ui1ul2f44.prototype.constructor = StructArrayLayout6i9ui1ul2f44;

        StructArrayLayout6i9ui1ul2f44.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
            this.uint32 = new Uint32Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout6i9ui1ul2f44.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);
        };

        StructArrayLayout6i9ui1ul2f44.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) {
            var o2 = i * 22;
            var o4 = i * 11;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            this.int16[o2 + 3] = v3;
            this.int16[o2 + 4] = v4;
            this.int16[o2 + 5] = v5;
            this.uint16[o2 + 6] = v6;
            this.uint16[o2 + 7] = v7;
            this.uint16[o2 + 8] = v8;
            this.uint16[o2 + 9] = v9;
            this.uint16[o2 + 10] = v10;
            this.uint16[o2 + 11] = v11;
            this.uint16[o2 + 12] = v12;
            this.uint16[o2 + 13] = v13;
            this.uint16[o2 + 14] = v14;
            this.uint32[o4 + 8] = v15;
            this.float32[o4 + 9] = v16;
            this.float32[o4 + 10] = v17;
            return i;
        };

        return StructArrayLayout6i9ui1ul2f44;
    }(e));
    array.prototype.bytesPerElement = 44;
    f.StructArrayLayout6i9ui1ul2f44 = array;

    array = (function (StructArray) {
        function StructArrayLayout1ul2ui8() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout1ul2ui8.__proto__ = StructArray;
        StructArrayLayout1ul2ui8.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout1ul2ui8.prototype.constructor = StructArrayLayout1ul2ui8;

        StructArrayLayout1ul2ui8.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.uint32 = new Uint32Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
        };

        StructArrayLayout1ul2ui8.prototype.emplaceBack = function emplaceBack(v0, v1, v2) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2);
        };

        StructArrayLayout1ul2ui8.prototype.emplace = function emplace(i, v0, v1, v2) {
            var o4 = i * 2;
            var o2 = i * 4;
            this.uint32[o4 + 0] = v0;
            this.uint16[o2 + 2] = v1;
            this.uint16[o2 + 3] = v2;
            return i;
        };

        return StructArrayLayout1ul2ui8;
    }(e));
    array.prototype.bytesPerElement = 8;
    f.StructArrayLayout1ul2ui8 = array;

    array = (function (StructArray) {
        function StructArrayLayout2f4ib16() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2f4ib16.__proto__ = StructArray;
        StructArrayLayout2f4ib16.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2f4ib16.prototype.constructor = StructArrayLayout2f4ib16;

        StructArrayLayout2f4ib16.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout2f4ib16.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5);
        };

        StructArrayLayout2f4ib16.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
            var o1 = i * 4;
            var o2 = i * 8;
            this.float32[o1 + 0] = v0;
            this.float32[o1 + 1] = v1;
            this.int16[o2 + 4] = v2;
            this.int16[o2 + 5] = v3;
            this.int16[o2 + 6] = v4;
            this.int16[o2 + 7] = v5;
            return i;
        };

        return StructArrayLayout2f4ib16;
    }(e));
    array.prototype.bytesPerElement = 16;
    f.StructArrayLayout2f4ib16 = array;


    array = (function (StructArray) {
        function StructArrayLayout2f2ib12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2f2ib12.__proto__ = StructArray;
        StructArrayLayout2f2ib12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2f2ib12.prototype.constructor = StructArrayLayout2f2ib12;

        StructArrayLayout2f2ib12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout2f2ib12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3);
        };

        StructArrayLayout2f2ib12.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
            var o1 = i * 3;
            var o2 = i * 6;
            this.float32[o1 + 0] = v0;
            this.float32[o1 + 1] = v1;
            this.int16[o2 + 4] = v2;
            this.int16[o2 + 5] = v3;
            return i;
        };

        return StructArrayLayout2f2ib12;
    }(e));
    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout2f2ib12 = array;

    array = function (StructArrayLayout6i1ul2ui2i24) {
        function CollisionBoxArray() {
            StructArrayLayout6i1ul2ui2i24.apply(this, arguments);
        }

        if (StructArrayLayout6i1ul2ui2i24) CollisionBoxArray.__proto__ = StructArrayLayout6i1ul2ui2i24;
        CollisionBoxArray.prototype = Object.create(StructArrayLayout6i1ul2ui2i24 && StructArrayLayout6i1ul2ui2i24.prototype);
        CollisionBoxArray.prototype.constructor = CollisionBoxArray;

        CollisionBoxArray.prototype.get = function get(index) {
            return new struct.CollisionBoxStruct(this, index);
        };

        return CollisionBoxArray;
    }(f.StructArrayLayout6i1ul2ui2i24);

    f.CollisionBoxArray = array;

    array = function (StructArrayLayout1f4) {
        function GlyphOffsetArray() {
            StructArrayLayout1f4.apply(this, arguments);
        }

        if (StructArrayLayout1f4) GlyphOffsetArray.__proto__ = StructArrayLayout1f4;
        GlyphOffsetArray.prototype = Object.create(StructArrayLayout1f4 && StructArrayLayout1f4.prototype);
        GlyphOffsetArray.prototype.constructor = GlyphOffsetArray;

        GlyphOffsetArray.prototype.getoffsetX = function getoffsetX(index) {
            return this.float32[index * 1 + 0];
        };
        /**
         * Return the GlyphOffsetStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        GlyphOffsetArray.prototype.get = function get(index) {
            return new GlyphOffsetStruct(this, index);
        };

        return GlyphOffsetArray;
    }(f.StructArrayLayout1f4);
    f.GlyphOffsetArray = array;

    var SymbolLineVertexArray = (function (StructArrayLayout3i6) {
        function SymbolLineVertexArray() {
            StructArrayLayout3i6.apply(this, arguments);
        }

        if (StructArrayLayout3i6) SymbolLineVertexArray.__proto__ = StructArrayLayout3i6;
        SymbolLineVertexArray.prototype = Object.create(StructArrayLayout3i6 && StructArrayLayout3i6.prototype);
        SymbolLineVertexArray.prototype.constructor = SymbolLineVertexArray;

        SymbolLineVertexArray.prototype.getx = function getx(index) {
            return this.int16[index * 3 + 0];
        };
        SymbolLineVertexArray.prototype.gety = function gety(index) {
            return this.int16[index * 3 + 1];
        };
        SymbolLineVertexArray.prototype.gettileUnitDistanceFromAnchor = function gettileUnitDistanceFromAnchor(index) {
            return this.int16[index * 3 + 2];
        };
        /**
         * Return the SymbolLineVertexStruct at the given location in the array.
         * @param {number} index The index of the element.
         */
        SymbolLineVertexArray.prototype.get = function get(index) {
            return new SymbolLineVertexStruct(this, index);
        };

        return SymbolLineVertexArray;
    }(f.StructArrayLayout3i6));
    f.SymbolLineVertexArray = SymbolLineVertexArray;

    array = (function (StructArrayLayout6i9ui1ul2f44) {
        function SymbolInstanceArray() {
            StructArrayLayout6i9ui1ul2f44.apply(this, arguments);
        }

        if (StructArrayLayout6i9ui1ul2f44) SymbolInstanceArray.__proto__ = StructArrayLayout6i9ui1ul2f44;
        SymbolInstanceArray.prototype = Object.create(StructArrayLayout6i9ui1ul2f44 && StructArrayLayout6i9ui1ul2f44.prototype);
        SymbolInstanceArray.prototype.constructor = SymbolInstanceArray;

        SymbolInstanceArray.prototype.get = function get(index) {
            return new struct.SymbolInstanceStruct(this, index);
        };

        return SymbolInstanceArray;
    }(f.StructArrayLayout6i9ui1ul2f44));
    f.SymbolInstanceArray = array;


    array = (function (StructArrayLayout1ul2ui8) {
        function FeatureIndexArray() {
            StructArrayLayout1ul2ui8.apply(this, arguments);
        }

        if (StructArrayLayout1ul2ui8) FeatureIndexArray.__proto__ = StructArrayLayout1ul2ui8;
        FeatureIndexArray.prototype = Object.create(StructArrayLayout1ul2ui8 && StructArrayLayout1ul2ui8.prototype);
        FeatureIndexArray.prototype.constructor = FeatureIndexArray;

        FeatureIndexArray.prototype.get = function get(index) {
            return new struct.FeatureIndexStruct(this, index);
        };

        return FeatureIndexArray;
    }(f.StructArrayLayout1ul2ui8));
    f.FeatureIndexArray = array;

    array = (function (StructArray) {
        function StructArrayLayout2f8() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2f8.__proto__ = StructArray;
        StructArrayLayout2f8.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2f8.prototype.constructor = StructArrayLayout2f8;

        StructArrayLayout2f8.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout2f8.prototype.emplaceBack = function emplaceBack(v0, v1) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1);
        };

        StructArrayLayout2f8.prototype.emplace = function emplace(i, v0, v1) {
            var o4 = i * 2;
            this.float32[o4 + 0] = v0;
            this.float32[o4 + 1] = v1;
            return i;
        };

        return StructArrayLayout2f8;
    }(e));

    array.prototype.bytesPerElement = 8;
    f.StructArrayLayout2f8 = array;

    array = (function (StructArray) {
        function StructArrayLayout5fb20() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout5fb20.__proto__ = StructArray;
        StructArrayLayout5fb20.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout5fb20.prototype.constructor = StructArrayLayout5fb20;

        StructArrayLayout5fb20.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout5fb20.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4);
        };

        StructArrayLayout5fb20.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4) {
            var o4 = i * 5;
            this.float32[o4 + 0] = v0;
            this.float32[o4 + 1] = v1;
            this.float32[o4 + 2] = v2;
            this.float32[o4 + 3] = v3;
            this.float32[o4 + 4] = v4;
            return i;
        };

        return StructArrayLayout5fb20;
    }(e));

    array.prototype.bytesPerElement = 20;
    f.StructArrayLayout5fb20 = array;

    array = (function (StructArray) {
        function StructArrayLayout4f16() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout4f16.__proto__ = StructArray;
        StructArrayLayout4f16.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout4f16.prototype.constructor = StructArrayLayout4f16;

        StructArrayLayout4f16.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.float32 = new Float32Array(this.arrayBuffer);
        };

        StructArrayLayout4f16.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3);
        };

        StructArrayLayout4f16.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
            var o4 = i * 4;
            this.float32[o4 + 0] = v0;
            this.float32[o4 + 1] = v1;
            this.float32[o4 + 2] = v2;
            this.float32[o4 + 3] = v3;
            return i;
        };

        return StructArrayLayout4f16;
    }(e));

    array.prototype.bytesPerElement = 16;
    f.StructArrayLayout4f16 = array;

    array = (function (StructArray) {
        function StructArrayLayout8ui16() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout8ui16.__proto__ = StructArray;
        StructArrayLayout8ui16.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout8ui16.prototype.constructor = StructArrayLayout8ui16;

        StructArrayLayout8ui16.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.uint16 = new Uint16Array(this.arrayBuffer);
        };

        StructArrayLayout8ui16.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5, v6, v7) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5, v6, v7);
        };

        StructArrayLayout8ui16.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5, v6, v7) {
            var o2 = i * 8;
            this.uint16[o2 + 0] = v0;
            this.uint16[o2 + 1] = v1;
            this.uint16[o2 + 2] = v2;
            this.uint16[o2 + 3] = v3;
            this.uint16[o2 + 4] = v4;
            this.uint16[o2 + 5] = v5;
            this.uint16[o2 + 6] = v6;
            this.uint16[o2 + 7] = v7;
            return i;
        };

        return StructArrayLayout8ui16;
    }(e));

    array.prototype.bytesPerElement = 16;
    f.StructArrayLayout8ui16 = array;

    f.PlacedSymbolArray = function (StructArrayLayout2i2ui3ul3ui2f2ub1ul44) {
        function PlacedSymbolArray() {
            StructArrayLayout2i2ui3ul3ui2f2ub1ul44.apply(this, arguments);
        }

        if (StructArrayLayout2i2ui3ul3ui2f2ub1ul44) PlacedSymbolArray.__proto__ = StructArrayLayout2i2ui3ul3ui2f2ub1ul44;
        PlacedSymbolArray.prototype = Object.create(StructArrayLayout2i2ui3ul3ui2f2ub1ul44 && StructArrayLayout2i2ui3ul3ui2f2ub1ul44.prototype);
        PlacedSymbolArray.prototype.constructor = PlacedSymbolArray;
        PlacedSymbolArray.prototype.get = function get(index) {
            return new struct.PlacedSymbolStruct(this, index);
        };
        return PlacedSymbolArray;
    }(f.StructArrayLayout2i2ui3ul3ui2f2ub1ul44);

    array = (function (StructArray) {
        function StructArrayLayout2i4i12() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout2i4i12.__proto__ = StructArray;
        StructArrayLayout2i4i12.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout2i4i12.prototype.constructor = StructArrayLayout2i4i12;

        StructArrayLayout2i4i12.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
        };

        StructArrayLayout2i4i12.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3, v4, v5) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3, v4, v5);
        };

        StructArrayLayout2i4i12.prototype.emplace = function emplace(i, v0, v1, v2, v3, v4, v5) {
            var o2 = i * 6;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            this.int16[o2 + 3] = v3;
            this.int16[o2 + 4] = v4;
            this.int16[o2 + 5] = v5;
            return i;
        };

        return StructArrayLayout2i4i12;
    }(e));
    array.prototype.bytesPerElement = 12;
    f.StructArrayLayout2i4i12 = array;

    array = (function (StructArray) {
        function StructArrayLayout4i8() {
            StructArray.apply(this, arguments);
        }

        if (StructArray) StructArrayLayout4i8.__proto__ = StructArray;
        StructArrayLayout4i8.prototype = Object.create(StructArray && StructArray.prototype);
        StructArrayLayout4i8.prototype.constructor = StructArrayLayout4i8;

        StructArrayLayout4i8.prototype._refreshViews = function _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
            this.int16 = new Int16Array(this.arrayBuffer);
        };

        StructArrayLayout4i8.prototype.emplaceBack = function emplaceBack(v0, v1, v2, v3) {
            var i = this.length;
            this.resize(i + 1);
            return this.emplace(i, v0, v1, v2, v3);
        };

        StructArrayLayout4i8.prototype.emplace = function emplace(i, v0, v1, v2, v3) {
            var o2 = i * 4;
            this.int16[o2 + 0] = v0;
            this.int16[o2 + 1] = v1;
            this.int16[o2 + 2] = v2;
            this.int16[o2 + 3] = v3;
            return i;
        };
        return StructArrayLayout4i8;
    }(e));

    array.prototype.bytesPerElement = 8;
    f.StructArrayLayout4i8 = array;


});
},
'com/huayun/webgis/gl/GridIndex':function(){
define([], function () {
    var NUM_PARAMS = 3;

    function GridIndex(extent, n, padding) {
        var cells = this.cells = [];
        if (extent instanceof ArrayBuffer) {
            this.arrayBuffer = extent;
            var array = new Int32Array(this.arrayBuffer);
            extent = array[0];
            n = array[1];
            padding = array[2];

            this.d = n + 2 * padding;
            for (var k = 0; k < this.d * this.d; k++) {
                var start = array[NUM_PARAMS + k];
                var end = array[NUM_PARAMS + k + 1];
                cells.push(start === end ?
                    null :
                    array.subarray(start, end));
            }
            var keysOffset = array[NUM_PARAMS + cells.length];
            var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
            this.keys = array.subarray(keysOffset, bboxesOffset);
            this.bboxes = array.subarray(bboxesOffset);
            this.insert = this._insertReadonly;
        } else {
            this.d = n + 2 * padding;
            for (var i = 0; i < this.d * this.d; i++) {
                cells.push([]);
            }
            this.keys = [];
            this.bboxes = [];
        }
        this.n = n;
        this.extent = extent;
        this.padding = padding;
        this.scale = n / extent;
        this.uid = 0;
        var p = (padding / n) * extent;
        this.min = -p;
        this.max = extent + p;
    }

    GridIndex.prototype.insert = function (key, x1, y1, x2, y2) {
        this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
        this.keys.push(key);
        this.bboxes.push(x1);
        this.bboxes.push(y1);
        this.bboxes.push(x2);
        this.bboxes.push(y2);
    };

    GridIndex.prototype._insertReadonly = function () {
        throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
    };

    GridIndex.prototype._insertCell = function (x1, y1, x2, y2, cellIndex, uid) {
        this.cells[cellIndex].push(uid);
    };

    GridIndex.prototype.query = function (x1, y1, x2, y2, intersectionTest) {
        var min = this.min;
        var max = this.max;
        if (x1 <= min && y1 <= min && max <= x2 && max <= y2 && !intersectionTest) {
            return Array.prototype.slice.call(this.keys);

        } else {
            var result = [];
            var seenUids = {};
            this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids, intersectionTest);
            return result;
        }
    };

    GridIndex.prototype._queryCell = function (x1, y1, x2, y2, cellIndex, result, seenUids, intersectionTest) {
        var cell = this.cells[cellIndex];
        if (cell !== null) {
            var keys = this.keys;
            var bboxes = this.bboxes;
            for (var u = 0; u < cell.length; u++) {
                var uid = cell[u];
                if (seenUids[uid] === undefined) {
                    var offset = uid * 4;
                    if (intersectionTest ? intersectionTest(bboxes[offset + 0], bboxes[offset + 1], bboxes[offset + 2], bboxes[offset + 3]) :
                        ((x1 <= bboxes[offset + 2]) && (y1 <= bboxes[offset + 3]) && (x2 >= bboxes[offset + 0]) && (y2 >= bboxes[offset + 1]))) {
                        seenUids[uid] = true;
                        result.push(keys[uid]);
                    } else {
                        seenUids[uid] = false;
                    }
                }
            }
        }
    };

    GridIndex.prototype._forEachCell = function (x1, y1, x2, y2, fn, arg1, arg2, intersectionTest) {
        var cx1 = this._convertToCellCoord(x1);
        var cy1 = this._convertToCellCoord(y1);
        var cx2 = this._convertToCellCoord(x2);
        var cy2 = this._convertToCellCoord(y2);
        for (var x = cx1; x <= cx2; x++) {
            for (var y = cy1; y <= cy2; y++) {
                var cellIndex = this.d * y + x;
                if (intersectionTest && !intersectionTest(this._convertFromCellCoord(x), this._convertFromCellCoord(y), this._convertFromCellCoord(x + 1), this._convertFromCellCoord(y + 1))) {
                    continue;
                }
                if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, intersectionTest)) {
                    return;
                }
            }
        }
    };

    GridIndex.prototype._convertFromCellCoord = function (x) {
        return (x - this.padding) / this.scale;
    };

    GridIndex.prototype._convertToCellCoord = function (x) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
    };

    GridIndex.prototype.toArrayBuffer = function () {
        if (this.arrayBuffer) {
            return this.arrayBuffer;
        }
        var cells = this.cells;
        var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
        var totalCellLength = 0;
        for (var i = 0; i < this.cells.length; i++) {
            totalCellLength += this.cells[i].length;
        }

        var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
        array[0] = this.extent;
        array[1] = this.n;
        array[2] = this.padding;

        var offset = metadataLength;
        for (var k = 0; k < cells.length; k++) {
            var cell = cells[k];
            array[NUM_PARAMS + k] = offset;
            array.set(cell, offset);
            offset += cell.length;
        }

        array[NUM_PARAMS + cells.length] = offset;
        array.set(this.keys, offset);
        offset += this.keys.length;

        array[NUM_PARAMS + cells.length + 1] = offset;
        array.set(this.bboxes, offset);
        offset += this.bboxes.length;

        return array.buffer;
    };

    return GridIndex;
});
},
'com/huayun/webgis/gl/constantBinder':function(){
define([
    "exports",
    "./uniform",
    "./dataTransfer",
    "../layers/support/EvaluationParameters",
    "../utils/utils"
], function (exports, uniform, dataTransfer, EvaluationParameters, utils) {

    var ConstantBinder = function ConstantBinder(value, names, type) {
        this.value = value;
        this.names = names;
        this.uniformNames = this.names.map(function (name) {
            return ("u_" + name);
        });
        this.type = type;
        this.maxValue = -Infinity;
    };

    ConstantBinder.prototype.defines = function defines() {
        return this.names.map(function (name) {
            return ("#define HAS_UNIFORM_u_" + name);
        });
    };
    ConstantBinder.prototype.setConstantPatternPositions = function setConstantPatternPositions() {
    };
    ConstantBinder.prototype.populatePaintArray = function populatePaintArray() {
    };
    ConstantBinder.prototype.updatePaintArray = function updatePaintArray() {
    };
    ConstantBinder.prototype.upload = function upload() {
    };
    ConstantBinder.prototype.destroy = function destroy() {
    };

    ConstantBinder.prototype.setUniforms = function setUniforms(context, uniform, globals,
                                                                currentValue) {
        uniform.set(currentValue.constantOr(this.value));
    };

    ConstantBinder.prototype.setUniform = function setUniform(context, uniform, value) {
        uniform.set(value);
    };

    ConstantBinder.prototype.getBinding = function getBinding(context, location) {
        return (this.type === 'color') ?
            new uniform.UniformColor(context, location) :
            new uniform.Uniform1f(context, location);
    };

    ConstantBinder.serialize = function serialize$1(binder) {
        var value = binder.value;
        var names = binder.names;
        var type = binder.type;
        return {value: dataTransfer.serialize(value), names: names, type: type};
    };

    ConstantBinder.deserialize = function deserialize$1(serialized) {
        var value = serialized.value;
        var names = serialized.names;
        var type = serialized.type;
        return new ConstantBinder(dataTransfer.deserialize(value), names, type);
    };

    var CrossFadedConstantBinder = function CrossFadedConstantBinder(value, names, type) {
        this.value = value;
        this.names = names;
        this.uniformNames = this.names.map(function (name) {
            return ("u_" + name);
        });
        this.type = type;
        this.maxValue = -Infinity;
        this.patternPositions = {patternTo: null, patternFrom: null};
    };

    CrossFadedConstantBinder.prototype.defines = function defines() {
        return this.names.map(function (name) {
            return ("#define HAS_UNIFORM_u_" + name);
        });
    };

    CrossFadedConstantBinder.prototype.populatePaintArray = function populatePaintArray() {
    };
    CrossFadedConstantBinder.prototype.updatePaintArray = function updatePaintArray() {
    };
    CrossFadedConstantBinder.prototype.upload = function upload() {
    };
    CrossFadedConstantBinder.prototype.destroy = function destroy() {
    };

    CrossFadedConstantBinder.prototype.setConstantPatternPositions = function setConstantPatternPositions(posTo, posFrom) {
        this.patternPositions.patternTo = posTo.tlbr;
        this.patternPositions.patternFrom = posFrom.tlbr;
    };

    CrossFadedConstantBinder.prototype.setUniforms = function setUniforms(context, uniform, globals,
                                                                          currentValue, uniformName) {
        var pos = this.patternPositions;
        if (uniformName === "u_pattern_to" && pos.patternTo) {
            uniform.set(pos.patternTo);
        }
        if (uniformName === "u_pattern_from" && pos.patternFrom) {
            uniform.set(pos.patternFrom);
        }
    };

    CrossFadedConstantBinder.prototype.getBinding = function getBinding(context, location) {
        return new uniform.Uniform4f(context, location);
    };

    var SourceExpressionBinder = function SourceExpressionBinder(expression, names, type, PaintVertexArray) {
        this.expression = expression;
        this.names = names;
        this.type = type;
        this.uniformNames = this.names.map(function (name) {
            return ("a_" + name);
        });
        this.maxValue = -Infinity;
        this.paintVertexAttributes = names.map(function (name) {
                return ({
                    name: ("a_" + name),
                    type: 'Float32',
                    components: type === 'color' ? 2 : 1,
                    offset: 0
                });
            }
        );
        this.paintVertexArray = new PaintVertexArray();
    };

    SourceExpressionBinder.prototype.defines = function defines() {
        return [];
    };

    SourceExpressionBinder.prototype.setConstantPatternPositions = function setConstantPatternPositions() {
    };

    SourceExpressionBinder.prototype.populatePaintArray = function populatePaintArray(newLength, feature) {
        var paintArray = this.paintVertexArray;

        var start = paintArray.length;
        paintArray.reserve(newLength);

        var value = this.expression.evaluate(new EvaluationParameters(0), feature, {});

        if (this.type === 'color') {
            var color = utils.packColor(value);
            for (var i = start; i < newLength; i++) {
                paintArray.emplaceBack(color[0], color[1]);
            }
        } else {
            for (var i$1 = start; i$1 < newLength; i$1++) {
                paintArray.emplaceBack(value);
            }

            this.maxValue = Math.max(this.maxValue, value);
        }
    };

    SourceExpressionBinder.prototype.updatePaintArray = function updatePaintArray(start, end, feature, featureState) {
        var paintArray = this.paintVertexArray;
        var value = this.expression.evaluate({zoom: 0}, feature, featureState);

        if (this.type === 'color') {
            var color = utils.packColor(value);
            for (var i = start; i < end; i++) {
                paintArray.emplace(i, color[0], color[1]);
            }
        } else {
            for (var i$1 = start; i$1 < end; i$1++) {
                paintArray.emplace(i$1, value);
            }

            this.maxValue = Math.max(this.maxValue, value);
        }
    };

    SourceExpressionBinder.prototype.upload = function upload(context) {
        if (this.paintVertexArray && this.paintVertexArray.arrayBuffer) {
            if (this.paintVertexBuffer && this.paintVertexBuffer.buffer) {
                this.paintVertexBuffer.updateData(this.paintVertexArray);
            } else {
                this.paintVertexBuffer = context.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent);
            }
        }
    };

    SourceExpressionBinder.prototype.destroy = function destroy() {
        if (this.paintVertexBuffer) {
            this.paintVertexBuffer.destroy();
        }
    };

    SourceExpressionBinder.prototype.setUniforms = function setUniforms(context, uniform) {
        uniform.set(0);
    };

    SourceExpressionBinder.prototype.getBinding = function getBinding(context, location) {
        return new uniform.Uniform1f(context, location);
    };

    var CompositeExpressionBinder = function CompositeExpressionBinder(expression, names, type, useIntegerZoom, zoom, layout) {
        this.expression = expression;
        this.names = names;
        this.uniformNames = this.names.map(function (name) {
            return ("u_" + name + "_t");
        });
        this.type = type;
        this.useIntegerZoom = useIntegerZoom;
        this.zoom = zoom;
        this.maxValue = -Infinity;
        var PaintVertexArray = layout;
        this.paintVertexAttributes = names.map(function (name) {
            return {
                name: ("a_" + name),
                type: 'Float32',
                components: type === 'color' ? 4 : 2,
                offset: 0
            };
        });
        this.paintVertexArray = new PaintVertexArray();
    };

    CompositeExpressionBinder.prototype.defines = function defines() {
        return [];
    };

    CompositeExpressionBinder.prototype.setConstantPatternPositions = function setConstantPatternPositions() {
    };

    CompositeExpressionBinder.prototype.populatePaintArray = function populatePaintArray(newLength, feature) {
        var paintArray = this.paintVertexArray;

        var start = paintArray.length;
        paintArray.reserve(newLength);

        var min = this.expression.evaluate(new EvaluationParameters(this.zoom), feature, {});
        var max = this.expression.evaluate(new EvaluationParameters(this.zoom + 1), feature, {});

        if (this.type === 'color') {
            var minColor = utils.packColor(min);
            var maxColor = utils.packColor(max);
            for (var i = start; i < newLength; i++) {
                paintArray.emplaceBack(minColor[0], minColor[1], maxColor[0], maxColor[1]);
            }
        } else {
            for (var i$1 = start; i$1 < newLength; i$1++) {
                paintArray.emplaceBack(min, max);
            }
            this.maxValue = Math.max(this.maxValue, min, max);
        }
    };

    CompositeExpressionBinder.prototype.updatePaintArray = function updatePaintArray(start, end, feature, featureState) {
        var paintArray = this.paintVertexArray;

        var min = this.expression.evaluate({zoom: this.zoom}, feature, featureState);
        var max = this.expression.evaluate({zoom: this.zoom + 1}, feature, featureState);

        if (this.type === 'color') {
            var minColor = utils.packColor(min);
            var maxColor = utils.packColor(max);
            for (var i = start; i < end; i++) {
                paintArray.emplace(i, minColor[0], minColor[1], maxColor[0], maxColor[1]);
            }
        } else {
            for (var i$1 = start; i$1 < end; i$1++) {
                paintArray.emplace(i$1, min, max);
            }
            this.maxValue = Math.max(this.maxValue, min, max);
        }
    };

    CompositeExpressionBinder.prototype.upload = function upload(context) {
        if (this.paintVertexArray && this.paintVertexArray.arrayBuffer) {
            if (this.paintVertexBuffer && this.paintVertexBuffer.buffer) {
                this.paintVertexBuffer.updateData(this.paintVertexArray);
            } else {
                this.paintVertexBuffer = context.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent);
            }
        }
    };

    CompositeExpressionBinder.prototype.destroy = function destroy() {
        if (this.paintVertexBuffer) {
            this.paintVertexBuffer.destroy();
        }
    };

    CompositeExpressionBinder.prototype.interpolationFactor = function interpolationFactor(currentZoom) {
        if (this.useIntegerZoom) {
            return this.expression.interpolationFactor(Math.floor(currentZoom), this.zoom, this.zoom + 1);
        } else {
            return this.expression.interpolationFactor(currentZoom, this.zoom, this.zoom + 1);
        }
    };

    CompositeExpressionBinder.prototype.setUniforms = function setUniforms(context, uniform,
                                                                           globals) {
        uniform.set(this.interpolationFactor(globals.zoom));
    };

    CompositeExpressionBinder.prototype.getBinding = function getBinding(context, location) {
        return new uniform.Uniform1f(context, location);
    };

    var CrossFadedCompositeBinder = function CrossFadedCompositeBinder(expression, names, type, useIntegerZoom, zoom, PaintVertexArray, layerId) {

        this.expression = expression;
        this.names = names;
        this.type = type;
        this.uniformNames = this.names.map(function (name) {
            return ("u_" + name + "_t");
        });
        this.useIntegerZoom = useIntegerZoom;
        this.zoom = zoom;
        this.maxValue = -Infinity;
        this.layerId = layerId;

        this.paintVertexAttributes = names.map(function (name) {
                return ({
                    name: ("a_" + name),
                    type: 'Uint16',
                    components: 4,
                    offset: 0
                });
            }
        );

        this.zoomInPaintVertexArray = new PaintVertexArray();
        this.zoomOutPaintVertexArray = new PaintVertexArray();
    };

    CrossFadedCompositeBinder.prototype.defines = function defines() {
        return [];
    };

    CrossFadedCompositeBinder.prototype.setConstantPatternPositions = function setConstantPatternPositions() {
    };

    CrossFadedCompositeBinder.prototype.populatePaintArray = function populatePaintArray(length, feature, imagePositions) {
        // We populate two paint arrays because, for cross-faded properties, we don't know which direction
        // we're cross-fading to at layout time. In order to keep vertex attributes to a minimum and not pass
        // unnecessary vertex data to the shaders, we determine which to upload at draw time.

        var zoomInArray = this.zoomInPaintVertexArray;
        var zoomOutArray = this.zoomOutPaintVertexArray;
        var ref = this;
        var layerId = ref.layerId;
        var start = zoomInArray.length;

        zoomInArray.reserve(length);
        zoomOutArray.reserve(length);

        if (imagePositions && feature.patterns && feature.patterns[layerId]) {
            var ref$1 = feature.patterns[layerId];
            var min = ref$1.min;
            var mid = ref$1.mid;
            var max = ref$1.max;

            var imageMin = imagePositions[min];
            var imageMid = imagePositions[mid];
            var imageMax = imagePositions[max];

            if (!imageMin || !imageMid || !imageMax) {
                return;
            }

            for (var i = start; i < length; i++) {
                zoomInArray.emplaceBack(
                    imageMid.tl[0], imageMid.tl[1], imageMid.br[0], imageMid.br[1],
                    imageMin.tl[0], imageMin.tl[1], imageMin.br[0], imageMin.br[1]
                );

                zoomOutArray.emplaceBack(
                    imageMid.tl[0], imageMid.tl[1], imageMid.br[0], imageMid.br[1],
                    imageMax.tl[0], imageMax.tl[1], imageMax.br[0], imageMax.br[1]
                );
            }
        }
    };

    CrossFadedCompositeBinder.prototype.updatePaintArray = function updatePaintArray(start, end, feature, featureState, imagePositions) {
        // We populate two paint arrays because, for cross-faded properties, we don't know which direction
        // we're cross-fading to at layout time. In order to keep vertex attributes to a minimum and not pass
        // unnecessary vertex data to the shaders, we determine which to upload at draw time.

        var zoomInArray = this.zoomInPaintVertexArray;
        var zoomOutArray = this.zoomOutPaintVertexArray;
        var ref = this;
        var layerId = ref.layerId;

        if (imagePositions && feature.patterns && feature.patterns[layerId]) {
            var ref$1 = feature.patterns[layerId];
            var min = ref$1.min;
            var mid = ref$1.mid;
            var max = ref$1.max;
            var imageMin = imagePositions[min];
            var imageMid = imagePositions[mid];
            var imageMax = imagePositions[max];

            if (!imageMin || !imageMid || !imageMax) {
                return;
            }
            for (var i = start; i < end; i++) {
                zoomInArray.emplace(i,
                    imageMid.tl[0], imageMid.tl[1], imageMid.br[0], imageMid.br[1],
                    imageMin.tl[0], imageMin.tl[1], imageMin.br[0], imageMin.br[1]
                );

                zoomOutArray.emplace(i,
                    imageMid.tl[0], imageMid.tl[1], imageMid.br[0], imageMid.br[1],
                    imageMax.tl[0], imageMax.tl[1], imageMax.br[0], imageMax.br[1]
                );
            }
        }
    };

    CrossFadedCompositeBinder.prototype.upload = function upload(context) {
        if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
            this.zoomInPaintVertexBuffer = context.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent);
            this.zoomOutPaintVertexBuffer = context.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent);
        }
    };

    CrossFadedCompositeBinder.prototype.destroy = function destroy() {
        if (this.zoomOutPaintVertexBuffer) {
            this.zoomOutPaintVertexBuffer.destroy();
        }
        if (this.zoomInPaintVertexBuffer) {
            this.zoomInPaintVertexBuffer.destroy();
        }

    };

    CrossFadedCompositeBinder.prototype.setUniforms = function setUniforms(context, uniform) {
        uniform.set(0);
    };

    CrossFadedCompositeBinder.prototype.getBinding = function getBinding(context, location) {
        return new uniform.Uniform1f(context, location);
    };

    console.log('ConstantBinder');
    dataTransfer.register('ConstantBinder', ConstantBinder);
    dataTransfer.register('CrossFadedConstantBinder', CrossFadedConstantBinder);
    dataTransfer.register('SourceExpressionBinder', SourceExpressionBinder);
    dataTransfer.register('CrossFadedCompositeBinder', CrossFadedCompositeBinder);
    dataTransfer.register('CompositeExpressionBinder', CompositeExpressionBinder);

    exports.ConstantBinder = ConstantBinder;
    exports.CrossFadedConstantBinder = CrossFadedConstantBinder;
    exports.SourceExpressionBinder = SourceExpressionBinder;
    exports.CrossFadedCompositeBinder = CrossFadedCompositeBinder;
    exports.CompositeExpressionBinder = CompositeExpressionBinder;



});
},
'com/huayun/webgis/layers/support/style/PossiblyEvaluatedPropertyValue':function(){
define([], function () {
  /**
   * data-drivenpaintlayout, PossiblyEvaluatedValuevalueGlobalProperties, .
   * @ignore
   * @private
   * @alias com.huayun.webgis.layers.support.style.PossiblyEvaluatedPropertyValue
   * @param property
   * @param value
   * @param parameters
   * @constructor
   * @property value
   */
  var PossiblyEvaluatedPropertyValue = function PossiblyEvaluatedPropertyValue(property, value, parameters) {
    this.property = property;
    this.value = value;
    this.parameters = parameters;
  };

  PossiblyEvaluatedPropertyValue.prototype.isConstant = function isConstant() {
    return this.value.kind === 'constant';
  };
  /**
   * , 
   * @param value
   * @return {*}
   */
  PossiblyEvaluatedPropertyValue.prototype.constantOr = function constantOr(value) {
    if (this.value.kind === 'constant') {
      return this.value.value;
    } else {
      return value;
    }
  };

  /**
   * Feature
   * @param feature
   * @param featureState
   * @return {*}
   */
  PossiblyEvaluatedPropertyValue.prototype.evaluate = function evaluate(feature, featureState) {
    return this.property.evaluate(this.value, this.parameters, feature, featureState);
  };
  
  return PossiblyEvaluatedPropertyValue;
});
},
'com/huayun/webgis/BaseMap':function(){
define([], 1);

},
'com/huayun/webgis/facade/MapConfigFacade':function(){
define(
    [
        "dojo/_base/declare",
        "dojo/request"
    ], function (declare, request) {

        return declare("com.huayun.webgis.facade.MapConfigFacade", null, {
            url:"",

            constructor: function (params) {
                this._url = params.url;
            },
            /**
             * 
             * @param result
             * @param fault
             */
            getMapConfigData:function (result,fault) {
                request.get(this._url,{handleAs:"json"}).then(function (data) {
                    result(data);
                },function (err) {
                    fault(err);
                });
            }
        });
    });
},
'dojo/request/default':function(){
define([
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if( 1  || has('host-webworker')){
		platformId = './xhr';
	}else if( 0 ){
		platformId = './node';
	/* TODO:
	}else if( 0 ){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});

},
'com/huayun/webgis/data/FeaturePositionMap':function(){
define([
    "../utils/utils"
], function (utils) {
    var FeaturePositionMap = function FeaturePositionMap() {
        this.ids = [];
        this.positions = [];
        this.indexed = false;
    };

    FeaturePositionMap.prototype.add = function add(id, index, start, end) {
        this.ids.push(id);
        this.positions.push(index, start, end);
    };

    FeaturePositionMap.prototype.getPositions = function getPositions(id) {
        var i = 0;
        var j = this.ids.length - 1;
        while (i < j) {
            var m = (i + j) >> 1;
            if (this.ids[m] >= id) {
                j = m;
            } else {
                i = m + 1;
            }
        }
        var positions = [];
        while (this.ids[i] === id) {
            var index = this.positions[3 * i];
            var start = this.positions[3 * i + 1];
            var end = this.positions[3 * i + 2];
            positions.push({index: index, start: start, end: end});
            i++;
        }
        return positions;
    };

    FeaturePositionMap.serialize = function serialize(map, transferables) {
        var ids = new Float64Array(map.ids);
        var positions = new Uint32Array(map.positions);
        utils.sort(ids, positions, 0, ids.length - 1);
        transferables.push(ids.buffer, positions.buffer);
        return {ids: ids, positions: positions};
    };

    FeaturePositionMap.deserialize = function deserialize(obj) {
        var map = new FeaturePositionMap();
        map.ids = (obj.ids);
        map.positions = (obj.positions);
        map.indexed = true;
        return map;
    };

    return FeaturePositionMap;
});
},
'com/huayun/webgis/data/GraphicIndex':function(){
define([
    "custom/rbush",
    "./queryIntersects",
    "./queryIntersectsEx",
    "./captureIntersects"
], function (rbush, queryIntersects, queryIntersectsEx, captureIntersects) {

    function getBounds(geometry) {
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0, list = geometry; i < list.length; i += 1) {
            var p = list[i];
            if(p.type === "point"){
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            } else if(p.type === "polygon") {
                for (var j = 0, point = p.path[0]; j < point.length; j++) {
                    minX = Math.min(minX, point[j].x);
                    minY = Math.min(minY, point[j].y);
                    maxX = Math.max(maxX, point[j].x);
                    maxY = Math.max(maxY, point[j].y);  
                }
            }
        }
        return {minx: minX, miny: minY, maxx: maxX, maxy: maxY};
    }

    var GraphicIndex = function () {
        this.tree = new rbush;
    };

    GraphicIndex.prototype.insert = function (geometry, graphicId) {
        var items = [];
        for (var i = 0; i < geometry.length; i++) {
            var ring = geometry[i];
            var bbox = [Infinity, Infinity, -Infinity, -Infinity];
            for (var j = 0; j < ring.length; j++) {
                var p = ring[j];
                bbox[0] = Math.min(bbox[0], p.x);
                bbox[1] = Math.min(bbox[1], p.y);
                bbox[2] = Math.max(bbox[2], p.x);
                bbox[3] = Math.max(bbox[3], p.y);
            }
            items.push({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
                id: graphicId
            });
        }
        this.tree.load(items);
    };

    GraphicIndex.prototype.insertMsc = function (geometry, graphicId) {
        var items = [];
        for (var i = 0; i < geometry.length; i++) {
            var ring = geometry[i];
            var bbox = [Infinity, Infinity, -Infinity, -Infinity];
            for (var j = 0; j < ring.length; j++) {
                var p = ring[j];
                bbox[0] = Math.min(bbox[0], p.x);
                bbox[1] = Math.min(bbox[1], p.y);
                bbox[2] = Math.max(bbox[2], p.x);
                bbox[3] = Math.max(bbox[3], p.y);
            }
            items.push({
                minX: bbox[0],
                minY: bbox[1],
                maxX: bbox[2],
                maxY: bbox[3],
                id: graphicId
            });
        }
        this.tree.load(items);
    };

    GraphicIndex.prototype.query = function (geometry, queryPadding, graphics, resolution, viewpoint) {
        var bounds = getBounds(geometry);
        var matching = this.tree.search({
            minX: bounds.minx - queryPadding * resolution,
            minY: bounds.miny - queryPadding * resolution,
            maxX: bounds.maxx + queryPadding * resolution,
            maxY: bounds.maxy + queryPadding * resolution
        });
        var g;
        var result = [];
        for (var i = 0; i < matching.length; i++) {
            for (var j = 0; j < graphics.length; j++) {
                if (matching[i].id === graphics[j].id) {
                    g = graphics[j];
                    if (g.feature.geometry.type === "multipoint") {
                        for (var k = 0, kk = g.feature.geometry.points.length; k < kk ; k++) {
                            var p = g.feature.geometry.points[k];
                            if (queryIntersects[g.symbol.type](geometry, p, g.symbol, resolution, g.feature.geometry.radius, viewpoint)) {
                                result.push(g);
                                break;
                            }
                        }
                    } else {
                        if (queryIntersects[g.symbol.type](geometry, g.feature.geometry, g.symbol, resolution, g.feature.geometry.radius, viewpoint)) {
                            result.push(g);
                        }
                    }
                }
            }
        }
        return result;
    };

    GraphicIndex.prototype.roughQuery = function (geometry, queryPadding, graphics, resolution, viewpoint) {
        var bounds = getBounds(geometry);
        var matching = this.tree.search({
            minX: bounds.minx - queryPadding * resolution,
            minY: bounds.miny - queryPadding * resolution,
            maxX: bounds.maxx + queryPadding * resolution,
            maxY: bounds.maxy + queryPadding * resolution
        });
        var g;
        var result = [];
        for (var i = 0; i < matching.length; i++) {
            for (var j = 0; j < graphics.length; j++) {
                if (matching[i].id === graphics[j].id) {
                    g = graphics[j];
                    result.push(g);
                }
            }
        }
        return result;
    };

    GraphicIndex.prototype.captureQuery = function (geometry, queryPadding, graphics, resolution, viewpoint) {
        var bounds = getBounds(geometry);
        var matching = this.tree.search({
            minX: bounds.minx - queryPadding * resolution,
            minY: bounds.miny - queryPadding * resolution,
            maxX: bounds.maxx + queryPadding * resolution,
            maxY: bounds.maxy + queryPadding * resolution
        });
        var g;
        var result = [];
        for (var i = 0; i < matching.length; i++) {
            for (var j = 0; j < graphics.length; j++) {
                if (matching[i].id === graphics[j].id) {
                    g = graphics[j];
                    if (captureIntersects[g.symbol.type](geometry, g.feature.geometry, g.symbol, resolution, g.feature.geometry.radius, viewpoint, queryPadding)) {
                        result.push(g);
                    }
                }
            }
        }
        return result;
    };

    GraphicIndex.prototype.queryMsc = function (geometry, queryPadding, resolution, viewpoint) {
        var bounds = getBounds(geometry);
        var matching = this.tree.search({
            minX: bounds.minx - queryPadding * resolution,
            minY: bounds.miny - queryPadding * resolution,
            maxX: bounds.maxx + queryPadding * resolution,
            maxY: bounds.maxy + queryPadding * resolution
        });
        var g;
        var result = [];
        var symbol = {
            width: 5
        };
        var type;
        for (var i = 0; i < matching.length; i++) {
            g = matching[i];
            type = g.id.feature.type + "ex";
            if (result.indexOf(g.id) === -1 && queryIntersectsEx[type](geometry, g.id.geometry, symbol, resolution, 5, viewpoint)) {
                result.push(g.id);
            }
        }
        return result;
    };

    GraphicIndex.prototype.queryRender = function (geometry, queryPadding, graphics, resolution, viewpoint) {
        var bounds = getBounds(geometry);
        var matching = this.tree.search({
            minX: bounds.minx - queryPadding * resolution,
            minY: bounds.miny - queryPadding * resolution,
            maxX: bounds.maxx + queryPadding * resolution,
            maxY: bounds.maxy + queryPadding * resolution
        });
        var g;
        var result = [];
        for (var i = 0; i < matching.length; i++) {
            for (var j = 0; j < graphics.length; j++) {
                if (matching[i].id === graphics[j].id) {
                    g = graphics[j];
                    if (g.visible && queryIntersects[g.symbol.type](geometry, g.feature.geometry, g.symbol, resolution, g.feature.geometry.radius, viewpoint)) {
                        result.push(g);
                    }
                }
            }
        }
        return result;
    };

    GraphicIndex.prototype.clear = function () {
        this.tree.clear();
    };

    return GraphicIndex;
});

},
'com/huayun/webgis/layers/support/TileCache':function(){
/**
 * 
 * @see com.huayun.webgis.layer.support.TileCache
 */
define([], function () {
    /**
     * 
     * @ignore
     * @alias com.huayun.webgis.layer.support.TileCache
     * @param max
     * @param onRemove
     * @constructor
     */
    var TileCache = function TileCache(max, onRemove) {
        this.max = max;
        this.onRemove = onRemove;
        this.reset();
    };

    /**
     * 
     * @return {TileCache}
     */
    TileCache.prototype.reset = function reset() {
        for (var key in this.data) {
            for (var i = 0, list = this.data[key]; i < list.length; i += 1) {
                var removedData = list[i];
                if (removedData.timeout) {
                    clearTimeout(removedData.timeout);
                }
                this.onRemove(removedData.value);
            }
        }
        this.data = {};
        this.order = [];
        return this;
    };

    /**
     * key-value, , 
     * @param tileID
     * @param data
     * @param expiryTimeout
     * @return {com.huayun.webgis.layer.support.TileCache}
     */
    TileCache.prototype.add = function add(tileID, data, expiryTimeout) {
        var this$1 = this;
        var key = tileID.wrapped().key;
        if (this.data[key] === undefined) {
            this.data[key] = [];
        }
        var dataWrapper = {
            value: data,
            timeout: undefined
        };

        if (expiryTimeout !== undefined) {
            dataWrapper.timeout = setTimeout(function () {
                this$1.remove(tileID, dataWrapper);
            }, expiryTimeout);
        }

        this.data[key].push(dataWrapper);
        this.order.push(key);

        if (this.order.length > this.max) {
            var removedData = this._getAndRemoveByKey(this.order[0]);
            if (removedData) {
                this.onRemove(removedData);
            }
        }
        return this;
    };

    /**
     * tile
     * @param tileID
     * @return {boolean}
     */
    TileCache.prototype.has = function has(tileID) {
        return tileID.wrapped().key in this.data;
    };

    /**
     * idtile
     * @param tileID
     * @return {null|*}
     */
    TileCache.prototype.getAndRemove = function getAndRemove(tileID) {
        if (!this.has(tileID)) {
            return null;
        }
        return this._getAndRemoveByKey(tileID.wrapped().key);
    };

    /**
     * 
     * @param key
     * @return {*}
     * @private
     */
    TileCache.prototype._getAndRemoveByKey = function _getAndRemoveByKey(key) {
        var data = this.data[key].shift();
        if (data.timeout) {
            clearTimeout(data.timeout);
        }

        if (this.data[key].length === 0) {
            delete this.data[key];
        }
        this.order.splice(this.order.indexOf(key), 1);
        return data.value;
    };

    /**
     * 
     * @param tileID
     * @return {null|*}
     */
    TileCache.prototype.get = function get(tileID) {
        if (!this.has(tileID)) {
            return null;
        }

        var data = this.data[tileID.wrapped().key][0];
        return data.value;
    };

    /**
     * 
     * @param tileID
     * @param value
     * @return {com.huayun.webgis.layer.support.TileCache}
     */
    TileCache.prototype.remove = function remove(tileID, value) {
        if (!this.has(tileID)) {
            return this;
        }
        var key = tileID.wrapped().key;

        var dataIndex = value === undefined ? 0 : this.data[key].indexOf(value);
        var data = this.data[key][dataIndex];
        this.data[key].splice(dataIndex, 1);
        if (data.timeout) {
            clearTimeout(data.timeout);
        }
        if (this.data[key].length === 0) {
            delete this.data[key];
        }
        this.onRemove(data.value);
        this.order.splice(this.order.indexOf(key), 1);
        return this;
    };

    /**
     * 
     * @param max
     * @return {com.huayun.webgis.layer.support.TileCache}
     */
    TileCache.prototype.setMaxSize = function setMaxSize(max) {
        this.max = max;
        while (this.order.length > this.max) {
            var removedData = this._getAndRemoveByKey(this.order[0]);
            if (removedData) {
                this.onRemove(removedData);
            }
        }
        return this;
    };

    return TileCache;
});
},
'com/huayun/webgis/data/bucket/LineBucketSimplify':function(){
define([
    "../ArrayType",
    "../../gl/SegmentVector"
], function (ArrayType, SegmentVector) {

    var EXTRUDE_SCALE = 63;
    var LINE_DISTANCE_BUFFER_BITS = 15;
    var LINE_DISTANCE_SCALE = 1 / 2;
    var MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS - 1) / LINE_DISTANCE_SCALE;
    var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));


    function addLineVertex(layoutVertexBuffer, point, extrude, round, up, dir, linesofar) {

        // console.log(point.x, point.y, extrude.x, extrude.y, round, up, dir, linesofar);

        /*layoutVertexBuffer.emplaceBack(
            (point.x << 1) + (round ? 1 : 0),
            (point.y << 1) + (up ? 1 : 0),// a_pos_normal
            Math.round(EXTRUDE_SCALE * extrude.x) + 128,
            Math.round(EXTRUDE_SCALE * extrude.y) + 128, // a_data
            ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),
            (linesofar * LINE_DISTANCE_SCALE) >> 6);*/
        layoutVertexBuffer.emplaceBack(
            point.x,
            point.y,
            point.z||0,
            Math.round(EXTRUDE_SCALE * extrude.x) + 128,
            Math.round(EXTRUDE_SCALE * extrude.y) + 128, // a_data
            ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),
            (linesofar * LINE_DISTANCE_SCALE) >> 6,
            round ? 1 : 0,
            up ? 1 : 0);
    }

    var LineBucketSimplify = function LineBucketSimplify(options) {
        // this.layoutVertexArray = new ArrayType.StructArrayLayout6fb24();
        // this.layoutVertexArray = new ArrayType.StructArrayLayout6f2ib28();
        this.layoutVertexArray = new ArrayType.StructArrayLayout7f2ib32();
        this.indexArray = new ArrayType.StructArrayLayout3ui6();
        this.segments = new SegmentVector();
    };

    LineBucketSimplify.prototype.addFeature = function addFeature(geometry, join, cap, miterLimit, roundLimit) {
        for (var i = 0; i < geometry.length; i += 1) {
            var feature = geometry[i];
            this.addLine(feature, join, cap, miterLimit, roundLimit);
        }
    };

    LineBucketSimplify.prototype.upload = function upload(context) {
        if (!this.uploaded) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, [
                {name: "a_pos", type: "Float32", components: 3, offset: 0},
                {name: "a_data", type: "Float32", components: 4, offset: 12},
                {name: "a_normal", type: "Int16", components: 2, offset: 28}
            ]);
            this.indexBuffer = context.createIndexBuffer(this.indexArray);
        }
        this.uploaded = true;
    };

    LineBucketSimplify.prototype.destroy = function destroy() {
        if (!this.layoutVertexBuffer) {
            return;
        }
        this.layoutVertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.segments.destroy();
    };

    LineBucketSimplify.prototype.addLine = function addLine(vertices, join, cap, miterLimit, roundLimit) {
        var lineDistances = null;
        var len = vertices.length;
        while (len >= 2 && vertices[len - 1].equals(vertices[len - 2])) {
            vertices.splice(len - 1);
            len--;
        }
        var first = 0;
        while (first < len - 1 && vertices[first].equals(vertices[first + 1])) {
            first++;
        }

        if (join === 'bevel') {
            miterLimit = 1.05;
        }

        var sharpCornerOffset = 240;

        var firstVertex = vertices[first];
        var segment = this.segments.prepareSegment(len * 10, this.layoutVertexArray, this.indexArray);

        this.distance = 0;

        var beginCap = cap,
            endCap = cap;
        var startOfLine = true;
        var currentVertex;
        var prevVertex = undefined;
        var nextVertex = undefined;
        var prevNormal = undefined;
        var nextNormal = undefined;
        var offsetA;
        var offsetB;

        // the last three vertices added
        this.e1 = this.e2 = this.e3 = -1;

        for (var i = first; i < len; i++) {
            nextVertex = vertices[i + 1]; // just the next vertex
            if (nextNormal) {
                prevNormal = nextNormal;
            }
            if (currentVertex) {
                prevVertex = currentVertex;
            }
            currentVertex = vertices[i];
            nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;
            prevNormal = prevNormal || nextNormal;

            if (!prevNormal) {
                return;
            }

            var joinNormal = prevNormal.add(nextNormal);
            if (joinNormal.x !== 0 || joinNormal.y !== 0) {
                joinNormal._unit();
            }
            /*  joinNormal prevNormal
            *           
            *            .________. prevVertex
            *            |
            * nextNormal    |  currentVertex
            *            |
            * nextVertex !
            *
            */
            var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
            var miterLength = cosHalfAngle !== 0 ? 1 / cosHalfAngle : Infinity;

            var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;

            if (isSharpCorner && i > first) {
                var prevSegmentLength = currentVertex.dist(prevVertex);
                if (prevSegmentLength > 2 * sharpCornerOffset) {
                    var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());
                    this.distance += newPrevVertex.dist(prevVertex);
                    this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false, segment, lineDistances);
                    prevVertex = newPrevVertex;
                }
            }

            // The join if a middle vertex, otherwise the cap.
            var middleVertex = prevVertex && nextVertex;
            var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

            if (middleVertex && currentJoin === 'round') {
                if (miterLength < roundLimit) {
                    currentJoin = 'miter';
                } else if (miterLength <= 2) {
                    currentJoin = 'fakeround';
                }
            }

            if (currentJoin === 'miter' && miterLength > miterLimit) {
                currentJoin = 'bevel';
            }

            if (currentJoin === 'bevel') {
                // The maximum extrude length is 128 / 63 = 2 times the width of the line
                // so if miterLength >= 2 we need to draw a different type of bevel here.
                if (miterLength > 2) {
                    currentJoin = 'flipbevel';
                }

                // If the miterLength is really small and the line bevel wouldn't be visible,
                // just draw a miter join to save a triangle.
                if (miterLength < miterLimit) {
                    currentJoin = 'miter';
                }
            }

            // Calculate how far along the line the currentVertex is
            if (prevVertex) {
                this.distance += currentVertex.dist(prevVertex);
            }

            if (currentJoin === 'miter') {
                joinNormal._mult(miterLength);
                this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false, segment, lineDistances);

            } else if (currentJoin === 'flipbevel') {
                // miter is too big, flip the direction to make a beveled join

                if (miterLength > 100) {
                    // Almost parallel lines
                    joinNormal = nextNormal.clone().mult(-1);

                } else {
                    var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                    var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                    joinNormal._perp()._mult(bevelLength * direction);
                }
                this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false, segment, lineDistances);
                this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false, segment, lineDistances);

            } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
                var lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;
                var offset = -Math.sqrt(miterLength * miterLength - 1);
                if (lineTurnsLeft) {
                    offsetB = 0;
                    offsetA = offset;
                } else {
                    offsetA = 0;
                    offsetB = offset;
                }

                // Close previous segment with a bevel
                if (!startOfLine) {
                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false, segment, lineDistances);
                }

                if (currentJoin === 'fakeround') {
                    // The join angle is sharp enough that a round join would be visible.
                    // Bevel joins fill the gap between segments with a single pie slice triangle.
                    // Create a round join by adding multiple pie slices. The join isn't actually round, but
                    // it looks like it is at the sizes we render lines at.

                    // Add more triangles for sharper angles.
                    // This math is just a good enough approximation. It isn't "correct".
                    var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
                    var approxFractionalJoinNormal = (void 0);

                    for (var m = 0; m < n; m++) {
                        approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
                        this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft, segment, lineDistances);
                    }

                    this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft, segment, lineDistances);

                    for (var k = n - 1; k >= 0; k--) {
                        approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
                        this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft, segment, lineDistances);
                    }
                }

                // Start next segment
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false, segment, lineDistances);
                }

            } else if (currentJoin === 'butt') {
                if (!startOfLine) {
                    // Close previous segment with a butt
                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false, segment, lineDistances);
                }

                // Start next segment with a butt
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false, segment, lineDistances);
                }

            } else if (currentJoin === 'square') {

                if (!startOfLine) {
                    // Close previous segment with a square cap
                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false, segment, lineDistances);

                    // The segment is done. Unset vertices to disconnect segments.
                    this.e1 = this.e2 = -1;
                }

                // Start next segment
                if (nextVertex) {
                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false, segment, lineDistances);
                }

            } else if (currentJoin === 'round') {

                if (!startOfLine) {
                    // Close previous segment with butt
                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false, segment, lineDistances);

                    // Add round cap or linejoin at end of segment
                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true, segment, lineDistances);

                    // The segment is done. Unset vertices to disconnect segments.
                    this.e1 = this.e2 = -1;
                }


                // Start next segment with a butt
                if (nextVertex) {
                    // Add round cap before first segment
                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true, segment, lineDistances);

                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false, segment, lineDistances);
                }
            }

            if (isSharpCorner && i < len - 1) {
                var nextSegmentLength = currentVertex.dist(nextVertex);
                if (nextSegmentLength > 2 * sharpCornerOffset) {
                    var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());
                    this.distance += newCurrentVertex.dist(currentVertex);
                    this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false, segment, lineDistances);
                    currentVertex = newCurrentVertex;
                }
            }
            startOfLine = false;
        }

    };

    LineBucketSimplify.prototype.addCurrentVertex = function addCurrentVertex(currentVertex, distance, normal, endLeft, endRight, round, segment, distancesForScaling) {
        var extrude;
        var layoutVertexArray = this.layoutVertexArray;
        var indexArray = this.indexArray;

        extrude = normal.clone();
        if (endLeft) {
            extrude._sub(normal.perp()._mult(endLeft));
        }
        addLineVertex(layoutVertexArray, currentVertex, extrude, round, false, endLeft, distance);
        this.e3 = segment.vertexLength++;
        if (this.e1 >= 0 && this.e2 >= 0) {
            indexArray.emplaceBack(this.e1, this.e2, this.e3);
            segment.primitiveLength++;
        }
        this.e1 = this.e2;
        this.e2 = this.e3;

        extrude = normal.mult(-1);
        if (endRight) {
            extrude._sub(normal.perp()._mult(endRight));
        }
        addLineVertex(layoutVertexArray, currentVertex, extrude, round, true, -endRight, distance);
        this.e3 = segment.vertexLength++;
        if (this.e1 >= 0 && this.e2 >= 0) {
            indexArray.emplaceBack(this.e1, this.e2, this.e3);
            segment.primitiveLength++;
        }
        this.e1 = this.e2;
        this.e2 = this.e3;

        if (distance > MAX_LINE_DISTANCE / 2 && !distancesForScaling) {
            this.distance = 0;
            this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round, segment);
        }
    };

    LineBucketSimplify.prototype.addPieSliceVertex = function addPieSliceVertex(currentVertex, distance, extrude, lineTurnsLeft, segment) {
        extrude = extrude.mult(lineTurnsLeft ? -1 : 1);
        var layoutVertexArray = this.layoutVertexArray;
        var indexArray = this.indexArray;

        addLineVertex(layoutVertexArray, currentVertex, extrude, false, lineTurnsLeft, 0, distance);
        this.e3 = segment.vertexLength++;
        if (this.e1 >= 0 && this.e2 >= 0) {
            indexArray.emplaceBack(this.e1, this.e2, this.e3);
            segment.primitiveLength++;
        }

        if (lineTurnsLeft) {
            this.e2 = this.e3;
        } else {
            this.e1 = this.e3;
        }
    };

    return LineBucketSimplify;
});
},
'com/huayun/webgis/geometry/Polyline':function(){
/**
 * 
 * @module com/huayun/webgis/geometry
 * @see com.huayun.webgis.geometry.Polyline
 */
define([
  "./Geometry",
  "./Extent"
], function (Geometry, Extent) {

  function findExtremum(path) {
    var xmin, ymin, xmax, ymax;
    xmin = xmax = path[0][0].x;
    ymin = ymax = path[0][0].y;
    var len = path.length;
    for (var i = 0; i < len; i++) {
      var line = path[i];
      var ll = line.length;
      for (var j = 0; j < ll; j++) {
        var p = line[j];
        xmin = Math.min(xmin, p.x);
        ymin = Math.min(ymin, p.y);
        xmax = Math.max(xmax, p.x);
        ymax = Math.max(ymax, p.y);
      }
    }
    return {
      xmin: xmin,
      ymin: ymin,
      xmax: xmax,
      ymax: ymax
    };
  }

  /**
   * 
   * @alias com.huayun.webgis.geometry.Polyline
   * @extends {Geometry}
   * @param {Array} path  - , 
   * @property {Array} path  - , 
   * @property {Extent} extent  - 
   * var line = new Polyline([[
   *  new Point(514581, 3349546),
   *  new Point(514981, 3349546),
   *  new Point(514981, 3349246),
   *  new Point(514581, 3349246),
   *  new Point(514581, 3349546)
   * ], [
   *  new Point(514581, 3349546),
   *  new Point(514981, 3349546),
   *  new Point(514981, 3349246),
   *  new Point(514581, 3349246),
   *  new Point(514581, 3349546)
   * ]
   * ]);
   */
  var Polyline = function (path, spatialReference) {
    Geometry.call(this);
    this.type = "line";
    this.path = path;
    this.spatialReference = spatialReference;
    this._extent = null;
  };

  if (Geometry) Polyline.__proto__ = Geometry;
  Polyline.prototype = Object.create(Geometry && Geometry.prototype);
  Polyline.prototype.constructor = Polyline;

  var prototypeAccessors = {
    length: {configurable: false},
    extent: {configurable: false}
  };

  prototypeAccessors.length.get = function () {
    return this.path.length;
  };

  prototypeAccessors.extent.get = function () {
    if (!this._extent) {
      var extremum = findExtremum(this.path);
      this._extent = new Extent(extremum.xmin, extremum.ymin, extremum.xmax, extremum.ymax);
    }
    return this._extent;
  };

  Polyline.prototype = {
    setPath: function (path) {
      this.path = path;
      this._extent = null;
    },
    addPath: function (line) {
      this.path.push(line);
      this._extent = null;
    },
    update: function (dx, dy) {
      this.path.forEach(function (line) {
        line.forEach(function (point) {
          point.update(dx, dy);
        });
      });
      this._extent = null;
    }
  };

  Object.defineProperties(Polyline.prototype, prototypeAccessors);
  return Polyline;
});
},
'com/huayun/webgis/gl/ProgramSimplify':function(){
define([
  "./VertexArrayObject"
], function (VertexArrayObject) {
  /**
   *
   * @param context
   * @param source
   * @param configuration
   * @param fixedUniforms
   */
  var ProgramSimplify = function Program(context, source, configuration, fixedUniforms) {
    var gl = context.gl;
    this.program = gl.createProgram();

    var defines = configuration.defines;
    var fragmentSource, vertexSource
    if (defines) {
      fragmentSource = defines.concat(source.fragmentSource).join('\n');
      vertexSource = defines.concat(source.vertexSource).join('\n');
    } else {
      fragmentSource = source.fragmentSource;
      vertexSource = source.vertexSource;
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    gl.attachShader(this.program, fragmentShader);

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    gl.attachShader(this.program, vertexShader);

    var layoutAttributes = configuration.layoutAttributes || [];
    for (var i = 0; i < layoutAttributes.length; i++) {
      gl.bindAttribLocation(this.program, i, layoutAttributes[i].name);
    }

    gl.linkProgram(this.program);
    this.numAttributes = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);
    this.attributes = {};
    var uniformLocations = {};
    for (var i$1 = 0; i$1 < this.numAttributes; i$1++) {
      var attribute = gl.getActiveAttrib(this.program, i$1);
      if (attribute) {
        this.attributes[attribute.name] = gl.getAttribLocation(this.program, attribute.name);
      }
    }
    var numUniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
    for (var i$2 = 0; i$2 < numUniforms; i$2++) {
      var uniform = gl.getActiveUniform(this.program, i$2);
      if (uniform) {
        uniformLocations[uniform.name] = gl.getUniformLocation(this.program, uniform.name);
      }
    }
    this.fixedUniforms = fixedUniforms(context, uniformLocations);
  };

  ProgramSimplify.prototype.draw = function draw(context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer,
                                                 indexBuffer, segments, currentProperties, zoom, configuration, dynamicLayoutBuffer, dynamicLayoutBuffer2) {
    var obj;
    var gl = context.gl;

    context.program.set(this.program);
    context.setDepthMode(depthMode);
    // context.setStencilMode(stencilMode);
    context.setColorMode(colorMode);
    context.setCullFace(cullFaceMode);

    for (var name in this.fixedUniforms) {
      this.fixedUniforms[name].set(uniformValues[name]);
    }

    var primitiveSize = (obj = {}, obj[gl.LINES] = 2, obj[gl.TRIANGLES] = 3, obj[gl.LINE_STRIP] = 1, obj)[drawMode];

    for (var i = 0, list = segments.get(); i < list.length; i += 1) {
      var segment = list[i];
      var vaos = segment.vaos || (segment.vaos = {});
      var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
      vao.bind(context, this, layoutVertexBuffer, [],
        indexBuffer, segment.vertexOffset, dynamicLayoutBuffer, dynamicLayoutBuffer2);
      gl.drawElements(drawMode, segment.primitiveLength * primitiveSize, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2);
      // console.log(drawMode, segment.primitiveLength * primitiveSize, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2);
    }
  };

  ProgramSimplify.prototype.draw2 = function draw2(context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer, len) {
    var obj;
    var gl = context.gl;

    context.program.set(this.program);
    context.setDepthMode(depthMode);
    context.setColorMode(colorMode);
    context.setCullFace(cullFaceMode);

    for (var name in this.fixedUniforms) {
      this.fixedUniforms[name].set(uniformValues[name]);
    }

    /*for (var i = 0, list = segments.get(); i < list.length; i += 1) {
        var segment = list[i];
        var vaos = segment.vaos || (segment.vaos = {});
        var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
        vao.bind(context, this, layoutVertexBuffer, []);

    }*/

    context.bindVertexBuffer.set(layoutVertexBuffer.buffer);
    gl.drawArrays(drawMode, 0, len);
  };

  ProgramSimplify.prototype.drawArray = function (context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer, indexBuffer, segments) {
    var obj;
    var gl = context.gl;
    context.program.set(this.program);
    context.setDepthMode(depthMode);
    context.setColorMode(colorMode);
    context.setCullFace(cullFaceMode);

    for (var name in this.fixedUniforms) {
      this.fixedUniforms[name].set(uniformValues[name]);
    }

    for (var i = 0, list = segments.get(); i < list.length; i += 1) {
      var segment = list[i];
      var vaos = segment.vaos || (segment.vaos = {});
      var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
      vao.bind(context, this, layoutVertexBuffer, [],
        indexBuffer, segment.vertexOffset, undefined, undefined);
      gl.drawArrays(drawMode, segment.primitiveOffset, segment.vertexLength);
    }

  };
  ProgramSimplify.prototype.drawArraysInstancedANGLE = function (context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer, indexBuffer, segments,
                                                                 dynamicLayoutBuffer, count) {
    var gl = context.gl;
    context.program.set(this.program);
    context.setDepthMode(depthMode);
    context.setColorMode(colorMode);
    context.setCullFace(cullFaceMode);

    for (var name in this.fixedUniforms) {
      this.fixedUniforms[name].set(uniformValues[name]);
    }

    var attrs = dynamicLayoutBuffer.attributes;
    var ext = context.extInstancedArray;

    for (var i = 0, list = segments.get(); i < list.length; i += 1) {
      var segment = list[i];
      var vaos = segment.vaos || (segment.vaos = {});
      var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
      vao.bind(context, this, layoutVertexBuffer, [dynamicLayoutBuffer],
        indexBuffer, segment.vertexOffset, undefined, undefined);

      for (var j = 0; j < attrs.length; j++) {
        var member = attrs[j];
        ext.vertexAttribDivisorANGLE(this.attributes[member.name], 1);
      }
      ext.drawArraysInstancedANGLE(drawMode, segment.primitiveOffset, segment.vertexLength, count);
    }
  };

  ProgramSimplify.prototype.drawInstancedANGLE = function (context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer, indexBuffer, segments,
                                                                 dynamicLayoutBuffer, count) {
    var gl = context.gl;
    context.program.set(this.program);
    context.setDepthMode(depthMode);
    context.setColorMode(colorMode);
    context.setCullFace(cullFaceMode);

    for (var name in this.fixedUniforms) {
      this.fixedUniforms[name].set(uniformValues[name]);
    }

    var attrs = dynamicLayoutBuffer.attributes;
    var ext = context.extInstancedArray;

    var primitiveSize = 3;
    for (var i = 0, list = segments.get(); i < list.length; i += 1) {
      var segment = list[i];
      var vaos = segment.vaos || (segment.vaos = {});
      var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
      vao.bind(context, this, layoutVertexBuffer, [dynamicLayoutBuffer],
        indexBuffer, segment.vertexOffset, undefined, undefined);

      for (var j = 0; j < attrs.length; j++) {
        var member = attrs[j];
        ext.vertexAttribDivisorANGLE(this.attributes[member.name], 1);
      }
      // ext.drawArraysInstancedANGLE(drawMode, segment.primitiveOffset, segment.vertexLength, count);


      ext.drawElementsInstancedANGLE(drawMode, segment.primitiveLength * primitiveSize, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2, count);
    }
  };

  /*ProgramSimplify.prototype.drawInstancedANGLE = function draw(context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer,
                                                 indexBuffer, segments, divisorANGLE, divisorVertexArrayBuffer, size) {
      var obj;
      var gl = context.gl;

      context.program.set(this.program);
      context.setDepthMode(depthMode);
      // context.setStencilMode(stencilMode);
      context.setColorMode(colorMode);
      context.setCullFace(cullFaceMode);

      for (var name in this.fixedUniforms) {
          this.fixedUniforms[name].set(uniformValues[name]);
      }

      var primitiveSize = (obj = {}, obj[gl.LINES] = 2, obj[gl.TRIANGLES] = 3, obj[gl.LINE_STRIP] = 1, obj)[drawMode];

      debugger;
      for (var i = 0, list = segments.get(); i < list.length; i += 1) {
          var segment = list[i];
          var vaos = segment.vaos || (segment.vaos = {});
          var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
          vao.bind(context, this, layoutVertexBuffer, [],
            indexBuffer, segment.vertexOffset, undefined, undefined, divisorANGLE, divisorVertexArrayBuffer);
          // context.extInstancedArray.drawElementsInstancedANGLE(drawMode, size * primitiveSize, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2, segment.primitiveLength / size);
          context.extInstancedArray.drawElementsInstancedANGLE(drawMode, 6, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2, segment.primitiveLength / size);
      }
  };*/

  ProgramSimplify.prototype.drawMassive = function draw(context, drawMode, depthMode, stencilMode, colorMode, cullFaceMode, uniformValues, layerID, layoutVertexBuffer,
                                                        indexBuffer, segments, currentProperties, zoom, configuration, dynamicLayoutBuffer, dynamicLayoutBuffer2) {
    var obj;
    var gl = context.gl;

    context.program.set(this.program);
    context.setDepthMode(depthMode);
    // context.setStencilMode(stencilMode);
    context.setColorMode(colorMode);
    context.setCullFace(cullFaceMode);

    for (var name in this.fixedUniforms) {
      this.fixedUniforms[name].set(uniformValues[name]);
    }

    if (configuration) {
      configuration.setUniforms(context, this.binderUniforms, currentProperties, {zoom: (zoom)});
    }

    var primitiveSize = (obj = {}, obj[gl.LINES] = 2, obj[gl.TRIANGLES] = 3, obj[gl.LINE_STRIP] = 1, obj)[drawMode];

    for (var i = 0, list = segments.get(); i < list.length; i += 1) {
      var segment = list[i];
      var vaos = segment.vaos || (segment.vaos = {});
      var vao = vaos[layerID] || (vaos[layerID] = new VertexArrayObject());
      vao.bind(context, this, layoutVertexBuffer, configuration ? configuration.getPaintVertexBuffers() : [],
        indexBuffer, segment.vertexOffset, dynamicLayoutBuffer, dynamicLayoutBuffer2);
      gl.drawElements(drawMode, segment.primitiveLength * primitiveSize, gl.UNSIGNED_INT, segment.primitiveOffset * primitiveSize * 2);
    }
  };

  return ProgramSimplify;
});
},
'com/huayun/webgis/renderer/Renderer':function(){
define([], function () {
    function Renderer() {
    }

    Renderer.prototype.getRealScale = function (fixed, scale, minScale) {
        var realScale = 1;
        if (fixed.isFixed || minScale === 0) {
            return realScale;
        }
        if (fixed.addratio === 0) {
            return scale / minScale;
        } else if (fixed.addratio > 0) {
            return (1 + (scale / minScale) * fixed.addratio);
        }
    };

    Renderer.prototype.calculateExtent = function () {};

    return Renderer;
});

},
'com/huayun/webgis/geometry/Multipoint':function(){
/**
 * 
 * @module com/huayun/webgis/geometry
 * @see com.huayun.webgis.geometry.Multipoint
 */
define([
    "./Geometry",
    "./Extent"
], function (Geometry, Extent) {

    function findExtremum(points) {
        var xmin, ymin, xmax, ymax;
        xmin = xmax = points[0].x;
        ymin = ymax = points[0].y;
        var len = points.length;
        for (var i = 0; i < len; i++) {
            var p = points[i];
            xmin = Math.min(xmin, p.x);
            ymin = Math.min(ymin, p.y);
            xmax = Math.max(xmax, p.x);
            ymax = Math.max(ymax, p.y);
        }
        return {
            xmin: xmin,
            ymin: ymin,
            xmax: xmax,
            ymax: ymax
        };
    }
    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.geometry.Multipoint
     * @extends {Geometry}
     * @param {Array} points , 
     * @property {Array} points , 
     * @property {Extent} extent 
     * @example
     * var mp = new Multipoint([
     *  new Point(514581, 3349546),
     *  new Point(514981, 3349546),
     *  new Point(514981, 3349246),
     *  new Point(514581, 3349246),
     *  new Point(514581, 3349546)
     * ])
     */
    var Multipoint = function (points, spatialReference) {
        Geometry.call(this);
        this.type = "multipoint";
        this.points = points === undefined?[]: points;
        this.spatialReference = spatialReference;
        this._extent = null;
    };

    if (Geometry) Multipoint.__proto__ = Geometry;
    Multipoint.prototype = Object.create(Geometry && Geometry.prototype);
    Multipoint.prototype.constructor = Multipoint;

    var prototypeAccessors = {
        length: {configurable: false},
        extent: {configurable: false}
    };

    prototypeAccessors.length.get = function () {
        return this.points.length;
    };

    prototypeAccessors.extent.get = function () {
        if (!this._extent) {
            var extremum = findExtremum(this.points);
            this._extent = new Extent(extremum.xmin, extremum.ymin, extremum.xmax, extremum.ymax);
        }
        return this._extent;
    };

    Multipoint.prototype = {
        setPoints: function (points) {
            this.points = points;
            this._extent = null;
        },
        addPoint: function (point) {
            this.points.push(point);
            this._extent = null;
        },
        update: function (dx, dy) {
            this.points.forEach(function (point) {
                point.update(dx, dy);
            });
            this._extent = null;
        }
    };

    Object.defineProperties(Multipoint.prototype, prototypeAccessors);
    return Multipoint;
});

},
'com/huayun/webgis/renderer/CircleRenderer':function(){
define([
    "./Renderer",
    "../gl/mode",
    "../data/bucket/CircleBucketSimplify",
    "../geometry/Point",
    "../gl/programCache"
], function (Renderer, mode, CircleBucket, Point, programCache) {
    function CircleRenderer() {
    }

    if (Renderer) CircleRenderer.__proto__ = Renderer;
    CircleRenderer.prototype = Object.create(Renderer && Renderer.prototype);
    CircleRenderer.prototype.constructor = CircleRenderer;

    CircleRenderer.prototype.add = function (view, graphic, geometry, symbol) {
        var bucket = new CircleBucket();
        var center = graphic.position || view.viewpoint.center || [0, 0],
            cx = center[0],
            cy = center[1];
        if (geometry.type === "multipoint") {
            var p = [];
            for (var i = 0; i < geometry.points.length; i++) {
                p.push(new Point(geometry.points[i].x - cx, geometry.points[i].y - cy, 0));
            }
            bucket.addFeature([p]);
        } else if (geometry.type === "point") {
            bucket.addFeature([[new Point(geometry.x - cx, geometry.y - cy, 0)]]); // 
        }
        bucket.upload(view.context); // Buffer, WebGL
        graphic.buckets.push(bucket);
        graphic.position = [cx, cy];
    };


    CircleRenderer.prototype.draw = function (view, graphic, geometry, symbol, layerView, index, sizeRight) {
        if (index === undefined) index = 0;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadOnly);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadOnly, [0.9, 0.9]);
        }
        var stencilMode = mode.StencilMode.disabled;
        var colorMode = mode.ColorMode.alphaBlended;
        var program = programCache.useProgramSimplify(context, 'circle', {
            layoutAttributes: [{name: "a_pos", type: "Float32", components: 2, offset: 0},
                {name: "a_data", type: "Int16", components: 2, offset: 8}]
        });

        var uniform = symbol.uniforms;
        var position = graphic.position;
        var realScale = this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
        var tempW = undefined;
        var resolution = view.resolution;
        // debugger;
        if (symbol.markerSize) {    // 
            realScale = realScale * (graphic.markerScaleFactor || 1);
            tempW = symbol.markerSize / symbol.radius;
            realScale = realScale * tempW;
        } else if (graphic.symbol.size && graphic.symbol.tempW === undefined) {   //
            graphic.scaleFactor = graphic.scaleFactor || 1;
            realScale = realScale * graphic.scaleFactor;
            tempW = graphic.symbol.size / symbol.radius;
            graphic.symbol.tempW = tempW;
            realScale = realScale * tempW;
        } else if (graphic.symbol.size && graphic.symbol.tempW !== undefined) {
            realScale = realScale * graphic.symbol.tempW;
        } else {
            graphic.scaleFactor = graphic.scaleFactor || 1;
            realScale = realScale * graphic.scaleFactor;
        }
        if (!sizeRight) {
            uniform["radius"] = symbol.radius * realScale;
        }
        if (graphic.rotation) {
            uniform.u_radian = symbol.angle + graphic.rotation;
        } else {
            uniform.u_radian = symbol.angle
        }

        var dx = symbol.dx * realScale * resolution,
            dy = symbol.dy * realScale * resolution;
        var sina = Math.sin(uniform.u_radian),
            cosa = Math.cos(uniform.u_radian);
        var offsetx = dx * cosa - dy * sina,
            offsety = dy * cosa + dx * sina;
        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0] + offsetx, position[1] + offsety);

        var w = symbol.strokeWidth * realScale;
        uniform["stroke_width"] = w < 1 ? 1 : w;
        uniform["u_camera_to_center_distance"] = view.viewpoint.cameraToCenterDistance;
        uniform["u_extrude_scale"] = view.viewpoint.pixelsToGLUnits;
        graphic["_circleOffset" + index] = {
            dx: offsetx,
            dy: offsety,
            size: symbol.uniforms["radius"] + symbol.uniforms["stroke_width"]
        };
        uniform['color'] = symbol.color;
        uniform['stroke_color'] = symbol.strokeColor;
        var buckets = graphic.buckets;
        var bucket = buckets[index];
        program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, mode.CullFaceMode.disabled,
            uniform, graphic.id + "-circle" + index,
            bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,
            null);
    };

    CircleRenderer.prototype.drawGlow = function (view, graphic, geometry, symbol, layerView, index, sizeRight) {
        var glow = graphic.glow;
        if (!glow) return;
        if (index === undefined) index = 0;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadOnly);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadOnly, [0.9, 0.9]);
        }
        var stencilMode = mode.StencilMode.disabled;
        var colorMode = mode.ColorMode.alphaBlended;
        var program = programCache.useProgramSimplify(context, 'circle', {
            layoutAttributes: [{name: "a_pos", type: "Float32", components: 2, offset: 0},
                {name: "a_data", type: "Int16", components: 2, offset: 8}]
        });

        var uniform = symbol.uniforms;
        var position = graphic.position;
        var realScale = this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
        var tempW = 1;
        var resolution = view.resolution;
        // debugger;
        if (symbol.markerSize) {    // 
            realScale = realScale * graphic.markerScaleFactor;
            tempW = symbol.markerSize / symbol.radius;
            realScale = realScale * tempW;
        } else if (graphic.symbol.size) {   //
            graphic.scaleFactor = graphic.scaleFactor || 1;
            realScale = realScale * graphic.scaleFactor;
            tempW = graphic.symbol.size / symbol.radius;
            realScale = realScale * tempW;
        } else {
            graphic.scaleFactor = graphic.scaleFactor || 1;
            realScale = realScale * graphic.scaleFactor;
        }
        if (!sizeRight) {
            uniform["radius"] = symbol.radius * realScale;
        }
        if (graphic.rotation) {
            uniform.u_radian = symbol.angle + graphic.rotation;
        } else {
            uniform.u_radian = symbol.angle
        }

        var dx = symbol.dx * realScale * resolution,
            dy = symbol.dy * realScale * resolution;
        var sina = Math.sin(uniform.u_radian),
            cosa = Math.cos(uniform.u_radian);
        var offsetx = dx * cosa - dy * sina,
            offsety = dy * cosa + dx * sina;
        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0] + offsetx, position[1] + offsety);

        var w = symbol.strokeWidth * realScale;
        uniform["stroke_width"] = w < 1 ? 1 : w;
        uniform["u_camera_to_center_distance"] = view.viewpoint.cameraToCenterDistance;
        uniform["u_extrude_scale"] = view.viewpoint.pixelsToGLUnits;
        var glowColor = glow.color;
        uniform['color'] = glowColor;
        uniform['stroke_color'] = glowColor;
        var buckets = graphic.buckets;
        var bucket = buckets[index];
        program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, mode.CullFaceMode.disabled,
            uniform, graphic.id + "-circle" + index,
            bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,
            null);
    };

    CircleRenderer.prototype.calculateExtent = function (view, graphic, geometry, symbol, result, index) {
        if (!index) index = 0;
        var resolution = view.resolution;
        var dxdy = graphic["_circleOffset" + index];
        var size = dxdy.size;
        var x = geometry.x,
            y = geometry.y;
        // 

        var dx = dxdy.dx,
            dy = dxdy.dy;
        x = x + dx;
        y = y + dy;

        result.push({
            id: graphic.id,
            g: graphic,
            minX: x - size * resolution,
            minY: y - size * resolution,
            maxX: x + size * resolution,
            maxY: y + size * resolution,
        });
    };

    return CircleRenderer;
})

},
'com/huayun/webgis/gl/Texture':function(){
define([], function () {
    var Texture = function Texture(context, image, format, options) {
        this.context = context;
        this.format = format;
        this.texture = context.gl.createTexture();
        this.update(image, options);
    };

    Texture.prototype.update = function update(image, options, position) {
        var width = image.width;
        var height = image.height;
        var resize = (!this.size || this.size[0] !== width || this.size[1] !== height) && !position;
        var ref = this;
        var context = ref.context;
        var gl = context.gl;

        this.useMipmap = Boolean(options && options.useMipmap);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        context.pixelStoreUnpackFlipY.set(false);
        context.pixelStoreUnpack.set(1);
        context.pixelStoreUnpackPremultiplyAlpha.set(this.format === gl.RGBA && (!options || options.premultiply !== false));

        if (resize) {
            this.size = [width, height];
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData) {
                gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, image);
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, image.data);
            }
        } else {
            var ref$1 = position || {x: 0, y: 0};
            var x = ref$1.x;
            var y = ref$1.y;
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData) {
                gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, image);
            } else {
                gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, image.data);
            }
        }
        if (this.useMipmap && this.isSizePowerOfTwo()) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    };

    Texture.prototype.bind = function bind(filter, wrap, minFilter) {
        var ref = this;
        var context = ref.context;
        var gl = context.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        if (minFilter === gl.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo()) {
            minFilter = gl.LINEAR;
        }
        if (filter !== this.filter) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter || filter);
            this.filter = filter;
        }
        if (wrap !== this.wrap) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
            this.wrap = wrap;
        }
    };

    Texture.prototype.isSizePowerOfTwo = function isSizePowerOfTwo() {
        return this.size[0] === this.size[1] && (Math.log(this.size[0]) / Math.LN2) % 1 === 0;
    };

    Texture.prototype.destroy = function destroy() {
        var ref = this.context;
        var gl = ref.gl;
        gl.deleteTexture(this.texture);
        this.texture = (null);
    };

    return Texture;
});
},
'com/huayun/webgis/views/SceneView':function(){
/**
 * View, 
 * @see com.huayun.webgis.views.SceneView
 */
define([
    "dojo/topic",
    "dojo/on",
    "dojo/DeferredList",
    "dojo/promise/Promise",
    "dojo/dom-construct",
    "./View",
    "../Viewpoint",
    "../geometry/Extent",
    "../geometry/Point",
    "../geometry/Polygon",
    "../geometry/MapPoint",
    "../layers/GraphicLayer",
    "../handler/PanHandler",
    "../handler/TouchHandler",
    "com/huayun/webgis/gl/Context",
    "com/huayun/webgis/layers/support/ZoomHistory",
    "com/huayun/webgis/gl/VertexFragShader",
    "com/huayun/webgis/gl/programConfig",
    "com/huayun/webgis/gl/Program",
    "com/huayun/webgis/gl/ProgramSimplify",
    "../utils/utils",
    "../utils/Color",
    "../utils/TaskQueue",
    "com/huayun/webgis/gl/LineAtlas",
    "../data/GraphicsIndex",
    "../data/queryIntersects",
    "../gl/draw/drawBackground",
    "../utils/Resource",
    "../gl/Texture"
], function (topic, on, DeferredList, Promise, domConstruct, View, Viewpoint,
             Extent, Point, Polygon, MapPoint, GraphicLayer, PanHandler, TouchHandler, Context, ZoomHistory, VertexFragShader,
             programConfig, Program, ProgramSimplify, utils, Color, TaskQueue, LineAtlas, GraphicsIndex, queryIntersects,
             drawBackground, Resource, Texture) {
    /**
     * View, LayerView, , , 
     * @constructor
     * @alias com.huayun.webgis.views.SceneView
     * @extends {View}
     * @param {Object} params 
     * @param {String} params.backgroundColor , CSS
     * @param {number} params.pitch 
     * @param {number} params.angle 
     * @param {number} params.maxPitch 
     * @param {number} params.minLevel 
     * @param {number} params.maxLevel 
     * @param {number} params.rotateEnabled 
     * @param {number} params.is3DVision 3D
     * @param {number} params.level 
     * @param {Array} params.center 
     * @property {number} width , px
     * @property {number} height , px
     * @property {number} resolution 
     * @property {number} level 
     * @property {number} scale 
     * @property {Point} center 
     * @property {Viewpoint} viewpoint 
     * @property {Extent} extent 
     * @property {boolean} panEnabled 
     * @property {boolean} zoomEnabled 
     * @property {boolean} rotateEnabled 
     * @property {Array<Function>} zoomEnd 
     * @property {HTMLDivElement} domNode dom
     * @example
     * var view = new SceneView({
     *     container: container,
     *     map: map,
     *     level: 13,
     *     maxPitch: 85,
     *     maxLevel: 14,
     *     minLevel: 11,
     *     is3DVision: false,
     *     center: [511766.2805660013, 3350826.79176667]
     * });
     */
    var SceneView = function (params) {
        View.call(this, params);
        this._offsetLeft = this.container.getBoundingClientRect().left;
        this._offsetTop = this.container.getBoundingClientRect().top;
        this._clearBit = 0 | 16384 | 256 | 1024; // WebGL
        this._nochanging = true;
        this._extentDirty = true;

        var backgroundColor = params.backgroundColor || "#FFFFFF";
        this.backgroundColor = Color.parse(backgroundColor);

        this.numSublayers = SceneView.maxUnderzooming + SceneView.maxOverzooming + 1;
        this.depthEpsilon = 1 / Math.pow(2, 16);
        this.currentLayer = 0;
        this.viewStates = []; // 
        this.backViewStates = [];
        this.viewStatesLength = 10;
        this._initState = null;
        this.antialias = !!params.antialias;

        var pitch = params.pitch ? params.pitch : params.is3DVision ? 50 : 0,
            angle = params.angle ? params.angle : 0,
            width = this.container.clientWidth,
            height = this.container.clientHeight;
        var maxPitch = params.maxPitch || 50;
        this._setupContainer(width, height);
        this._setupContext();
        this.viewpoint = new Viewpoint(width, height, pitch, angle, params.maxLevel, params.minLevel, maxPitch, this);


        // todo
        this._tileTextures = {};
        this.zoomHistory = new ZoomHistory();
        this.panEnabled = true;
        this.zoomEnabled = true;
        this.rotateEnabled = params.rotateEnabled === undefined ? true : params.rotateEnabled;
        this.selectEnabled = true;
        this.resizeEnabled = true;
        this.emptyProgramConfiguration = new programConfig.ProgramConfiguration();
        this.lineAtlas = new LineAtlas(256, 512);

        this._offsetLeft = this.container.getBoundingClientRect().left;
        this._offsetTop = this.container.getBoundingClientRect().top;
        this.graphicsIndex = new GraphicsIndex();

        var pan = new PanHandler(this); // 
        new TouchHandler(this);

        this._handleAddedLayer();
        this._handleEvent();

        if (params.center) { // 
            if (params.level) {
                this.setCenter(params.center, params.level);
            } else if (params.resolution) {
                this.setCenter(params.center, null, params.resolution);
            } else {
                throw new Error("");
            }
        } else if (params.extent) { // 
            this.setExtent(params.extent);
        }

        this.numSublayers = 3 + 10 + 1;
        this.depthEpsilon = 1 / Math.pow(2, 16);

        var self = this;
        if (params.backgroundImage) {
            Resource.loadImage(params.backgroundImage, function (err, img) {
                if (img) {
                    var context = self.context;
                    var gl = context.gl;
                    self._backgroundTexture = new Texture(context, img, gl.RGBA, {useMipmap: true});
                    self._backgroundTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
                    if (context.extTextureFilterAnisotropic) {
                        gl.texParameterf(gl.TEXTURE_2D, context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, context.extTextureFilterAnisotropicMax);
                    }
                    self.threeRender();
                }
            })
        }

        // 
        this.zoomEnd = [];


        this._renderTaskQueue = new TaskQueue();
    };

    if (View) SceneView.__proto__ = View;
    SceneView.prototype = Object.create(View && View.prototype);
    SceneView.prototype.constructor = SceneView;

    var prototypeAccessors = {
        width: {configurable: true},
        height: {configurable: true},
        resolution: {configurable: true},
        level: {configurable: true},
        center: {configurable: true},
        is3DVision: {configurable: true},
        extent: {configurable: true},
        nearestResolution: {configurable: true},
        scale: {configurable: true}
    };

    prototypeAccessors.width.get = function () {
        return this.viewpoint.width;
    };
    prototypeAccessors.height.get = function () {
        return this.viewpoint.height;
    };

    prototypeAccessors.resolution.get = function () {
        return this.viewpoint.resolution;
    };

    prototypeAccessors.scale.get = function () {
        return 0.0254000508001016 / (this.resolution * 96);
    };
    /*prototypeAccessors.resolution.set = function(resolution) {
        this.viewpoint.resolution = resolution;
    };*/

    prototypeAccessors.level.get = function () {
        return this.viewpoint.level;
    };
    /*prototypeAccessors.level.set = function(level) {
        return this.view.level = level;
    };*/

    prototypeAccessors.center.get = function () {
        var center = this.viewpoint.center;
        return new Point(center[0], center[1], 0);
    };
    /*prototypeAccessors.center.set = function(center) {
        return this.view.center = center;
    };*/

    prototypeAccessors.is3DVision.get = function () {
        return this.viewpoint.pitch !== 0;
    };

    prototypeAccessors.extent.get = function () {
        if (this._extentDirty) {
            var bound = this._bound;
            if (this._bound) {
                var xmin = Math.min(bound[0].x, bound[1].x, bound[2].x, bound[3].x),
                    xmax = Math.max(bound[0].x, bound[1].x, bound[2].x, bound[3].x),
                    ymin = Math.min(bound[0].y, bound[1].y, bound[2].y, bound[3].y),
                    ymax = Math.max(bound[0].y, bound[1].y, bound[2].y, bound[3].y);
                this._extent = new Extent(xmin, ymin, xmax, ymax);
                this._extentDirty = false;
                return this._extent;
            } else {
                return null;
            }
        } else {
            return this._extent;
        }
    };

    // , WebGLCanvas
    SceneView.prototype._setupContainer = function (width, height) {
        this.domNode = document.createElement("div");
        this.domNode.classList.add('webgis-root');
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        this._canvas = canvas;
        this._canvas.setAttribute('tabindex', '0');
        this._canvas.setAttribute('aria-label', 'Map');
        this.domNode.appendChild(canvas);
        this.container.appendChild(this.domNode);
        // this._canvas.addEventListener('webglcontextlost', this._contextLost, false);
        // this._canvas.addEventListener('webglcontextrestored', this._contextRestored, false);
    };

    // WebGLContext, 
    SceneView.prototype._setupContext = function () {
        var attr = {
            alpha: true,
            antialias: this.antialias,
            depth: true,
            failIfMajorPerformanceCaveat: false,
            preserveDrawingBuffer: false,
            stencil: true
        };
        this._gl = this._canvas.getContext('webgl', attr) || this._canvas.getContext('experimental-webgl', attr);
        // this._gl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
        // this._gl.clearColor(1.0, 1.0, 0.0, 1.0);
        this.context = new Context(this._gl);
    };

    // LayerView
    SceneView.prototype._handleAddedLayer = function () {
        if (this.map.allLayers.length > 0) {
            var type = this.map.allLayers[0].type;
            if (!type || type.indexOf("Tile") < 0) {
                this._load = true;
            } else {
                var tileInfo = this.map.allLayers[0].tileInfo;
                if (tileInfo) { // , 
                    this.viewpoint.setTileInfo(tileInfo);
                    this._load = true;
                }
            }
            this.map.allLayers.forEach(function (item) {
                this.allLayerViews.push(item.createLayerView(this));
            }.bind(this));
        }
    };


    /**
     * 
     */
    SceneView.prototype.setTileInfo = function () {
        var tileInfo = this.map.allLayers[0].tileInfo;
        if (!tileInfo) return;
        if (!this.viewpoint.tileInfo) { // 
            this.viewpoint.setTileInfo(tileInfo);
            this._load = true;
            if (this.viewpoint.level || this.viewpoint.resolution) {
                this.setCenter(this.viewpoint.center, this.viewpoint.level, this.viewpoint.resolution);
            }
            topic.publish("mapLoadComplete");
        } else {
            this.setCenter(this.center);
        }
    }

    /**
     * View
     * @ignore
     * @private
     */
    SceneView.prototype._handleEvent = function () {
        // 
        this.map.on("addLayers", function (layerArray, beforeLayerId, targetIndex) {
            var type = this.map.allLayers[0].type;
            if (!type || type.indexOf("Tile") < 0) { // , 
                this._load = true;
            } else {
                var tileInfo = this.map.allLayers[0].tileInfo;
                if (tileInfo) { // , 
                    this.viewpoint.setTileInfo(tileInfo);
                    this._load = true;
                }
            }
            for (var i = 0; i < layerArray.length; i++) {
                if (beforeLayerId) {
                    this.allLayerViews.splice(targetIndex, 0, layerArray[i].createLayerView(this));
                } else {
                    this.allLayerViews.push(layerArray[i].createLayerView(this));
                }
            }
        }.bind(this));

        this.map.on("removeLayers", function (layerIds) {
            for (var j = 0; j < layerIds.length; j++) {
                var layerId = layerIds[j];
                for (var i = this.allLayerViews.length - 1; i > -1; i--) {
                    if (this.allLayerViews[i].id === layerId) {
                        this.allLayerViews.splice(i, 1);
                        break;
                    }
                }
            }
        }.bind(this));

        // todo 
        on(this.domNode, "mousewheel", this._zoomMap.bind(this));
        on(window, "resize", this._onResize.bind(this));
        /*
        on(this.container, "click", this._onClick.bind(this));
        // on(this.container, "mousemove", this._onMouseMove.bind(this));
        on(window, "resize", this._onResize.bind(this));*/
    };

    /**
     * , 
     */
    SceneView.prototype._onResize = function () {
        if (this.resizeEnabled) {
            var width = this.container.clientWidth,
                height = this.container.clientHeight;
            if (width && height) {
                this.resizeEnabled = false;
                setTimeout(function () {
                    this.resizeEnabled = true;
                }.bind(this), 100);

                this._canvas.width = width;
                this._canvas.height = height;
                this._canvas.style.width = width + 'px';
                this._canvas.style.height = height + 'px';
                this.context.viewport.set([0, 0, this._canvas.width, this._canvas.height]);
                this.viewpoint.resize(width, height);
                this._offsetLeft = this.container.getBoundingClientRect().left;
                this._offsetTop = this.container.getBoundingClientRect().top;
                this.allLayerViews.forEach(function (item) {
                    item.resize();
                });
                this.refresh();
            }
        }
    };

    /**
     * /
     * @param factor  
     * @return
     *
     */
    SceneView.prototype.expand = function (factor) {
        // var dvalue = (1 - factor) / 2;
        // var newWidth = this.width * dvalue;
        // var newHeight = this.height * dvalue;
        // this._extentDirty = true;
        // return new Extent(this.extent.minx + newWidth,this.extent.miny + newHeight,this.extent.maxx - newWidth,this.extent.maxy - newHeight);
        var newWidth = this.width / 2 * factor * this.resolution,
            newHeight = this.height / 2 * factor * this.resolution;
        var newExtent = new Extent(
            this.center.x - newWidth,
            this.center.y - newHeight,
            this.center.x + newWidth,
            this.center.y + newHeight
        );
        this.setExtent(newExtent);
    }


    /**
     * 
     * @param {Array} center , 
     * @param {number} level , 
     * @param {number} resolution , 
     * @example
     * sceneView.setCenter([511766, 3350826], 10)
     */
    SceneView.prototype.setCenter = function (center, level, resolution) {
        if (level) { // 
            var oldLevel = this.viewpoint.level;
            this.viewpoint.setLevel(level);
            this.viewpoint.setCenter(center);
            var newLevel = this.viewpoint.level;
            if (oldLevel !== newLevel) {
                topic.publish("changeLevel", {level: this.viewpoint.level});
            }
        } else if (resolution) {
            var oldLevel = this.viewpoint.level;
            this.viewpoint.setResolution(resolution, this._load);
            this.viewpoint.setCenter(center);
            var newLevel = this.viewpoint.level;
            if (oldLevel !== newLevel) {
                topic.publish("changeLevel", {level: this.viewpoint.level});
            }
        } else {
            this.viewpoint.setCenter(center);
        }
        this.refresh();
    };

    /**
     * 
     * @param {Extent} extent 
     */
    SceneView.prototype.setExtent = function (extent, callback) {
        if (extent instanceof Extent) {
            var center = extent.getCenter();
            var w = extent.getWidth(),
                h = extent.getHeight(),
                width = this.viewpoint.width,
                height = this.viewpoint.height;
            var oldLevel = this.viewpoint.level;
            this.viewpoint.setCenter([center.x, center.y]);
            this.viewpoint.setResolution(Math.max(w / width, h / height), true);
            this._extentDirty = true;
            var newLevel = this.viewpoint.level;
            if (oldLevel !== newLevel) {
                topic.publish("changeLevel", {level: this.viewpoint.level});
            }
            this.refresh(false, callback);
        }
    };

    /**
     * 
     * @return {Extent|null}
     */
    SceneView.prototype.getExtent = function () {
        if (this._extentDirty) {
            var bound = this._bound;
            if (this._bound) {
                var xmin = Math.min(bound[0].x, bound[1].x, bound[2].x, bound[3].x),
                    xmax = Math.max(bound[0].x, bound[1].x, bound[2].x, bound[3].x),
                    ymin = Math.min(bound[0].y, bound[1].y, bound[2].y, bound[3].y),
                    ymax = Math.max(bound[0].y, bound[1].y, bound[2].y, bound[3].y);
                this._extent = new Extent(xmin, ymin, xmax, ymax);
                this._extentDirty = false;
                return this._extent;
            } else {
                return null;
            }
        } else {
            return this._extent;
        }

    };

    /**
     * 
     * @param {Object} view 
     * @param {number} view.pitch 
     * @param {number} view.angle 
     * @param {number} view.level 
     * @param {Array} view.center 
     * @example
     * sceneView.setView({
     *     pitch: 0,
     *     angle: 0,
     *     level: 10,
     *     center: [511766, 3350826]
     * })
     */
    SceneView.prototype.setView = function (view) {
        var viewState;
        if (prev instanceof Object) {
            if (prev.level !== this.level) {
                topic.publish("changeLevel", {level: prev.level});
            }
            this.viewpoint.setView(prev);
            this.refresh(true);
        } else {
            if (prev && this.viewStates.length > 1) {
                this.backViewStates.push(this.viewStates.pop());
                viewState = this.viewStates[this.viewStates.length - 1];
                this.viewpoint.setView(viewState);
                this.refresh(true);
            } else if (!prev && this.backViewStates.length > 0) {
                this.viewStates.push(this.backViewStates.pop());
                viewState = this.viewStates[this.viewStates.length - 1];
                this.viewpoint.setView(viewState);
                this.refresh(true);
            }
        }
    };

    /**
     * 
     */
    SceneView.prototype.refresh = function (noPushState, callback) {
        if (!this._load) {
            return;
        }
        if (this.viewpoint.matrixDirty) {
            var width = this.container.clientWidth,
                height = this.container.clientHeight;
            if (width === 0 || height === 0) {
                return;
            }
            this.viewpoint.resize(width, height);
            this.viewpoint.matrixDirty = false;
        }
        this.zoomHistory.update(this.viewpoint.level, utils.now());
        this.viewpoint.calcMatrix(true);
        this._bound = this.viewpoint.calcBounds();
        this._extentDirty = true;
        topic.publish("extentChangeEvent", this);
        if (!this._initState) {
            this._initState = {
                level: this.viewpoint.level,
                center: [this.viewpoint.center[0], this.viewpoint.center[1]],
                pitch: this.viewpoint.pitch,
                angle: this.viewpoint.angle
            }
        }
        if (!noPushState) {
            this.handlePushViewState();
        }
        // this.graphicsIndex.clear();
        this.allLayerViews.forEach(function (item) {
            item.refresh(callback);
        });
        this.threeRender();
    };

    SceneView.prototype.handlePushViewState = function () {
        // 10
        if (this.viewStates.length < this.viewStatesLength) {
            this.viewStates.push({
                pitch: this.viewpoint.pitch,
                angle: this.viewpoint.angle,
                level: this.viewpoint.targetZoom || this.viewpoint.level,
                center: this.viewpoint.center
            });
        } else {
            this.viewStates.shift();
            this.viewStates.push({
                pitch: this.viewpoint.pitch,
                angle: this.viewpoint.angle,
                level: this.viewpoint.targetZoom || this.viewpoint.level,
                center: this.viewpoint.center
            });
        }
        this.backViewStates = [];
    };

    SceneView.prototype.centerAt = function (x, y, level) {
        if (level && level !== this.viewpoint.level) {
            this.viewpoint.setLevel(level);
        }
        this.viewpoint.setCenter([x, y]);
        this.refresh();
    };

    /**
     * 
     * @param {number} level 
     */
    SceneView.prototype.setLevel = function (level) {
        this.viewpoint.setLevel(level);
        this.viewpoint.calcMatrix(true);
        this.refresh();
    };

    /**
     * LayerViewidLayerView
     * @param {string} id - LayerViewid
     * @return {LayerView}
     */
    SceneView.prototype.findLayerViewById = function (id) {
        for (var i = this.allLayerViews.length - 1; i > -1; i--) {
            if (this.allLayerViews[i].id === id) {
                return this.allLayerViews[i];
            }
        }
    };

    /**
     * 
     * @param {number} x x
     * @param {number} y y
     * @return {Point} 
     */
    SceneView.prototype.screenToGeometry = function (x, y) {
        x = x - this._offsetLeft; // 
        y = y - this._offsetTop;
        var p = this.viewpoint.screenToGeometry(x, y);
        return new Point(p.x, p.y, 0);
    };

    /**
     * 
     * @param {number} x x
     * @param {number} y y
     * @return {Point} 
     */
    SceneView.prototype.geometryToScreen = function (x, y) {
        var screen = this.viewpoint.geometryToScreen(x, y);
        x = screen.x + this._offsetLeft;
        y = screen.y + this._offsetTop;
        return new Point(x, y);
    };

    SceneView.prototype.getTileTexture = function getTileTexture(size) {
        var textures = this._tileTextures[size];
        return textures && textures.length > 0 ? textures.pop() : null;
    };

    SceneView.prototype.saveTileTexture = function (texture) {
        var textures = this._tileTextures[texture.size[0]];
        if (!textures) {
            this._tileTextures[texture.size[0]] = [texture];
        } else {
            textures.push(texture);
        }
    };

    SceneView.prototype.useProgram = function (name, programConfiguration, customDefine) {
        if (programConfiguration === void 0) programConfiguration = this.emptyProgramConfiguration;
        this.cache = this.cache || {};
        var key = "" + name + (programConfiguration.cacheKey || '');
        if (!this.cache[key]) {
            this.cache[key] = new Program(this.context, VertexFragShader[name], programConfiguration, VertexFragShader.programUniforms[name], customDefine);
        }
        return this.cache[key];
    };

    SceneView.prototype.useProgramSimplify = function (name, programConfiguration) {
        this.simplifyCache = this.simplifyCache || {};
        if (!this.simplifyCache[name]) {
            this.simplifyCache[name] = new ProgramSimplify(this.context, VertexFragShader[name], programConfiguration, VertexFragShader.programUniforms[name]);
        }
        return this.simplifyCache[name];
    };

    SceneView.prototype._drawBackgroundImage = function () {
        if (this._backgroundTexture && this.viewpoint.rasterBoundsBuffer) {
            drawBackground(this);
        }
    }

    Object.defineProperties(SceneView.prototype, prototypeAccessors);

    // 
    // todo
    // 
    SceneView.prototype._zoomMap = function (e) {
        if (e.wheelDelta > 0) {
            this.zoomInWheel(e.clientX, e.clientY);
        } else if (e.wheelDelta < 0) {
            this.zoomOutWheel(e.clientX, e.clientY);
        }
    };

    SceneView.prototype.zoomInWheel = function (x, y) {
        if (this.zoomEnabled) {
            if (this.viewpoint.level !== null && this.viewpoint.level < this.viewpoint.maxLevel) { // 
                this.zoomEnabled = false;
                setTimeout(function () {
                    this.zoomEnabled = true;
                }.bind(this), 400);
                this.viewpoint.startZoom = this.viewpoint.level;
                this.viewpoint.targetZoom = this.viewpoint.level + 1;
                this.viewpoint.level = this.viewpoint.targetZoom;

                var aroundPoint = this.screenToGeometry(x, y);
                var center = this.viewpoint.center;
                this.deltaX = aroundPoint.x - center[0];
                this.deltaY = aroundPoint.y - center[1];
                this.viewpoint.readyMatrix(center[0] + this.deltaX / 2, center[1] + this.deltaY / 2, this.viewpoint.targetZoom);
                this._bound = this.viewpoint.calcBounds();
                this._extentDirty = true;
                topic.publish("changeLevel", {level: this.viewpoint.targetZoom});
                topic.publish("extentChangeEvent", this);
                this._handleZoomWheel(true);
            } else if (this.viewpoint.level === null) { // 
                this.zoomEnabled = false;
                this.graphicsIndex.clear();
                setTimeout(function () {
                    this.zoomEnabled = true;
                }.bind(this), 400);

                this.viewpoint.targetResolution = this.viewpoint.resolution;
                var aroundPoint = this.screenToGeometry(x, y);
                var center = this.viewpoint.center;
                this.deltaX = aroundPoint.x - center[0];
                this.deltaY = aroundPoint.y - center[1];
                this.viewpoint.readyMatrix(center[0] + this.deltaX / 2, center[1] + this.deltaY / 2, null, null, this.viewpoint.resolution / 2);
                this._bound = this.viewpoint.calcBounds();
                this._extentDirty = true;
                topic.publish("extentChangeEvent", this);
                this._handleZoomWheel(true);
            }
        }
    };

    SceneView.prototype.zoomOutWheel = function (x, y) {
        if (this.zoomEnabled) {
            if (this.viewpoint.level !== null && this.viewpoint.level > this.viewpoint.minLevel) {
                this.zoomEnabled = false;
                setTimeout(function () {
                    this.zoomEnabled = true;
                }.bind(this), 400);
                this.viewpoint.startZoom = this.viewpoint.level;
                this.viewpoint.targetZoom = this.viewpoint.level - 1;
                this.viewpoint.level = this.viewpoint.targetZoom;
                var aroundPoint = this.screenToGeometry(x, y);
                var center = this.viewpoint.center;
                this.deltaX = aroundPoint.x - center[0];
                this.deltaY = aroundPoint.y - center[1];
                this.viewpoint.readyMatrix(center[0] - this.deltaX, center[1] - this.deltaY, this.viewpoint.targetZoom);
                this._bound = this.viewpoint.calcBounds();
                this._extentDirty = true;
                topic.publish("changeLevel", {level: this.viewpoint.targetZoom});
                topic.publish("extentChangeEvent", this);
                this._handleZoomWheel(false);
            } else if (this.viewpoint.level === null) {
                this.zoomEnabled = false;
                this.graphicsIndex.clear();
                setTimeout(function () {
                    this.zoomEnabled = true;
                }.bind(this), 400);
                this.viewpoint.targetResolution = this.viewpoint.resolution;
                var aroundPoint = this.screenToGeometry(x, y);
                var center = this.viewpoint.center;
                this.deltaX = aroundPoint.x - center[0];
                this.deltaY = aroundPoint.y - center[1];
                this.viewpoint.readyMatrix(center[0] + this.deltaX / 2, center[1] + this.deltaY / 2, null, null, this.viewpoint.resolution * 2);
                this._bound = this.viewpoint.calcBounds();
                this._extentDirty = true;
                topic.publish("extentChangeEvent", this);
                this._handleZoomWheel(false);
            }
        }
    };

    /**
     * 
     */
    SceneView.prototype.zoomIn = function () {
        if (this.zoomEnabled && this.viewpoint.level < this.viewpoint.maxLevel) {
            this.zoomEnabled = false;
            setTimeout(function () {
                this.zoomEnabled = true;
            }.bind(this), 300);
            this.viewpoint.startZoom = this.viewpoint.level;
            this.viewpoint.targetZoom = this.viewpoint.level + 1;
            this.viewpoint.level = this.viewpoint.targetZoom;

            var center = this.viewpoint.center;
            this.viewpoint.readyMatrix(center[0], center[1], this.viewpoint.targetZoom);
            this._bound = this.viewpoint.calcBounds();
            this._extentDirty = true;
            topic.publish("extentChangeEvent", this);
            topic.publish("changeLevel", {level: this.viewpoint.targetZoom});
            this._handleZoom(true);
        }
    };
    /**
     * 
     */
    SceneView.prototype.zoomOut = function () {
        if (this.zoomEnabled && this.viewpoint.level > this.viewpoint.minLevel) {
            this.zoomEnabled = false;
            setTimeout(function () {
                this.zoomEnabled = true;
            }.bind(this), 300);
            this.viewpoint.startZoom = this.viewpoint.level;
            this.viewpoint.targetZoom = this.viewpoint.level - 1;
            this.viewpoint.level = this.viewpoint.targetZoom;

            var center = this.viewpoint.center;
            this.viewpoint.readyMatrix(center[0], center[1], this.viewpoint.targetZoom);
            this._bound = this.viewpoint.calcBounds();
            this._extentDirty = true;
            topic.publish("changeLevel", {level: this.viewpoint.targetZoom});
            topic.publish("extentChangeEvent", this);
            this._handleZoom(false);
        }
    };

    SceneView.prototype._handleZoom = function (isZoomIn) {
        this.allLayerViews.forEach(function (item) {
            item._readyData();
        });
        this._nochanging = false;
        if (isZoomIn) {
            this._zoomAnimateIn(null, 1);
        } else {
            this._zoomAnimateOut(null, 1);
        }
    };

    SceneView.prototype._handleZoomWheel = function (isZoomIn) {
        this.allLayerViews.forEach(function (item) {
            item._readyData();
        });
        this._nochanging = false;
        if (isZoomIn) {
            this._zoomWheelAnimateIn(null, this.viewpoint.level !== null);
        } else {
            this._zoomWheelAnimateOut(null, this.viewpoint.level !== null);
        }
    };

    SceneView.prototype._zoomWheelAnimateOut = function (start, hasLevel) {
        if (!start) start = performance.now();
        var delta = performance.now() - start;
        var center = this.viewpoint.center;
        if (delta >= 300) {
            window.cancelAnimationFrame(this._animateRaf);
            this._nochanging = true;
            this.viewpoint.setCenter([center[0] - this.deltaX, center[1] - this.deltaY]);
            if (hasLevel) {
                this.viewpoint.setLevel(this.viewpoint.targetZoom);
                this.viewpoint.targetZoom = null;
            } else {
                this.viewpoint.resolution = this.viewpoint.targetResolution * 2;
                this.viewpoint.targetResolution = null;
            }
            this.viewpoint.calcMatrix(true);
            this.handlePushViewState();
            this._renderRaf = null;
            this.callHooks("zoomEnd");
            this.threeRender();
        } else {
            var scale = delta / 300;
            var powScale;
            if (hasLevel) {
                powScale = 1 / Math.pow(2, -scale) - 1;
                this.viewpoint.updateMatrix(center[0] - this.deltaX * powScale, center[1] - this.deltaY * powScale, this.viewpoint.startZoom - scale);
            } else {
                powScale = scale;
                this.viewpoint.resolution = this.viewpoint.targetResolution * (1 + scale);
                this.viewpoint.updateMatrix(center[0] - this.deltaX * powScale, center[1] - this.deltaY * powScale, null, this.viewpoint.resolution);
            }
            this.animate();
            this._animateRaf = window.requestAnimationFrame(this._zoomWheelAnimateOut.bind(this, start, hasLevel));
        }
    };

    SceneView.prototype._zoomAnimateOut = function (start) {
        if (!start) start = performance.now();
        var delta = performance.now() - start;
        var center = this.viewpoint.center;
        if (delta >= 300) {
            window.cancelAnimationFrame(this._animateRaf);
            this._nochanging = true;
            this.viewpoint.setCenter([center[0], center[1]]);
            this.viewpoint.setLevel(this.viewpoint.targetZoom);
            this.viewpoint.calcMatrix(true);
            this.viewpoint.targetZoom = null;
            this.handlePushViewState();
            this._renderRaf = null;
            this.callHooks("zoomEnd");
            this.threeRender();
        } else {
            var scale = delta / 300;
            this.viewpoint.updateMatrix(center[0], center[1], this.viewpoint.startZoom - scale);
            this.animate();
            this._animateRaf = window.requestAnimationFrame(this._zoomAnimateOut.bind(this, start));
        }
    };

    SceneView.prototype._zoomWheelAnimateIn = function (start, hasLevel) {
        if (!start) start = performance.now();
        var delta = performance.now() - start;
        var center = this.viewpoint.center;
        if (delta >= 300) {
            window.cancelAnimationFrame(this._animateRaf);
            this._nochanging = true;
            this.viewpoint.setCenter([center[0] + this.deltaX / 2, center[1] + this.deltaY / 2]);
            if (hasLevel) {
                this.viewpoint.setLevel(this.viewpoint.targetZoom);
                this.viewpoint.targetZoom = null;
            } else {
                this.viewpoint.resolution = this.viewpoint.targetResolution / 2;
                this.viewpoint.targetResolution = null;
            }
            this.viewpoint.calcMatrix(true);
            this._renderRaf = null;
            this.callHooks("zoomEnd");
            this.handlePushViewState();
            this.threeRender();
        } else {
            var scale = delta / 300;
            var powScale;
            if (hasLevel) {
                powScale = 1 - 1 / Math.pow(2, scale);
                this.viewpoint.updateMatrix(center[0] + this.deltaX * powScale, center[1] + this.deltaY * powScale, this.viewpoint.startZoom + scale);
            } else {
                powScale = 1 - 1 / (1 + scale);
                this.viewpoint.resolution = this.viewpoint.targetResolution / (1 + scale);
                this.viewpoint.updateMatrix(center[0] + this.deltaX * powScale, center[1] + this.deltaY * powScale, null, this.viewpoint.resolution);
            }
            this.animate();
            this._animateRaf = window.requestAnimationFrame(this._zoomWheelAnimateIn.bind(this, start, hasLevel));
        }
    };

    SceneView.prototype._zoomAnimateIn = function (start) {
        if (!start) start = performance.now();
        var delta = performance.now() - start;
        var center = this.viewpoint.center;
        if (delta >= 300) {
            window.cancelAnimationFrame(this._animateRaf);
            this._nochanging = true;
            this.viewpoint.setCenter([center[0], center[1]]);
            this.viewpoint.setLevel(this.viewpoint.targetZoom);
            this.viewpoint.calcMatrix(true);
            this._renderRaf = null;
            this.viewpoint.targetZoom = null;
            this.handlePushViewState();
            this.callHooks("zoomEnd");
            this.threeRender();
        } else {
            var scale = delta / 300;
            this.viewpoint.updateMatrix(center[0], center[1], this.viewpoint.startZoom + scale);
            this.animate();
            this._animateRaf = window.requestAnimationFrame(this._zoomAnimateIn.bind(this, start));
        }
    };

    SceneView.prototype.mapMove = function (xmove, ymove) {
        if (this.panEnabled) {
            // todo 
            var theta = -this.viewpoint.angle / 180 * Math.PI,
                sina = Math.sin(theta),
                cosa = Math.cos(theta),
                resolution = this.viewpoint.resolution,
                center = this.viewpoint.center;
            var rxmove = xmove * cosa - ymove * sina,
                rymove = xmove * sina + ymove * cosa;
            var deltax = resolution * rxmove,
                deltay = resolution * rymove;
            this.viewpoint.setCenter([center[0] - deltax, center[1] + deltay]);
            this.viewpoint.calcMatrix(true);
            this.threeRender();
        }
    };

    SceneView.prototype.stopMove = function () {
        if (this.panEnabled) {
            this.refresh(true);
        }
    };

    /**
     * 
     * @param {number} x x
     * @param {number} y y
     */
    SceneView.prototype.pan = function (x, y) {
        var center = this.viewpoint.center;
        this.viewpoint.setCenter([center[0] + x, center[1] + y]);
        this.viewpoint.calcMatrix(true);
        this.zoomHistory.update(this.viewpoint.level, utils.now());
        this.viewpoint.calcMatrix(true);
        this._bound = this.viewpoint.calcBounds();
        this._extentDirty = true;
        this.allLayerViews.forEach(function (item) {
            item.refresh();
        });
        this.threeRender();
    };

    SceneView.prototype._mouseRotate = function (move) {
        if (this.rotateEnabled) {
            var angle = move / 1080 * 180;
            this.viewpoint.angle = (this.viewpoint.angle - angle) % 360;
            this.viewpoint.updateBaseMatrix();
            this.threeRender();
            topic.publish("mapRotateAngle", this.viewpoint.angle);
        }
    };

    SceneView.prototype._stopMouseRotate = function () {
        if (this.rotateEnabled) {
            this.refresh(true);
        }
    };

    /**
     * 
     * @param {number} angle , 
     */
    SceneView.prototype.rotateMap = function (angle) {
        if (this.rotateEnabled) {
            this.viewpoint.oldAngle = this.viewpoint.angle;
            this.viewpoint.angle = (this.viewpoint.angle + angle) % 360;
            this.viewpoint.deltaAngle = angle;
            topic.publish("mapRotateAngle", this.viewpoint.angle);
            this.viewpoint.updateBaseMatrix();
            this._bound = this.viewpoint.calcBounds();
            this._extentDirty = true;
            this._handleRotate();
        }
    };

    SceneView.prototype._handleRotate = function () {
        this.allLayerViews.forEach(function (item) {
            item._readyData();
        });
        this._nochanging = false;
        this._rotateAnimation(null, this.viewpoint.deltaAngle, 0);
    };

    SceneView.prototype._rotateAnimation = function (start, rad, d) {
        if (!start) start = performance.now();
        var delta = performance.now() - start;
        var center = this.viewpoint.center;
        if (delta >= 300) {
            window.cancelAnimationFrame(this._animateRaf);
            this._nochanging = true;
            this.viewpoint.angle = this.viewpoint.oldAngle + rad;
            this.viewpoint.updateBaseMatrix();
            this.handlePushViewState();
            this.threeRender();
        } else {
            this.viewpoint.angle = this.viewpoint.oldAngle + rad * delta / 300;
            this.viewpoint.updateBaseMatrix();
            this.animate();
            this._animateRaf = window.requestAnimationFrame(this._rotateAnimation.bind(this, start, rad, delta));
        }
    };

    SceneView.prototype._mouseSwitchDip = function (ymove) {
        if (this.rotateEnabled) {
            this.viewpoint.updatePitch(-ymove / 20);
            this.threeRender();
        }
    };

    SceneView.prototype._stopSwitch = function () {
        if (this.rotateEnabled) {
            this.refresh(true);

        }
    };

    /**
     * 23
     * @param {number} d 23
     */
    SceneView.prototype.setDimensions = function (d) {
        if (d === 2 && this.viewpoint.pitch !== 0) {
            this.viewpoint.oldPitch = this.viewpoint.pitch;
            this.viewpoint.pitch = 0;
            this.viewpoint.deltaPitch = this.viewpoint.pitch - this.viewpoint.oldPitch;
            topic.publish("mapSwitchDimension", 2);
            this.viewpoint.updateBaseMatrix();
            this._bound = this.viewpoint.calcBounds();
            this._extentDirty = true;
            this._handleSwitch2D();
        } else if (d === 3 && this.viewpoint.pitch !== 50) {
            this.viewpoint.oldPitch = this.viewpoint.pitch;
            this.viewpoint.pitch = 50;
            this.viewpoint.deltaPitch = this.viewpoint.pitch - this.viewpoint.oldPitch;
            topic.publish("mapSwitchDimension", 3);
            this.viewpoint.updateBaseMatrix();
            this._bound = this.viewpoint.calcBounds();
            this._extentDirty = true;
            this._handleSwitch3D();
        }
    };

    SceneView.prototype._handleSwitch2D = function () {
        this.allLayerViews.forEach(function (item) {
            item._readyData();
        });
        this._nochanging = false;
        this._switchAnimation(null, this.viewpoint.deltaPitch);
    };

    SceneView.prototype._handleSwitch3D = function () {
        this.allLayerViews.forEach(function (item) {
            item._readyData();
        });
        this._nochanging = false;
        this._switchAnimation(null, this.viewpoint.deltaPitch);
    };

    SceneView.prototype._switchAnimation = function (start, rad) {
        if (!start) start = performance.now();
        var delta = performance.now() - start;
        if (delta >= 500) {
            window.cancelAnimationFrame(this._animateRaf);
            this._nochanging = true;
            this.viewpoint.pitch = this.viewpoint.oldPitch + rad;
            this.viewpoint.updateBaseMatrix();
            this.handlePushViewState();
            this.threeRender();
        } else {
            this.viewpoint.pitch = this.viewpoint.oldPitch + rad * delta / 500;
            this.viewpoint.updateBaseMatrix();
            this.animate();
            this._animateRaf = window.requestAnimationFrame(this._switchAnimation.bind(this, start, rad));
        }
    };

    SceneView.prototype.animate = function () {
        if (!this._renderRaf) {
            this._renderRaf = requestAnimationFrame(function () {
                this._renderRaf = null;
                this._gl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                this._gl.clear(this._clearBit);
                this.currentLayer = 0;
                this.context.setDefault();
                this._drawBackgroundImage();
                this.allLayerViews.forEach(function (item) {
                    item.zoom();
                });
            }.bind(this));
        }
    };

    SceneView.prototype.setCustomLayerDefaults = function () {
        this.context.unbindVAO();
        this.context.cullFace.setDefault();
        this.context.activeTexture.setDefault();
        this.context.pixelStoreUnpack.setDefault();
        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault();
        this.context.pixelStoreUnpackFlipY.setDefault();
    };

    SceneView.prototype.setBaseState = function setBaseState() {
        var gl = this.context.gl;
        this.context.cullFace.set(false);
        this.context.viewport.set([0, 0, this.width, this.height]);
        this.context.blendEquation.set(gl.FUNC_ADD);
    };

    SceneView.prototype.queryFeaturesByGeometry = function (geometry, queryPadding, callback) {
        var layers = this.map.allLayers;
        var promises = [];
        var result = {};
        var promiseLayer = [];
        layers.forEach(function (layer) {
            if (layer.selectEnabled) {
                var features = layer.queryFeaturesByGeometry(geometry, queryPadding);
                if (features instanceof Promise) { // 
                    promises.push(features);
                    promiseLayer.push(layer.id);
                } else {
                    result[layer.id] = features;
                }
            }
        });
        if (promises.length > 0) {
            new DeferredList(promises).then(function (resp) {
                resp.forEach(function (response, index) {
                    if (response[0]) {
                        result[promiseLayer[index]] = response[1].results;
                    }
                });
                if (callback) callback(result);
            });
        } else {
            if (callback) callback(result);
        }
    };

    SceneView.prototype.queryRenderFeaturesByGeometry = function (geometry, queryPadding, callback) {
        var layers = this.map.allLayers;
        var promises = [];
        var result = {};
        var promiseLayer = [];
        layers.forEach(function (layer) {
            if (layer.selectEnabled) {
                var features = layer.queryRenderFeaturesByGeometry(geometry, queryPadding);
                if (features instanceof Promise) { // 
                    promises.push(features);
                    promiseLayer.push(layer.id);
                } else {
                    result[layer.id] = features;
                }
            }
        });
        if (promises.length > 0) {
            new DeferredList(promises).then(function (resp) {
                resp.forEach(function (response, index) {
                    if (response[0]) {
                        result[promiseLayer[index]] = response[1].results;
                    }
                });
                if (callback) callback(result);
            });
        } else {
            if (callback) callback(result);
        }
    };

    /**
     * 
     * @param {Function} callback 
     */
    SceneView.prototype.addTask = function (callback) {
        this._renderRaf = requestAnimationFrame(function () {
            this._renderRaf = null;
            this._gl.clear(this._clearBit);
            this.currentLayer = 0;
            this.depthRangeFor3D = [0, 1 - ((1 + 2) * this.numSublayers * this.depthEpsilon)];
            this.context.setDefault();
            this.allLayerViews.forEach(function (item) {
                item._render();
            });
            if (this.allLayerViews[0]._fadeDirty) { // , 
                this.allLayerViews[0]._fadeDirty = false;
                this.threeRender();
            } else {
                callback();
            }
        }.bind(this));
    };

    /**
     * , 
     */
    SceneView.prototype.resetExtent = function () {
        if (this._initState) {
            this.viewpoint.setView(this._initState);
            this.refresh(true);
        }
    };

    SceneView.prototype.calcBounds = function (xmin, xmax, ymin, ymax) {
        return this.viewpoint.calcBound(xmin, xmax, ymin, ymax);
    };

    SceneView.prototype.callHooks = function (type) {
        var hooks = this[type];
        hooks.forEach(function (item) {
            item();
        });
    };

    SceneView.prototype.loadItem = function (items) {
        this.graphicsIndex.load(items);
    };

    SceneView.prototype.insertItems = function (items) {
        for (var i = 0, ii = items.length; i < ii; i++) {
            this.graphicsIndex.insert(items[i]);
        }
    };

    /**
     * , 
     * @param {Geometry} geometry , 
     * @param {number} queryPadding 
     * @return {Array} 
     */
    SceneView.prototype.queryGraphicsByGeometry = function (geometry, queryPadding) {
        queryPadding = queryPadding || 0;
        switch (geometry.type) {
            case "point":
                geometry = [geometry];
                break;
        }
        var obj = {};
        var items = this.graphicsIndex.query(geometry, queryPadding, this.resolution);
        var results = [];
        for (var i = 0, ii = items.length; i < ii; i++) {
            var item = items[i];
            if (!item.g.selectEnabled) { // 
                continue;
            }
            if (item.hasOwnProperty('symbol')) { // 
                var g = item.g;
                var geo = g.feature.geometry;
                if (geo.type === "multipolygon") {
                    var polygons = geo.polygons;
                    for (var k = 0; k < polygons.length; k++) {
                        var polygon = polygons[k];
                        if (queryIntersects[item.symbol.type](geometry, polygon, item.symbol, this.resolution, g.feature.geometry.radius, this.viewpoint)) {
                            if (!obj.hasOwnProperty(item.id)) {
                                results.push(item.g);
                                obj[item.id] = true;
                            }
                            break;
                        }
                    }
                } else {
                    if (queryIntersects[item.symbol.type](geometry, item.g.feature.geometry, item.symbol, this.resolution, g.feature.geometry.radius, this.viewpoint)) {
                        if (!obj.hasOwnProperty(item.id)) {
                            results.push(item.g);
                            obj[item.id] = true;
                        }
                    }
                }
            } else {
                if (!obj.hasOwnProperty(item.id)) {
                    results.push(item.g);
                    obj[item.id] = true;
                }
            }
        }
        return results;
    };

    SceneView.prototype.queryGraphicByDevId = function (devId) {
        var graphicIsOk;
        for (var i = 0, ii = this.allLayerViews; i < ii.length; i++) {
            if (ii[i].layer.graphics.length > 0 && ii[i].graphicsLayerView.id !== "labelLayer") {
                for (var j = 0, jj = ii[i].layer.graphics; j < jj.length; j++) {
                    jj[j].feature.attributes.forEach(element => {
                        if (element.name === "dev_id") {
                            if (element.value === devId) {
                                graphicIsOk = jj[j];
                            }
                        }
                    });
                }
            }
        }
        if (graphicIsOk !== undefined) {
            return graphicIsOk;
        } else {
            return null;
        }
    }

    SceneView.prototype.queryGraphicSizeByPoint = function (point, computePolygon) {
        var items = this.graphicsIndex.query([point], 0, this.resolution);
        var xmin = Infinity,
            ymin = Infinity,
            xmax = -Infinity,
            ymax = -Infinity;
        var filterPolygon = !computePolygon;
        for (var i = 0, ii = items.length; i < ii; i++) {
            var item = items[i];
            if (item.symbol && filterPolygon) continue;
            if (item.minX < xmin) {
                xmin = item.minX;
            }
            if (item.minY < ymin) {
                ymin = item.minY;
            }
            if (item.maxX > xmax) {
                xmax = item.maxX;
            }
            if (item.maxY > ymax) {
                ymax = item.maxY;
            }
        }
        return {
            xmin: xmin,
            ymin: ymin,
            xmax: xmax,
            ymax: ymax,
            width: Math.abs(xmax - xmin),
            height: Math.abs(ymax - ymin)
        };
    };

    SceneView.prototype.checkExtentState = function (xmin, ymin, xmax, ymax, intersectLine) {
        if (intersectLine === undefined) intersectLine = true;
        var items = this.graphicsIndex.checkExtentState(xmin, ymin, xmax, ymax);
        /*for (var i = 0, ii = items.length; i < ii; i++) {
            var item = items[i];
            if (item.hasOwnProperty('symbol')) { // 
                var g = item.g;
                if (queryIntersects[item.symbol.type](new Point((xmin+xmax)/2, (ymin + ymax)/2), g.feature.geometry, item.symbol, this.resolution, g.feature.geometry.radius, this.viewpoint)) {
                    return true;
                }
            } else {
                return true;
            }
        }
        return false;*/
        var polygon = [
            new Point(xmin, ymax),
            new Point(xmax, ymax),
            new Point(xmax, ymin),
            new Point(xmin, ymin),
        ];
        for (var i = 0, ii = items.length; i < ii; i++) {
            var item = items[i];
            if (!item.hasOwnProperty('symbol')) { // 
                return true;
            } else {
                var g = item.g;
                // 
                if (intersectLine && queryIntersects["line"](polygon, g.feature.geometry, item.symbol, this.resolution, g.feature.geometry.radius, this.viewpoint)) {
                    return true;
                }
            }
        }
        return false;
    };

    /**
     * 
     */
    SceneView.prototype.clear = function () {
        this.graphicsIndex.clear();
        this.map.clear();
        this.allLayerViews = [];
        this.threeRender();
    }

    SceneView.prototype.setBackgroundColor = function (newColor) {
        this.backgroundColor = Color.parse(newColor);
        this.threeRender();
    }

    SceneView.prototype.destroy = function () {
        this.graphicsIndex.clear();
        this.map.clear();
        this.allLayerViews = [];
        domConstruct.destroy(this.domNode);
    }


    SceneView.prototype.requestRenderFrame = function (callback) {
        return this._renderTaskQueue.add(callback);
    }

    SceneView.prototype.cancelRenderFrame = function (id) {
        this._renderTaskQueue.remove(id);
    }

    /**
     * 
     */
    SceneView.prototype.threeRender = function () {
        if (!this._renderRaf && this._nochanging && !this.viewpoint.matrixDirty) {
            this._renderRaf = requestAnimationFrame(function () {
                this._renderRaf = null;
                if (!this._nochanging) {
                    return;
                }
                this._renderTaskQueue.run(this);


                this._gl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                this._gl.clear(this._clearBit);
                this.context.setDefault();

                this.currentLayer = 0;
                this.depthRangeFor3D = [0, 1 - ((1 + 2) * this.numSublayers * this.depthEpsilon)];
                this.allLayerViews.forEach(function (item) {
                    item._render();
                });
                this._drawBackgroundImage();
                if (this.allLayerViews.length > 0) {
                    if (this.allLayerViews[0]._fadeDirty) { // , 
                        this.allLayerViews[0]._fadeDirty = false;
                        this.threeRender();
                    }
                }
            }.bind(this));
        }
    };

    SceneView.maxOverzooming = 10;
    SceneView.maxUnderzooming = 3;
    return SceneView;
});

},
'com/huayun/webgis/layers/support/OverscaledTileID':function(){
define([
    "./CanonicalTileID",
    "./funcUtils"
], function (CanonicalTileID, funcUtils) {

    var UnwrappedTileID = function UnwrappedTileID(wrap, canonical) {
        this.wrap = wrap;
        this.canonical = canonical;
        this.key = funcUtils.calculateKey(wrap, canonical.z, canonical.x, canonical.y);
    };

    var OverscaledTileID = function OverscaledTileID(overscaledZ, wrap, z, x, y) {
        this.overscaledZ = overscaledZ;
        this.wrap = wrap;
        this.canonical = new CanonicalTileID(z, +x, +y);
        this.key = funcUtils.calculateKey(wrap, overscaledZ, x, y);
    };

    OverscaledTileID.prototype.equals = function equals(id) {
        return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);
    };

    OverscaledTileID.prototype.scaledTo = function scaledTo(targetZ) {
        var zDifference = this.canonical.z - targetZ;
        if (targetZ > this.canonical.z) {
            return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        } else {
            return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);
        }
    };

    OverscaledTileID.prototype.isChildOf = function isChildOf(parent) {
        if (parent.wrap !== this.wrap) {
            // We can't be a child if we're in a different world copy
            return false;
        }
        var zDifference = this.canonical.z - parent.canonical.z;
        // We're first testing for z == 0, to avoid a 32 bit shift, which is undefined.
        return parent.overscaledZ === 0 || (
            parent.overscaledZ < this.overscaledZ &&
            parent.canonical.x === (this.canonical.x >> zDifference) &&
            parent.canonical.y === (this.canonical.y >> zDifference));
    };

    /**
     * 
     * @param sourceMaxZoom
     * @return {[OverscaledTileID, OverscaledTileID, OverscaledTileID, OverscaledTileID]|[OverscaledTileID]}
     */
    OverscaledTileID.prototype.children = function children(sourceMaxZoom) {
        if (this.overscaledZ >= sourceMaxZoom) {
            return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        }

        var z = this.canonical.z + 1;
        var x = this.canonical.x * 2;
        var y = this.canonical.y * 2;
        return [
            new OverscaledTileID(z, this.wrap, z, x, y),
            new OverscaledTileID(z, this.wrap, z, x + 1, y),
            new OverscaledTileID(z, this.wrap, z, x, y + 1),
            new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)
        ];
    };

    OverscaledTileID.prototype.isLessThan = function isLessThan(rhs) {
        if (this.wrap < rhs.wrap) {
            return true;
        }
        if (this.wrap > rhs.wrap) {
            return false;
        }

        if (this.overscaledZ < rhs.overscaledZ) {
            return true;
        }
        if (this.overscaledZ > rhs.overscaledZ) {
            return false;
        }

        if (this.canonical.x < rhs.canonical.x) {
            return true;
        }
        if (this.canonical.x > rhs.canonical.x) {
            return false;
        }

        if (this.canonical.y < rhs.canonical.y) {
            return true;
        }
        return false;
    };

    OverscaledTileID.prototype.wrapped = function wrapped() {
        return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
    };

    OverscaledTileID.prototype.unwrapTo = function unwrapTo(wrap) {
        return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);
    };

    OverscaledTileID.prototype.overscaleFactor = function overscaleFactor() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
    };

    OverscaledTileID.prototype.toUnwrapped = function toUnwrapped() {
        return new UnwrappedTileID(this.wrap, this.canonical);
    };

    OverscaledTileID.prototype.toString = function toString() {
        return ((this.overscaledZ) + "/" + (this.canonical.x) + "/" + (this.canonical.y));
    };

    OverscaledTileID.prototype.getTilePoint = function getTilePoint(coord) {
        return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));
    };

    return OverscaledTileID;
});
},
'com/huayun/webgis/data/struct':function(){
define([
    "exports"
], function (exports) {
    var Struct = function Struct(structArray, index) {
        (this)._structArray = structArray;
        this._pos1 = index * this.size;
        this._pos2 = this._pos1 / 2;
        this._pos4 = this._pos1 / 4;
        this._pos8 = this._pos1 / 8;
    };

    var SymbolInstanceStruct = (function (Struct) {
        function SymbolInstanceStruct() {
            Struct.apply(this, arguments);
        }

        if (Struct) SymbolInstanceStruct.__proto__ = Struct;
        SymbolInstanceStruct.prototype = Object.create(Struct && Struct.prototype);
        SymbolInstanceStruct.prototype.constructor = SymbolInstanceStruct;

        var prototypeAccessors$2 = {
            anchorX: {configurable: true},
            anchorY: {configurable: true},
            rightJustifiedTextSymbolIndex: {configurable: true},
            centerJustifiedTextSymbolIndex: {configurable: true},
            leftJustifiedTextSymbolIndex: {configurable: true},
            verticalPlacedTextSymbolIndex: {configurable: true},
            key: {configurable: true},
            textBoxStartIndex: {configurable: true},
            textBoxEndIndex: {configurable: true},
            iconBoxStartIndex: {configurable: true},
            iconBoxEndIndex: {configurable: true},
            featureIndex: {configurable: true},
            numHorizontalGlyphVertices: {configurable: true},
            numVerticalGlyphVertices: {configurable: true},
            numIconVertices: {configurable: true},
            crossTileID: {configurable: true},
            textBoxScale: {configurable: true},
            radialTextOffset: {configurable: true}
        };

        prototypeAccessors$2.anchorX.get = function () {
            return this._structArray.int16[this._pos2 + 0];
        };
        prototypeAccessors$2.anchorX.set = function (x) {
            this._structArray.int16[this._pos2 + 0] = x;
        };
        prototypeAccessors$2.anchorY.get = function () {
            return this._structArray.int16[this._pos2 + 1];
        };
        prototypeAccessors$2.anchorY.set = function (x) {
            this._structArray.int16[this._pos2 + 1] = x;
        };
        prototypeAccessors$2.rightJustifiedTextSymbolIndex.get = function () {
            return this._structArray.int16[this._pos2 + 2];
        };
        prototypeAccessors$2.rightJustifiedTextSymbolIndex.set = function (x) {
            this._structArray.int16[this._pos2 + 2] = x;
        };
        prototypeAccessors$2.centerJustifiedTextSymbolIndex.get = function () {
            return this._structArray.int16[this._pos2 + 3];
        };
        prototypeAccessors$2.centerJustifiedTextSymbolIndex.set = function (x) {
            this._structArray.int16[this._pos2 + 3] = x;
        };
        prototypeAccessors$2.leftJustifiedTextSymbolIndex.get = function () {
            return this._structArray.int16[this._pos2 + 4];
        };
        prototypeAccessors$2.leftJustifiedTextSymbolIndex.set = function (x) {
            this._structArray.int16[this._pos2 + 4] = x;
        };
        prototypeAccessors$2.verticalPlacedTextSymbolIndex.get = function () {
            return this._structArray.int16[this._pos2 + 5];
        };
        prototypeAccessors$2.verticalPlacedTextSymbolIndex.set = function (x) {
            this._structArray.int16[this._pos2 + 5] = x;
        };
        prototypeAccessors$2.key.get = function () {
            return this._structArray.uint16[this._pos2 + 6];
        };
        prototypeAccessors$2.key.set = function (x) {
            this._structArray.uint16[this._pos2 + 6] = x;
        };
        prototypeAccessors$2.textBoxStartIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 7];
        };
        prototypeAccessors$2.textBoxStartIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 7] = x;
        };
        prototypeAccessors$2.textBoxEndIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 8];
        };
        prototypeAccessors$2.textBoxEndIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 8] = x;
        };
        prototypeAccessors$2.iconBoxStartIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 9];
        };
        prototypeAccessors$2.iconBoxStartIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 9] = x;
        };
        prototypeAccessors$2.iconBoxEndIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 10];
        };
        prototypeAccessors$2.iconBoxEndIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 10] = x;
        };
        prototypeAccessors$2.featureIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 11];
        };
        prototypeAccessors$2.featureIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 11] = x;
        };
        prototypeAccessors$2.numHorizontalGlyphVertices.get = function () {
            return this._structArray.uint16[this._pos2 + 12];
        };
        prototypeAccessors$2.numHorizontalGlyphVertices.set = function (x) {
            this._structArray.uint16[this._pos2 + 12] = x;
        };
        prototypeAccessors$2.numVerticalGlyphVertices.get = function () {
            return this._structArray.uint16[this._pos2 + 13];
        };
        prototypeAccessors$2.numVerticalGlyphVertices.set = function (x) {
            this._structArray.uint16[this._pos2 + 13] = x;
        };
        prototypeAccessors$2.numIconVertices.get = function () {
            return this._structArray.uint16[this._pos2 + 14];
        };
        prototypeAccessors$2.numIconVertices.set = function (x) {
            this._structArray.uint16[this._pos2 + 14] = x;
        };
        prototypeAccessors$2.crossTileID.get = function () {
            return this._structArray.uint32[this._pos4 + 8];
        };
        prototypeAccessors$2.crossTileID.set = function (x) {
            this._structArray.uint32[this._pos4 + 8] = x;
        };
        prototypeAccessors$2.textBoxScale.get = function () {
            return this._structArray.float32[this._pos4 + 9];
        };
        prototypeAccessors$2.textBoxScale.set = function (x) {
            this._structArray.float32[this._pos4 + 9] = x;
        };
        prototypeAccessors$2.radialTextOffset.get = function () {
            return this._structArray.float32[this._pos4 + 10];
        };
        prototypeAccessors$2.radialTextOffset.set = function (x) {
            this._structArray.float32[this._pos4 + 10] = x;
        };

        Object.defineProperties(SymbolInstanceStruct.prototype, prototypeAccessors$2);

        return SymbolInstanceStruct;
    }(Struct));
    SymbolInstanceStruct.prototype.size = 44;

    var PlacedSymbolStruct = (function (Struct) {
        function PlacedSymbolStruct() {
            Struct.apply(this, arguments);
        }

        if (Struct) PlacedSymbolStruct.__proto__ = Struct;
        PlacedSymbolStruct.prototype = Object.create(Struct && Struct.prototype);
        PlacedSymbolStruct.prototype.constructor = PlacedSymbolStruct;

        var prototypeAccessors$1 = {
            anchorX: {configurable: true},
            anchorY: {configurable: true},
            glyphStartIndex: {configurable: true},
            numGlyphs: {configurable: true},
            vertexStartIndex: {configurable: true},
            lineStartIndex: {configurable: true},
            lineLength: {configurable: true},
            segment: {configurable: true},
            lowerSize: {configurable: true},
            upperSize: {configurable: true},
            lineOffsetX: {configurable: true},
            lineOffsetY: {configurable: true},
            writingMode: {configurable: true},
            hidden: {configurable: true},
            crossTileID: {configurable: true}
        };

        prototypeAccessors$1.anchorX.get = function () {
            return this._structArray.int16[this._pos2 + 0];
        };
        prototypeAccessors$1.anchorX.set = function (x) {
            this._structArray.int16[this._pos2 + 0] = x;
        };
        prototypeAccessors$1.anchorY.get = function () {
            return this._structArray.int16[this._pos2 + 1];
        };
        prototypeAccessors$1.anchorY.set = function (x) {
            this._structArray.int16[this._pos2 + 1] = x;
        };
        prototypeAccessors$1.glyphStartIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 2];
        };
        prototypeAccessors$1.glyphStartIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 2] = x;
        };
        prototypeAccessors$1.numGlyphs.get = function () {
            return this._structArray.uint16[this._pos2 + 3];
        };
        prototypeAccessors$1.numGlyphs.set = function (x) {
            this._structArray.uint16[this._pos2 + 3] = x;
        };
        prototypeAccessors$1.vertexStartIndex.get = function () {
            return this._structArray.uint32[this._pos4 + 2];
        };
        prototypeAccessors$1.vertexStartIndex.set = function (x) {
            this._structArray.uint32[this._pos4 + 2] = x;
        };
        prototypeAccessors$1.lineStartIndex.get = function () {
            return this._structArray.uint32[this._pos4 + 3];
        };
        prototypeAccessors$1.lineStartIndex.set = function (x) {
            this._structArray.uint32[this._pos4 + 3] = x;
        };
        prototypeAccessors$1.lineLength.get = function () {
            return this._structArray.uint32[this._pos4 + 4];
        };
        prototypeAccessors$1.lineLength.set = function (x) {
            this._structArray.uint32[this._pos4 + 4] = x;
        };
        prototypeAccessors$1.segment.get = function () {
            return this._structArray.uint16[this._pos2 + 10];
        };
        prototypeAccessors$1.segment.set = function (x) {
            this._structArray.uint16[this._pos2 + 10] = x;
        };
        prototypeAccessors$1.lowerSize.get = function () {
            return this._structArray.uint16[this._pos2 + 11];
        };
        prototypeAccessors$1.lowerSize.set = function (x) {
            this._structArray.uint16[this._pos2 + 11] = x;
        };
        prototypeAccessors$1.upperSize.get = function () {
            return this._structArray.uint16[this._pos2 + 12];
        };
        prototypeAccessors$1.upperSize.set = function (x) {
            this._structArray.uint16[this._pos2 + 12] = x;
        };
        prototypeAccessors$1.lineOffsetX.get = function () {
            return this._structArray.float32[this._pos4 + 7];
        };
        prototypeAccessors$1.lineOffsetX.set = function (x) {
            this._structArray.float32[this._pos4 + 7] = x;
        };
        prototypeAccessors$1.lineOffsetY.get = function () {
            return this._structArray.float32[this._pos4 + 8];
        };
        prototypeAccessors$1.lineOffsetY.set = function (x) {
            this._structArray.float32[this._pos4 + 8] = x;
        };
        prototypeAccessors$1.writingMode.get = function () {
            return this._structArray.uint8[this._pos1 + 36];
        };
        prototypeAccessors$1.writingMode.set = function (x) {
            this._structArray.uint8[this._pos1 + 36] = x;
        };
        prototypeAccessors$1.hidden.get = function () {
            return this._structArray.uint8[this._pos1 + 37];
        };
        prototypeAccessors$1.hidden.set = function (x) {
            this._structArray.uint8[this._pos1 + 37] = x;
        };
        prototypeAccessors$1.crossTileID.get = function () {
            return this._structArray.uint32[this._pos4 + 10];
        };
        prototypeAccessors$1.crossTileID.set = function (x) {
            this._structArray.uint32[this._pos4 + 10] = x;
        };

        Object.defineProperties(PlacedSymbolStruct.prototype, prototypeAccessors$1);

        return PlacedSymbolStruct;
    }(Struct));

    PlacedSymbolStruct.prototype.size = 44;

    var CollisionBoxStruct = (function (Struct) {
        function CollisionBoxStruct() {
            Struct.apply(this, arguments);
        }

        if (Struct) CollisionBoxStruct.__proto__ = Struct;
        CollisionBoxStruct.prototype = Object.create(Struct && Struct.prototype);
        CollisionBoxStruct.prototype.constructor = CollisionBoxStruct;

        var prototypeAccessors = {
            anchorPointX: {configurable: true},
            anchorPointY: {configurable: true},
            x1: {configurable: true},
            y1: {configurable: true},
            x2: {configurable: true},
            y2: {configurable: true},
            featureIndex: {configurable: true},
            sourceLayerIndex: {configurable: true},
            bucketIndex: {configurable: true},
            radius: {configurable: true},
            signedDistanceFromAnchor: {configurable: true},
            anchorPoint: {configurable: true}
        };

        prototypeAccessors.anchorPointX.get = function () {
            return this._structArray.int16[this._pos2 + 0];
        };
        prototypeAccessors.anchorPointX.set = function (x) {
            this._structArray.int16[this._pos2 + 0] = x;
        };
        prototypeAccessors.anchorPointY.get = function () {
            return this._structArray.int16[this._pos2 + 1];
        };
        prototypeAccessors.anchorPointY.set = function (x) {
            this._structArray.int16[this._pos2 + 1] = x;
        };
        prototypeAccessors.x1.get = function () {
            return this._structArray.int16[this._pos2 + 2];
        };
        prototypeAccessors.x1.set = function (x) {
            this._structArray.int16[this._pos2 + 2] = x;
        };
        prototypeAccessors.y1.get = function () {
            return this._structArray.int16[this._pos2 + 3];
        };
        prototypeAccessors.y1.set = function (x) {
            this._structArray.int16[this._pos2 + 3] = x;
        };
        prototypeAccessors.x2.get = function () {
            return this._structArray.int16[this._pos2 + 4];
        };
        prototypeAccessors.x2.set = function (x) {
            this._structArray.int16[this._pos2 + 4] = x;
        };
        prototypeAccessors.y2.get = function () {
            return this._structArray.int16[this._pos2 + 5];
        };
        prototypeAccessors.y2.set = function (x) {
            this._structArray.int16[this._pos2 + 5] = x;
        };
        prototypeAccessors.featureIndex.get = function () {
            return this._structArray.uint32[this._pos4 + 3];
        };
        prototypeAccessors.featureIndex.set = function (x) {
            this._structArray.uint32[this._pos4 + 3] = x;
        };
        prototypeAccessors.sourceLayerIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 8];
        };
        prototypeAccessors.sourceLayerIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 8] = x;
        };
        prototypeAccessors.bucketIndex.get = function () {
            return this._structArray.uint16[this._pos2 + 9];
        };
        prototypeAccessors.bucketIndex.set = function (x) {
            this._structArray.uint16[this._pos2 + 9] = x;
        };
        prototypeAccessors.radius.get = function () {
            return this._structArray.int16[this._pos2 + 10];
        };
        prototypeAccessors.radius.set = function (x) {
            this._structArray.int16[this._pos2 + 10] = x;
        };
        prototypeAccessors.signedDistanceFromAnchor.get = function () {
            return this._structArray.int16[this._pos2 + 11];
        };
        prototypeAccessors.signedDistanceFromAnchor.set = function (x) {
            this._structArray.int16[this._pos2 + 11] = x;
        };
        prototypeAccessors.anchorPoint.get = function () {
            return new pointGeometry(this.anchorPointX, this.anchorPointY);
        };

        Object.defineProperties(CollisionBoxStruct.prototype, prototypeAccessors);

        return CollisionBoxStruct;
    }(Struct));

    CollisionBoxStruct.prototype.size = 24;

    var FeatureIndexStruct = (function (Struct) {
        function FeatureIndexStruct () {
            Struct.apply(this, arguments);
        }

        if ( Struct ) FeatureIndexStruct.__proto__ = Struct;
        FeatureIndexStruct.prototype = Object.create( Struct && Struct.prototype );
        FeatureIndexStruct.prototype.constructor = FeatureIndexStruct;

        var prototypeAccessors$5 = { featureIndex: { configurable: true },sourceLayerIndex: { configurable: true },bucketIndex: { configurable: true } };

        prototypeAccessors$5.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 0]; };
        prototypeAccessors$5.featureIndex.set = function (x        ) { this._structArray.uint32[this._pos4 + 0] = x; };
        prototypeAccessors$5.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 2]; };
        prototypeAccessors$5.sourceLayerIndex.set = function (x        ) { this._structArray.uint16[this._pos2 + 2] = x; };
        prototypeAccessors$5.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 3]; };
        prototypeAccessors$5.bucketIndex.set = function (x        ) { this._structArray.uint16[this._pos2 + 3] = x; };

        Object.defineProperties( FeatureIndexStruct.prototype, prototypeAccessors$5 );

        return FeatureIndexStruct;
    }(Struct));

    FeatureIndexStruct.prototype.size = 8;

    // 
    exports.SymbolInstanceStruct = SymbolInstanceStruct;
    exports.PlacedSymbolStruct = PlacedSymbolStruct;
    exports.CollisionBoxStruct = CollisionBoxStruct;

    exports.FeatureIndexStruct = FeatureIndexStruct;
});
},
'com/huayun/webgis/views/3d/layers/GraphicLayerView3D':function(){
define([
    "dojo/_base/declare",
    "./LayerView3D",
    "com/huayun/webgis/gl/mode",
    "com/huayun/webgis/data/ArrayType",
    "com/huayun/webgis/gl/SegmentVector",
    "com/huayun/webgis/gl/glUtils"
], function (declare, LayerView3D, mode, ArrayType, SegmentVector, glUtils) {
    return declare("com.huayun.webgis.views.3d.layers.GraphicLayerView3D", [LayerView3D], {

        constructor: function (params) {
            declare.safeMixin(this, params);
            this.visible = params.visible;
            this.renderer = params.renderer;
            this.glow = params.glow;
            var viewportArray = new ArrayType.StructArrayLayout4i8();
            viewportArray.emplaceBack(-1, -1, 0, 0);
            viewportArray.emplaceBack(1, -1, 1, 0);
            viewportArray.emplaceBack(-1, 1, 0, 1);
            viewportArray.emplaceBack(1, 1, 1, 1);
            this.viewportBuffer = this.view.context.createVertexBuffer(viewportArray, [
                {name: "aPos", type: "Int16", components: 4, offset: 0}
            ]);
            this.viewportSegments = SegmentVector.simpleSegment(0, 0, 4, 2);

            var quadTriangleIndices = new ArrayType.StructArrayLayout3ui6();
            quadTriangleIndices.emplaceBack(0, 1, 2);
            quadTriangleIndices.emplaceBack(2, 1, 3);
            this.quadTriangleIndexBuffer = this.view.context.createIndexBuffer(quadTriangleIndices);
        },

        _readyData: function () {
        },
        _render: function () {
            var level = this.view.viewpoint.targetZoom || this.view.viewpoint.level;
            var show = true;
            if (this.layer.minLevel && level < this.layer.minLevel) {
                show = false;
            }
            if (this.layer.maxLevel && level >= this.layer.maxLevel) {
                show = false;
            }

            if (this.visible && show) {
                this.view.currentLayer++;
                this.depthRangeFor3D = [0, 1 - ((1 + this.view.currentLayer) * this.view.numSublayers) * this.view.depthEpsilon];
                var graphics = this.layer.graphics;
                var graphic, symbol;
                var filterGraphic = [];
                for (var i = 0; i < graphics.length; i++) {
                    graphic = graphics[i];
                    if (graphic.glow && graphic.visible && graphic.symbol) {
                        filterGraphic.push(graphic);
                    }
                }
                try {
                    if (filterGraphic.length > 0) { // 
                        var context = this.view.context;
                        var width = this.view.width,
                            height = this.view.height;
                        // framebuffer
                        this.bindFramebuffer(context, "renderFBO", width, height);
                        var gl = context.gl;
                        gl.clearColor(0.0, 0.0, 0.0, 0.0);
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        for (i = 0; i < filterGraphic.length; i++) {
                            graphic = filterGraphic[i];
                            symbol = graphic.symbol;
                            // graphic.renderer.draw[symbol.type](this, graphic, graphic.glow);
                            this.renderer.drawGlow(this.view, graphic, graphic.feature.geometry, symbol, this);
                        }
                        this.renderBlur(context, width, height); // 
                        context.bindFramebuffer.set(null);
                        context.viewport.set([0, 0, width, height]);
                        this.renderTextureToMap(context);
                        for (i = 0; i < graphics.length; i++) {
                            graphic = graphics[i];
                            symbol = graphic.symbol;
                            if (graphic.visible && symbol) {
                                this.renderer.draw(this.view, graphic, graphic.feature.geometry, symbol, this);
                                if (graphic.addHook) {
                                    graphic.addHook(graphic, this);
                                    graphic.addHook = null;
                                }
                            }
                        }
                    } else {
                        for (i = 0; i < graphics.length; i++) {
                            graphic = graphics[i];
                            symbol = graphic.symbol;
                            if (graphic.visible && symbol) {
                                this.renderer.draw(this.view, graphic, graphic.feature.geometry, symbol, this);
                                if (graphic.addHook) {
                                    graphic.addHook(graphic, this);
                                    graphic.addHook = null;
                                }
                            }
                        }
                    }
                }catch (e) {
                    console.log(e);
                }
            }
        },
        bindFramebuffer: function (context, targetFBOName, width, height) {
            var fbo = this[targetFBOName];

            if (!fbo || Math.abs((fbo.width - width)) > 1 || Math.abs(fbo.height - height) > 1) {
                fbo = this[targetFBOName] = glUtils.generateFBO(context, width, height);
            }
            context.bindFramebuffer.set(fbo.framebuffer);
        },

        renderBlur: function (context, width, height) {
            var gl = context.gl;
            var reductionRate = this.layer.glowRatio;
            // var reductionRate = 1; //this.layer.glowRatio;
            width = Math.ceil(width / reductionRate);
            height = Math.ceil(height / reductionRate);
            this.bindFramebuffer(context, "blurFBO", width, height);
            context.activeTexture.set(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.renderFBO.colorAttachment.get());

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            context.viewport.set([0, 0, width, height]);
            this.view.useProgramSimplify('gaussianBlur', {
                "layoutAttributes": {name: "aPos", type: "Int16", components: 4, offset: 0}
            }).draw(context, gl.TRIANGLES,
                mode.DepthMode.disabled, mode.StencilMode.disabled, mode.ColorMode.alphaBlended, mode.CullFaceMode.disabled,
                {
                    'uSize': [width, height],
                    'uTexture': 0,
                    'uHorizontal': 0,
                    'u_kernel': [0.8, 0.15, 0.1, 0.05, 0.01]
                },
                this.id, this.viewportBuffer, this.quadTriangleIndexBuffer,
                this.viewportSegments);

            this.bindFramebuffer(context, "blurFBO2", width, height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.bindTexture(gl.TEXTURE_2D, this.blurFBO.colorAttachment.get());
            this.view.useProgramSimplify('gaussianBlur', {
                "layoutAttributes": {name: "aPos", type: "Int16", components: 4, offset: 0}
            }).draw(context, gl.TRIANGLES,
                mode.DepthMode.disabled, mode.StencilMode.disabled, mode.ColorMode.alphaBlended, mode.CullFaceMode.disabled,
                {
                    'uSize': [width, height],
                    'uTexture': 0,
                    'uHorizontal': 1,
                    'u_kernel': [0.8, 0.15, 0.1, 0.05, 0.01]
                },
                this.id, this.viewportBuffer, this.quadTriangleIndexBuffer,
                this.viewportSegments);
        },

        renderTextureToMap: function (context) {
            var gl = context.gl;
            var fbo = this.blurFBO2;
            if (!fbo) {
                return;
            }
            context.activeTexture.set(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());

            this.view.useProgramSimplify('screen', {
                "layoutAttributes": {name: "aPos", type: "Int16", components: 4, offset: 0}
            }).draw(context, gl.TRIANGLES,
                mode.DepthMode.disabled, mode.StencilMode.disabled, mode.ColorMode.alphaBlended, mode.CullFaceMode.disabled,
                {
                    uTexture: 0
                },
                this.id, this.viewportBuffer, this.quadTriangleIndexBuffer,
                this.viewportSegments);
        },

        refresh: function () {
            this.view.threeRender();
        },

        addGraphic: function (graphic) {
            if (!graphic.position) {
                graphic.position = this.view.viewpoint.center;
            }
            if (graphic.symbol) {
                graphic.added = true;
                this.renderer.add(this.view, graphic, graphic.feature.geometry, graphic.symbol);
                graphic.addHook = function (g, layerView) {
                    var items = [];
                    layerView.renderer.calculateExtent(layerView.view, g, g.feature.geometry, g.symbol, items);
                    layerView.view.insertItems(items);
                }
            }
        },

        zoom: function () {
            if (this.visible) {
                this._render();
            }
        },
        depthModeForSublayer: function (n, mask, func) {
            // var depth = 1 - ((1 + this.view.currentLayer) * this.view.numSublayers + n) * this.view.depthEpsilon;
            // return new mode.DepthMode(func || this.view.context.gl.LEQUAL, mask, [depth, depth]);
            return new mode.DepthMode(this.view.context.gl.LEQUAL, mask, this.view.depthRangeFor3D);
            // new mode.DepthMode(func || this.view.context.gl.LEQUAL, mask, [0, 1]);
        },
        setVisible: function (value) {
            this.visible = value;
            this.view.threeRender();
        }

        /*remove:function(graphic){

        },



        _graphicRefresh: function () {

        },
        resize: function () {

        },

        */

    });
});

},
'com/huayun/webgis/symbols/LineSymbol':function(){
/**
 * 
 * @module com/huayun/webgis/symbols
 * @see com.huayun.webgis.symbols.LineSymbol
 */
define([
    "./Symbol",
    "../utils/Color"
], function (BaseSymbol, Color) {
    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.symbols.LineSymbol
     * @extends {Symbol}
     * @param {Object} params 
     * @param {String} params.color 
     * @param {Number} params.opacity 
     * @param {Number} params.width 
     * @param {String} params.style dash|solid 
     * @param {Array} params.dasharray , Canvas
     * @property {String} color 
     * @property {Number} opacity 
     * @property {Number} width 
     */
    var LineSymbol = function (params) {
        if (params) {
            BaseSymbol.call(this, params);
            this.type = "line";
            this.join = params.lineJoin || params.join || "miter";
            this.cap = params.lineCap || params.cap || "butt";
            var color = Color.parse(params.color || "#FF0000"),
                opacity = params.opacity === undefined ? 1 : params.opacity;
            this.width = Number(params.width); //params.width < 1?1:params.width;
            this.length = params.length || 8;
            this._color = [color.r, color.g, color.b, color.a];
            this.opacity = opacity;
            this.gapwidth = params.gapwidth === undefined ? 0 : params.gapwidth;
            this.offset = params.offset === undefined ? 0 : params.offset;
            this.minScale = params.minScale;
            this.maxScale = params.maxScale;

            if (params.style === "dash") {
                params.dasharray = [5, 5];
            } else if (params.style === "solid") {
                params.dasharray = null;
            }

            if (params.dasharray) { // 
                var dasharray = {
                    from: params.dasharray,
                    to: params.dasharray
                };
                this.dasharray = dasharray;
                /*var round = this.cap === "round";
                var posA = lineDashTexture.lineAtlas.getDash(dasharray.from, round);
                var posB = lineDashTexture.lineAtlas.getDash(dasharray.to, round);
                var widthA = posA.width * 2;
                var widthB = posB.width * 1;
                this.widthA = widthA;
                this.widthB = widthB;
                var width = lineDashTexture.lineAtlas.width;
                this.lineAtlas = lineDashTexture.lineAtlas;*/
                this.scaleDirty = true;
                this.uniforms = {
                    "u_ratio": 1,
                    "u_color": this.color,
                    "u_opacity": this.opacity,
                    "u_gapwidth": 0,
                    "u_width": this.width,
                    "u_blur": 0,
                    "u_offset": this.offset,
                    "u_floorwidth": 1,
                    /*'u_patternscale_a': [1 / widthA, -posA.height / 2],
                    'u_patternscale_b': [1 / widthB, -posB.height / 2],
                    'u_sdfgamma': width / (Math.min(widthA, widthB) * 256) / 2,
                    'u_tex_y_a': posA.y,
                    'u_tex_y_b': posB.y,*/
                    'u_mix': 1,
                    'ratio': 0.5
                };
            } else {
                this.uniforms = {
                    "u_ratio": 1,
                    "u_color": [color.r, color.g, color.b, color.a],
                    "u_blur": 0,
                    "u_opacity": this.opacity,
                    "u_gapwidth": this.gapwidth,
                    "u_offset": this.offset,
                    "u_width": this.width,
                    'ratio': 0.5
                };
            }
        }
    };
    if (BaseSymbol) LineSymbol.__proto__ = BaseSymbol;
    LineSymbol.prototype = Object.create(BaseSymbol && BaseSymbol.prototype);
    LineSymbol.prototype.constructor = LineSymbol;

    LineSymbol.prototype.setWidth = function (width) {
        this.uniforms["u_width"] = width;
    }

    LineSymbol.prototype.clone = function () {
        var cloneSymbol = new LineSymbol();
        cloneSymbol.type = "line";
        cloneSymbol.join = this.join;
        cloneSymbol.cap = this.cap;
        cloneSymbol.width = this.width;
        cloneSymbol.length = this.length;
        cloneSymbol.opacity = this.opacity;
        cloneSymbol.gapwidth = this.gapwidth;
        cloneSymbol.offset = this.offset;
        cloneSymbol.minScale = this.minScale;
        cloneSymbol.maxScale = this.maxScale;
        if (this.dasharray) {
            cloneSymbol.dasharray = this.dasharray;
            cloneSymbol.scaleDirty = this.scaleDirty;
            cloneSymbol.uniforms = this.uniforms;
        } else {
            cloneSymbol.uniforms = this.uniforms;
        }
        cloneSymbol.color = this.color;
        cloneSymbol.fixedSize = this.fixedSize;
        cloneSymbol.fixed = {
            isFixed: cloneSymbol.fixedSize,
            addratio: 0
        };
        return cloneSymbol;
    }

    var prototypeAccessors = {
        color: {configurable: true}
    };
    prototypeAccessors.color.set = function (value) {
        var color = Color.parse(value);
        this._color = [color.r, color.g, color.b, color.a];
        if (this.uniforms) this.uniforms['u_color'] = this._color;
    };
    prototypeAccessors.color.get = function () {
        return this._color;
    };

    Object.defineProperties(LineSymbol.prototype, prototypeAccessors);

    return LineSymbol;
});

},
'com/huayun/webgis/data/bucket/FillBucketSimplify':function(){
/**
 *  @author :   wushengfei
 *  @date   :   2019/7/24
 *  @description : OK
 */
define([
    "../ArrayType",
    "../../gl/SegmentVector",
    "../../utils/earcut",
    "../../utils/utils",
    "../../utils/Constant",
    "../../utils/classifyRings"
], function (ArrayType, SegmentVector, earcut, utils, Constant,classifyRings) {

    function FillBucket() {
        this.layoutVertexArray = new ArrayType.StructArrayLayout2f8();
        this.indexArray = new ArrayType.StructArrayLayout3ui6();
        this.segments = new SegmentVector();
    }

    FillBucket.prototype.addFeatures = function addFeatures(options, imagePositions) {
        for (var i = 0, list = this.features; i < list.length; i += 1) {
            var feature = list[i];

            var geometry = feature.geometry;
            this.addFeature(feature, geometry, feature.index, imagePositions);
        }
    };

    FillBucket.prototype.destroy = function destroy() {
        if (!this.layoutVertexBuffer) {
            return;
        }
        this.layoutVertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.segments.destroy();
    };

    FillBucket.prototype.addFeature = function addFeature(geometry) {
        for (var i$4 = 0, list$2 = classifyRings(geometry, Constant.layout.EARCUT_MAX_RINGS); i$4 < list$2.length; i$4 += 1) {
            var polygon = list$2[i$4];

            var numVertices = 0;
            for (var i$2 = 0, list = polygon; i$2 < list.length; i$2 += 1) {
                var ring = list[i$2];

                numVertices += ring.length;
            }

            var triangleSegment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);
            var triangleIndex = triangleSegment.vertexLength;

            var flattened = [];
            var holeIndices = [];

            for (var i$3 = 0, list$1 = polygon; i$3 < list$1.length; i$3 += 1) {
                var ring$1 = list$1[i$3];

                if (ring$1.length === 0) {
                    continue;
                }

                if (ring$1 !== polygon[0]) {
                    holeIndices.push(flattened.length / 2);
                }
                this.layoutVertexArray.emplaceBack(ring$1[0].x, ring$1[0].y);
                flattened.push(ring$1[0].x);
                flattened.push(ring$1[0].y);

                for (var i = 1; i < ring$1.length; i++) {
                    this.layoutVertexArray.emplaceBack(ring$1[i].x, ring$1[i].y);
                    flattened.push(ring$1[i].x);
                    flattened.push(ring$1[i].y);
                }
            }

            var indices = earcut.earcut(flattened, holeIndices);

            for (var i$1 = 0; i$1 < indices.length; i$1 += 3) {
                this.indexArray.emplaceBack(
                    triangleIndex + indices[i$1],
                    triangleIndex + indices[i$1 + 1],
                    triangleIndex + indices[i$1 + 2]);
            }
            triangleSegment.vertexLength += numVertices;
            triangleSegment.primitiveLength += indices.length / 3;
        }
    };

    FillBucket.prototype.upload = function upload(context) {
        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, [
            {name: "a_pos", type: "Float32", components: 2, offset: 0}
        ]);
        this.indexBuffer = context.createIndexBuffer(this.indexArray);
    };

    return FillBucket;
});
},
'com/huayun/core/EventEmitter':function(){
/**
 * 
 * @see com.huayun.core.EventEmitter
 */
define([], function () {
    var defaultMaxListeners = 10;

    function $getMaxListeners(that) {
        if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
    }

    function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
            copy[i] = arr[i];
        return copy;
    }

    function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== 'function') {
            throw new Error("listener must be function");
        }
        events = target._events;
        if (events === undefined) {
            events = target._events = Object.create(null);
            target._eventsCount = 0;
        } else {
            if (events.newListener !== undefined) {
                target.emit('newListener', type, listener.listener ? listener.listener : listener);
                events = target._events;
            }
            existing = events[type];
        }
        if (existing === undefined) {
            existing = events[type] = listener;
            ++target._eventsCount;
        } else {
            if (typeof existing === 'function') {
                existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else if (prepend) {
                existing.unshift(listener);
            } else {
                existing.push(listener);
            }
            m = $getMaxListeners(target);
            if (m > 0 && existing.length > m && !existing.warned) {
                console.warn("Possible EventEmitter memory leak detected.");
            }
        }
        return target;
    }

    function _onceWrap(target, type, listener) {
        var state = {
            fired: false,
            wrapFn: undefined,
            target: target,
            type: type,
            listener: listener
        };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
    }

    function onceWrapper() {
        if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            this.listener.apply(this.target, Array.prototype.slice.call(arguments, 0));
        }
    }

    function unwrapListeners(arr) {
        const ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
        }
        return ret;
    }

    function _listeners(target, type, unwrap) {
        const events = target._events;
        if (events === undefined)
            return [];
        const evlistener = events[type];
        if (evlistener === undefined)
            return [];
        if (typeof evlistener === 'function')
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];

        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }

    /**
     * , 
     * @private
     * @ignore
     * @constructor
     * @alias com.huayun.core.EventEmitter
     * @property {Object} _events Map
     * @property {Number} _eventsCount 
     */
    function EventEmitter() {
        EventEmitter.init.call(this);
    }

    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function () {
            return defaultMaxListeners;
        },
        set: function (arg) {
            if (typeof arg !== 'number' || arg < 0 || Number.isNaN(arg)) {
                throw new Error("defaultMaxListeners must be a positive number!");
            }
            defaultMaxListeners = arg;
        }
    })

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;

    EventEmitter.init = function () {
        if (this._events === undefined ||
            this._events === Object.getPrototypeOf(this)._events) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || undefined;
    }

    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {
            throw new Error("defaultMaxListeners must be a positive number!");
        }
        this._maxListeners = n;
        return this;
    };

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
    };

    EventEmitter.prototype.emit = function emit(type) {
        var doError = type === 'error';
        var events = this._events;
        if (events !== undefined)
            doError = (doError && events.error === undefined);
        else if (!doError)
            return false;
        if (doError) {
            var er;
            if (arguments.length > 1) {
                er = arguments[1];
            }
            if (er instanceof Error) {
                throw er;
            }
        }
        var handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === 'function') {
            handler.apply(this, Array.prototype.slice.call(arguments, 1));
        } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
                listeners[i].apply(this, Array.prototype.slice.call(arguments, 1));
        }
        return true;
    }

    EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
    };

    EventEmitter.prototype.once = function once(type, listener) {
        if (typeof listener !== 'function') {
            throw new Error("listener must be function!");
        }
        this.on(type, _onceWrap(this, type, listener));
        return this;
    };

    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        if (typeof listener !== 'function') {
            throw new Error("listener must be function!");
        }
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
    };

    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== 'function') {
            throw new Error("listener must be function!");
        }
        events = this._events;
        if (events === undefined)
            return this;
        list = events[type];
        if (list === undefined)
            return this;
        if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
                this._events = Object.create(null);
            else {
                delete events[type];
                if (events.removeListener)
                    this.emit('removeListener', type, list.listener || listener);
            }
        } else if (typeof list !== 'function') {
            position = -1;
            for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                }
            }
            if (position < 0)
                return this;
            if (position === 0)
                list.shift();
            else {
                list.splice(position, 1);
            }

            if (list.length === 1)
                events[type] = list[0];
            if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener);
        }
        return this;
    };

    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined)
            return this;
        if (events.removeListener === undefined) {
            if (arguments.length === 0) {
                this._events = Object.create(null);
                this._eventsCount = 0;
            } else if (events[type] !== undefined) {
                if (--this._eventsCount === 0)
                    this._events = Object.create(null);
                else
                    delete events[type];
            }
            return this;
        }
        if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
                key = keys[i];
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
        }
        listeners = events[type];
        if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
            for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i]);
            }
        }
        return this;
    };

    EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
    };

    EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
    };

    EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
            return emitter.listenerCount(type);
        } else {
            return listenerCount.call(emitter, type);
        }
    };

    EventEmitter.prototype.listenerCount = listenerCount;

    function listenerCount(type) {
        const events = this._events;
        if (events !== undefined) {
            const evlistener = events[type];
            if (typeof evlistener === 'function') {
                return 1;
            } else if (evlistener !== undefined) {
                return evlistener.length;
            }
        }
        return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Object.keys(this._events) : [];
    };

    return EventEmitter;
});
},
'com/huayun/webgis/views/3d/layers/LayerView3D':function(){
define([
    "../../layers/LayerView",
    "../../../utils/extendClazz"
], function (LayerView, extendClazz) {
    /**
     * @ignore
     * @param params
     * @constructor
     */
    function LayerView3D(params) {
        LayerView.call(this, params);
    }
    extendClazz(LayerView3D, LayerView);

    LayerView3D.prototype.resize = function () {

    }

    return LayerView3D;
});
},
'com/huayun/webgis/utils/image':function(){
define([
    "exports"
], function (exports) {
    function createImage(image, ref, channels, data) {
        var width = ref.width;
        var height = ref.height;

        if (!data) {
            data = new Uint8Array(width * height * channels);
        } else if (data instanceof Uint8ClampedArray) {
            data = new Uint8Array(data.buffer);
        } else if (data.length !== width * height * channels) {
            throw new RangeError('mismatched image size');
        }
        image.width = width;
        image.height = height;
        image.data = data;
        return image;
    }

    function resizeImage(image, ref, channels) {
        var width = ref.width;
        var height = ref.height;

        if (width === image.width && height === image.height) {
            return;
        }

        var newImage = createImage({}, {width: width, height: height}, channels);

        copyImage(image, newImage, {x: 0, y: 0}, {x: 0, y: 0}, {
            width: Math.min(image.width, width),
            height: Math.min(image.height, height)
        }, channels);
        image.width = width;
        image.height = height;
        image.data = newImage.data;
    }

    function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
        if (size.width === 0 || size.height === 0) {
            return dstImg;
        }

        if (size.width > srcImg.width ||
            size.height > srcImg.height ||
            srcPt.x > srcImg.width - size.width ||
            srcPt.y > srcImg.height - size.height) {
            throw new RangeError('out of range source coordinates for image copy');
        }

        if (size.width > dstImg.width ||
            size.height > dstImg.height ||
            dstPt.x > dstImg.width - size.width ||
            dstPt.y > dstImg.height - size.height) {
            throw new RangeError('out of range destination coordinates for image copy');
        }

        var srcData = srcImg.data;
        var dstData = dstImg.data;

        for (var y = 0; y < size.height; y++) {
            var srcOffset = ((srcPt.y + y) * srcImg.width + srcPt.x) * channels;
            var dstOffset = ((dstPt.y + y) * dstImg.width + dstPt.x) * channels;
            for (var i = 0; i < size.width * channels; i++) {
                dstData[dstOffset + i] = srcData[srcOffset + i];
            }
        }

        return dstImg;
    }

    var AlphaImage = function AlphaImage(size, data) {
        createImage(this, size, 1, data);
    };

    AlphaImage.prototype.resize = function resize(size) {
        resizeImage(this, size, 1);
    };

    AlphaImage.prototype.clone = function clone() {
        return new AlphaImage({width: this.width, height: this.height}, new Uint8Array(this.data));
    };

    AlphaImage.copy = function copy(srcImg, dstImg, srcPt, dstPt, size) {
        copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);
    };

    exports.AlphaImage = AlphaImage;

    var RGBAImage = function RGBAImage(size, data) {
        createImage(this, size, 4, data);
    };

    RGBAImage.prototype.resize = function resize(size) {
        resizeImage(this, size, 4);
    };

    RGBAImage.prototype.replace = function replace(data, copy) {
        if (copy) {
            this.data.set(data);
        } else if (data instanceof Uint8ClampedArray) {
            this.data = new Uint8Array(data.buffer);
        } else {
            this.data = data;
        }
    };

    RGBAImage.prototype.clone = function clone() {
        return new RGBAImage({width: this.width, height: this.height}, new Uint8Array(this.data));
    };

    RGBAImage.copy = function copy(srcImg, dstImg, srcPt, dstPt, size) {
        copyImage(srcImg, dstImg, srcPt, dstPt, size, 4);
    };

    exports.RGBAImage = RGBAImage;

    function renderColorRamp(expression, colorRampEvaluationParameter) {
        var colorRampData = new Uint8Array(256 * 4);
        var evaluationGlobals = {};
        for (var i = 0, j = 0; i < 256; i++, j += 4) {
            evaluationGlobals[colorRampEvaluationParameter] = i / 255;
            var pxColor = expression.evaluate(evaluationGlobals);
            colorRampData[j + 0] = Math.floor(pxColor.r * 255 / pxColor.a);
            colorRampData[j + 1] = Math.floor(pxColor.g * 255 / pxColor.a);
            colorRampData[j + 2] = Math.floor(pxColor.b * 255 / pxColor.a);
            colorRampData[j + 3] = Math.floor(pxColor.a * 255);
        }

        return new RGBAImage({width: 256, height: 1}, colorRampData);
    }

    exports.renderColorRamp = renderColorRamp;
});
},
'com/huayun/webgis/symbols/Symbol':function(){
/**
 * 
 * @module com/huayun/webgis/symbols
 * @see com.huayun.webgis.symbols.Symbol
 */
define([], function () {
    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.symbols.Symbol
     * @param {Object} params 
     * @param {number} params.minScale 
     * @param {number} params.maxScale 
     * @param {Boolean} params.isFixed , 
     * @property {number} minScale 
     * @property {number} maxScale 
     * @property {Object} fixed , 
     */
    function Symbol(params) {
        if(params){
            this.minScale = params.minScale === undefined ? 1 : params.minScale;
            this.maxScale = params.maxScale === undefined ? 1 : params.maxScale;
            this.dx = params.dx === undefined ? 0 : params.dx;
            this.dy = params.dy === undefined ? 0 : params.dy;
            if (params.isFixed === false) {
                this.isFixed = false;
            }else if (params.symbol === undefined) {
                this.isFixed = true;
            } else {
                this.isFixed = params.isFixed === undefined;
            }
            this.renderer = params.renderer === undefined ? null : params.renderer;
            this.fixed = {
                isFixed: this.isFixed,
                addratio: 0
            }
        }
    };

    Symbol.prototype.clone = function () {
    }

    return Symbol;
});

},
'com/huayun/webgis/layers/support/CanonicalTileID':function(){
define([
    "./funcUtils"
], function (funcUtils) {

    var CanonicalTileID = function CanonicalTileID(z, x, y) {
        this.z = z;
        this.x = x;
        this.y = y;
        this.key = funcUtils.calculateKey(0, z, x, y);
    };

    CanonicalTileID.prototype.equals = function equals(id) {
        return this.z === id.z && this.x === id.x && this.y === id.y;
    };

    CanonicalTileID.prototype.url = function url(urls, schema) {
        return urls[(this.x + this.y) % urls.length].replace('{z}', String(Math.round(this.z)))
            .replace('{x}', String(this.x))
            .replace('{y}', String(schema === 'tms'?(Math.pow(2, this.z) - this.y - 1): this.y));
    };

    CanonicalTileID.prototype.getTilePoint = function getTilePoint(coord) {

        /*var tilesAtZoom = Math.pow(2, this.z);
        return new pointGeometry(
            (coord.x * tilesAtZoom - this.x) * EXTENT,
            (coord.y * tilesAtZoom - this.y) * EXTENT);*/
    };

    return CanonicalTileID;
});
},
'com/huayun/webgis/layers/support/expression/Interpolate':function(){
define([
    "../style/styleUtils",
    "../../../utils/colorSpaces",
    "../UnitBezier"
], function (styleUtils, colorSpaces, UnitBezier) {

    /**
     * 
     * @private
     * @ignore
     * @param input 
     * @param base , 1
     * @param lowerValue 
     * @param upperValue 
     * @return {number}
     */
    function exponentialInterpolation(input, base, lowerValue, upperValue) {
        var difference = upperValue - lowerValue;
        var progress = input - lowerValue;
        if (difference === 0) {
            return 0;
        } else if (base === 1) {
            return progress / difference;
        } else {
            return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
        }
    }

    /**
     * , :
     * - ['linear']: 
     * - ['exponential', base]: 
     * - ['cubic-bezier', x1, y1, x2, y2]: ,
     * :
     * ["interpolate",
     *    interpolation: ["linear"] | ["exponential", base] | ["cubic-bezier", x1, y1, x2, y2]
     *    input: number,
     *    stop_input_1: number, stop_output_1: OutputType,
     *    stop_input_n: number, stop_output_n: OutputType, ...
     * ]
     * @private
     * @ignore
     * @param type
     * @param operator
     * @param interpolation
     * @param input
     * @param stops
     * @constructor
     */
    var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
        this.type = type;
        this.operator = operator;
        this.interpolation = interpolation;
        this.input = input;

        this.labels = [];
        this.outputs = [];
        for (var i = 0, list = stops; i < list.length; i += 1) {
            var ref = list[i];
            var label = ref[0];
            var expression = ref[1];

            this.labels.push(label);
            this.outputs.push(expression);
        }
    };

    Interpolate.interpolationFactor = function (interpolation, input, lower, upper) {
        var t = 0;
        if (interpolation.name === 'exponential') { // 
            t = exponentialInterpolation(input, interpolation.base, lower, upper);
        } else if (interpolation.name === 'linear') { // , 1
            t = exponentialInterpolation(input, 1, lower, upper);
        } else if (interpolation.name === 'cubic-bezier') { // 
            var c = interpolation.controlPoints;
            var ub = new UnitBezier(c[0], c[1], c[2], c[3]);
            t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
        }
        return t;
    };

    Interpolate.parse = function (args, context) {
        var operator = args[0]; // 
        var interpolation = args[1]; // 
        var input = args[2]; // 
        var rest = args.slice(3); // stops

        if (!Array.isArray(interpolation) || interpolation.length === 0) {
            return context.error("Expected an interpolation type expression.", 1);
        }

        if (interpolation[0] === 'linear') {
            interpolation = {name: 'linear'};
        } else if (interpolation[0] === 'exponential') {
            var base = interpolation[1];
            if (typeof base !== 'number') {
                return context.error("Exponential interpolation requires a numeric base.", 1, 1);
            }
            interpolation = {
                name: 'exponential',
                base: base
            };
        } else if (interpolation[0] === 'cubic-bezier') {
            var controlPoints = interpolation.slice(1);
            if (controlPoints.length !== 4 ||
                controlPoints.some(function (t) {
                    return typeof t !== 'number' || t < 0 || t > 1;
                })
            ) {
                return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
            }
            interpolation = {
                name: 'cubic-bezier',
                controlPoints: (controlPoints)
            };
        } else {
            return context.error("Unknown interpolation type " + String(interpolation[0]), 1, 0);
        }

        if (args.length - 1 < 4) {
            return context.error(("Expected at least 4 arguments, but found only " + (args.length - 1) + "."));
        }

        if ((args.length - 1) % 2 !== 0) {
            return context.error("Expected an even number of arguments.");
        }

        input = context.parse(input, 2, {kind: 'number'});
        if (!input) {
            return null;
        }

        var stops = [];
        var outputType = null;
        if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') { // 
            outputType = {kind: 'color'};
        } else if (context.expectedType && context.expectedType.kind !== 'value') {
            outputType = context.expectedType;
        }

        for (var i = 0; i < rest.length; i += 2) {
            var label = rest[i];
            var value = rest[i + 1];
            var labelKey = i + 3;
            var valueKey = i + 4;

            if (typeof label !== 'number') {
                return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
            }

            if (stops.length && stops[stops.length - 1][0] >= label) {
                return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
            }

            var parsed = context.parse(value, valueKey, outputType);
            if (!parsed) {
                return null;
            }
            outputType = outputType || parsed.type;
            stops.push([label, parsed]);
        }

        if (outputType.kind !== 'number' && outputType.kind !== 'color' &&
            !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
            return context.error("Type " + styleUtils.toString(outputType) + " is not interpolatable.");
        }

        return new Interpolate(outputType, operator, interpolation, input, stops);
    };

    Interpolate.prototype.evaluate = function (ctx) {
        var labels = this.labels;
        var outputs = this.outputs;

        if (labels.length === 1) {
            return outputs[0].evaluate(ctx);
        }

        var value = this.input.evaluate(ctx);
        if (value <= labels[0]) {
            return outputs[0].evaluate(ctx);
        }

        var stopCount = labels.length;
        if (value >= labels[stopCount - 1]) {
            return outputs[stopCount - 1].evaluate(ctx);
        }

        var index = styleUtils.findStopLessThanOrEqualTo(labels, value);
        var lower = labels[index];
        var upper = labels[index + 1];
        var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);

        var outputLower = outputs[index].evaluate(ctx);
        var outputUpper = outputs[index + 1].evaluate(ctx);

        if (this.operator === 'interpolate') {
            return (styleUtils.interpolate[this.type.kind.toLowerCase()])(outputLower, outputUpper, t);
        } else if (this.operator === 'interpolate-hcl') {
            var hcl = colorSpaces.hcl;
            return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
        } else {
            var lab = colorSpaces.lab;
            return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
        }
    };

    Interpolate.prototype.eachChild = function (fn) {
        fn(this.input);
        for (var i = 0, list = this.outputs; i < list.length; i += 1) {
            var expression = list[i];
            fn(expression);
        }
    };

    Interpolate.prototype.possibleOutputs = function () {
        var ref;
        return (ref = []).concat.apply(ref, this.outputs.map(function (output) {
            return output.possibleOutputs();
        }));
    };

    Interpolate.prototype.serialize = function () {
        var interpolation;
        if (this.interpolation.name === 'linear') {
            interpolation = ["linear"];
        } else if (this.interpolation.name === 'exponential') {
            if (this.interpolation.base === 1) {
                interpolation = ["linear"];
            } else {
                interpolation = ["exponential", this.interpolation.base];
            }
        } else {
            interpolation = ["cubic-bezier"].concat(this.interpolation.controlPoints);
        }

        var serialized = [this.operator, interpolation, this.input.serialize()];
        for (var i = 0; i < this.labels.length; i++) {
            serialized.push(
                this.labels[i],
                this.outputs[i].serialize()
            );
        }
        return serialized;
    };
    return Interpolate;
});
},
'com/huayun/webgis/gl/ImageAtlas':function(){
define([
    "./potpack",
    "./ImagePosition",
    "../utils/image",
    "../utils/Constant"
], function (potpack, ImagePosition, images, Constant) {

    var ImageAtlas = function ImageAtlas(icons, patterns) {
        var iconPositions = {}, patternPositions = {};
        this.haveRenderCallbacks = [];
        var bins = [];
        this.addImages(icons, iconPositions, bins);
        this.addImages(patterns, patternPositions, bins);

        var ref = potpack(bins);
        var w = ref.w;
        var h = ref.h;
        var image = new images.RGBAImage({width: w || 1, height: h || 1});

        for (var id in icons) {
            var src = icons[id];
            var bin = iconPositions[id].paddedRect;
            images.RGBAImage.copy(src.data, image, {x: 0, y: 0}, {
                x: bin.x + Constant.layout.padding,
                y: bin.y + Constant.layout.padding
            }, src.data);
        }

        for (var id$1 in patterns) {
            var src$1 = patterns[id$1];
            var bin$1 = patternPositions[id$1].paddedRect;
            var x = bin$1.x + Constant.layout.padding,
                y = bin$1.y + Constant.layout.padding,
                w$1 = src$1.data.width,
                h$1 = src$1.data.height;

            images.RGBAImage.copy(src$1.data, image, {x: 0, y: 0}, {x: x, y: y}, src$1.data);
            images.RGBAImage.copy(src$1.data, image, {x: 0, y: h$1 - 1}, {x: x, y: y - 1}, {width: w$1, height: 1}); // T
            images.RGBAImage.copy(src$1.data, image, {x: 0, y: 0}, {x: x, y: y + h$1}, {width: w$1, height: 1}); // B
            images.RGBAImage.copy(src$1.data, image, {x: w$1 - 1, y: 0}, {x: x - 1, y: y}, {width: 1, height: h$1}); // L
            images.RGBAImage.copy(src$1.data, image, {x: 0, y: 0}, {x: x + w$1, y: y}, {width: 1, height: h$1}); // R
        }

        this.image = image;
        this.iconPositions = iconPositions;
        this.patternPositions = patternPositions;
    };

    ImageAtlas.prototype.addImages = function addImages(images, positions, bins) {
        for (var id in images) {
            var src = images[id];
            var bin = {
                x: 0,
                y: 0,
                w: src.data.width + 2 * Constant.layout.padding,
                h: src.data.height + 2 * Constant.layout.padding
            };
            bins.push(bin);
            positions[id] = new ImagePosition(bin, src);

            if (src.hasRenderCallback) {
                this.haveRenderCallbacks.push(id);
            }
        }
    };

    ImageAtlas.prototype.patchUpdatedImages = function patchUpdatedImages(imageManager, texture) {
        imageManager.dispatchRenderCallbacks(this.haveRenderCallbacks);
        for (var name in imageManager.updatedImages) {
            this.patchUpdatedImage(this.iconPositions[name], imageManager.getImage(name), texture);
            this.patchUpdatedImage(this.patternPositions[name], imageManager.getImage(name), texture);
        }
    };

    ImageAtlas.prototype.patchUpdatedImage = function patchUpdatedImage(position, image, texture) {
        if (!position || !image) {
            return;
        }

        if (position.version === image.version) {
            return;
        }

        position.version = image.version;
        var ref = position.tl;
        var x = ref[0];
        var y = ref[1];
        texture.update(image.data, undefined, {x: x, y: y});
    };

    // dataTransfer.register('ImageAtlas', ImageAtlas);

    return ImageAtlas;
});
},
'com/huayun/webgis/gl/SegmentVector':function(){
define([], function () {
    var SegmentVector = function SegmentVector(segments) {
        if (segments === void 0) segments = [];
        this.segments = segments;
    };
    SegmentVector.prototype.prepareSegment = function prepareSegment(numVertices, layoutVertexArray, indexArray, sortKey) {
        var segment = this.segments[this.segments.length - 1];
        if (numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) {
           console.log("Max vertices per segment is " + (SegmentVector.MAX_VERTEX_ARRAY_LENGTH) + ": bucket requested " + numVertices);
        }
        if (!segment || segment.vertexLength + numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH || segment.sortKey !== sortKey) {
            segment = {
                vertexOffset: layoutVertexArray.length,
                primitiveOffset: indexArray.length,
                vertexLength: 0,
                primitiveLength: 0
            };
            if (sortKey !== undefined) {
                segment.sortKey = sortKey;
            }
            this.segments.push(segment);
        }
        return segment;
    };

    SegmentVector.prototype.get = function get() {
        return this.segments;
    };

    SegmentVector.prototype.destroy = function destroy() {
        for (var i = 0, list = this.segments; i < list.length; i += 1) {
            var segment = list[i];

            for (var k in segment.vaos) {
                segment.vaos[k].destroy();
            }
        }
    };

    SegmentVector.simpleSegment = function simpleSegment(vertexOffset, primitiveOffset, vertexLength, primitiveLength) {
        return new SegmentVector([{
            vertexOffset: vertexOffset,
            primitiveOffset: primitiveOffset,
            vertexLength: vertexLength,
            primitiveLength: primitiveLength,
            vaos: {},
            sortKey: 0
        }]);
    };

    SegmentVector.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;
    return SegmentVector;
});
},
'com/huayun/webgis/gl/VertexArrayObject':function(){
define([], function () {
    function VertexArrayObject() {
        this.boundProgram = null;
        this.boundLayoutVertexBuffer = null;
        this.boundPaintVertexBuffers = [];
        this.boundIndexBuffer = null;
        this.boundVertexOffset = null;
        this.boundDynamicVertexBuffer = null;
        this.vao = null;
    }

    VertexArrayObject.prototype.bind = function bind(context, program, layoutVertexBuffer, paintVertexBuffers, indexBuffer,
                                                     vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2) {

        this.context = context;
        var paintBuffersDiffer = this.boundPaintVertexBuffers.length !== paintVertexBuffers.length;
        for (var i = 0; !paintBuffersDiffer && i < paintVertexBuffers.length; i++) {
            if (this.boundPaintVertexBuffers[i] !== paintVertexBuffers[i]) {
                paintBuffersDiffer = true;
            }
        }
        var isFreshBindRequired = (
            !this.vao ||
            this.boundProgram !== program ||
            this.boundLayoutVertexBuffer !== layoutVertexBuffer ||
            paintBuffersDiffer ||
            this.boundIndexBuffer !== indexBuffer ||
            this.boundVertexOffset !== vertexOffset ||
            this.boundDynamicVertexBuffer !== dynamicVertexBuffer ||
            this.boundDynamicVertexBuffer2 !== dynamicVertexBuffer2
        );

        if (!context.extVertexArrayObject || isFreshBindRequired) {
            this.freshBind(program, layoutVertexBuffer, paintVertexBuffers, indexBuffer, vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2);
        } else {
            context.bindVertexArrayOES.set(this.vao);
            if (dynamicVertexBuffer) {
                dynamicVertexBuffer.bind();
            }
            if (indexBuffer && indexBuffer.dynamicDraw) {
                indexBuffer.bind();
            }
            if (dynamicVertexBuffer2) {
                dynamicVertexBuffer2.bind();
            }
        }
    };

    VertexArrayObject.prototype.freshBind = function freshBind(program, layoutVertexBuffer, paintVertexBuffers, indexBuffer,
                                                               vertexOffset, dynamicVertexBuffer, dynamicVertexBuffer2) {
        var numPrevAttributes;
        var numNextAttributes = program.numAttributes;
        var context = this.context;
        var gl = context.gl;

        if (context.extVertexArrayObject) {
            if (this.vao) {
                this.destroy();
            }
            this.vao = context.extVertexArrayObject.createVertexArrayOES();
            context.bindVertexArrayOES.set(this.vao);
            numPrevAttributes = 0;
            this.boundProgram = program;
            this.boundLayoutVertexBuffer = layoutVertexBuffer;
            this.boundPaintVertexBuffers = paintVertexBuffers;
            this.boundIndexBuffer = indexBuffer;
            this.boundVertexOffset = vertexOffset;
            this.boundDynamicVertexBuffer = dynamicVertexBuffer;
            this.boundDynamicVertexBuffer2 = dynamicVertexBuffer2;
        } else {
            numPrevAttributes = context.currentNumAttributes || 0;
            for (var i = numNextAttributes; i < numPrevAttributes; i++) {
                gl.disableVertexAttribArray(i);
            }
        }
        layoutVertexBuffer.enableAttributes(gl, program);
        for (var i$1 = 0, list = paintVertexBuffers; i$1 < list.length; i$1 += 1) {
            var vertexBuffer = list[i$1];
            vertexBuffer.enableAttributes(gl, program);
        }

        if (dynamicVertexBuffer) {
            dynamicVertexBuffer.enableAttributes(gl, program);
        }
        if (dynamicVertexBuffer2) {
            dynamicVertexBuffer2.enableAttributes(gl, program);
        }

        layoutVertexBuffer.bind();
        layoutVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
        for (var i$2 = 0, list$1 = paintVertexBuffers; i$2 < list$1.length; i$2 += 1) {
            var vertexBuffer$1 = list$1[i$2];
            vertexBuffer$1.bind();
            vertexBuffer$1.setVertexAttribPointers(gl, program, vertexOffset);
        }

        if (dynamicVertexBuffer) {
            dynamicVertexBuffer.bind();
            dynamicVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
        }
        if (indexBuffer) {
            indexBuffer.bind();
        }

        if (dynamicVertexBuffer2) {
            dynamicVertexBuffer2.bind();
            dynamicVertexBuffer2.setVertexAttribPointers(gl, program, vertexOffset);
        }
        context.currentNumAttributes = numNextAttributes;
    };

    VertexArrayObject.prototype.destroy = function destroy() {
        if (this.vao) {
            this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao);
            this.vao = null;
        }
    };

    return VertexArrayObject;
});
},
'com/huayun/webgis/layers/support/style/styleUtils':function(){
define([
    "exports",
    "../expression/Formatted",
    "../expression/Var",
    "../../../utils/utils",
    "../../../utils/Color",
    "../../../geometry/Point"
], function (exports, Formatted, Var, utils, Color, Point) {

    var valueMemberTypes = [
        {kind: 'null'},
        {kind: 'number'},
        {kind: 'string'},
        {kind: 'boolean'},
        {kind: 'color'},
        {kind: 'formatted'},
        {kind: 'object'},
        {
            kind: 'array',
            itemType: {kind: 'value'},
            N: undefined
        }
    ];

    /**
     * 
     * @private
     * @ignore
     * @param spec
     * @return {boolean|*}
     */
    function supportsInterpolation(spec) {
        return !!spec.expression && spec.expression.interpolated;
    }

    exports.supportsInterpolation = supportsInterpolation;

    /**
     * stopsinput
     * @private
     * @ignore
     * @param stops
     * @param input
     * @return {number}
     */
    function findStopLessThanOrEqualTo(stops, input) {
        var lastIndex = stops.length - 1;
        var lowerIndex = 0;
        var upperIndex = lastIndex;
        var currentIndex = 0;
        var currentValue, nextValue;

        while (lowerIndex <= upperIndex) {
            currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
            currentValue = stops[currentIndex];
            nextValue = stops[currentIndex + 1];

            if (currentValue <= input) {
                if (currentIndex === lastIndex || input < nextValue) { // Search complete
                    return currentIndex;
                }
                lowerIndex = currentIndex + 1;
            } else if (currentValue > input) {
                upperIndex = currentIndex - 1;
            } else {
                throw new Error('Input is not a number.');
            }
        }
        return 0;
    }

    exports.findStopLessThanOrEqualTo = findStopLessThanOrEqualTo;

    /**
     * 
     * @private
     * @ignore
     * @param input
     * @param base
     * @param lowerValue
     * @param upperValue
     * @return {number}
     */
    function interpolationFactor(input, base, lowerValue, upperValue) {
        var difference = upperValue - lowerValue;
        var progress = input - lowerValue;
        if (difference === 0) {
            return 0;
        } else if (base === 1) {
            return progress / difference;
        } else {
            return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
        }
    }

    exports.interpolationFactor = interpolationFactor;

    /**
     * RGB
     * @private
     * @ignore
     * @param from
     * @param to
     * @param t
     * @return {Color|exports}
     */
    function color(from, to, t) {
        return new Color(
            utils.number(from.r, to.r, t),
            utils.number(from.g, to.g, t),
            utils.number(from.b, to.b, t),
            utils.number(from.a, to.a, t)
        );
    }

    function array$1(from, to, t) {
        return from.map(function (d, i) {
            return utils.number(d, to[i], t);
        });
    }

    /**
     * 
     * @ignore
     * @private
     * @type {Readonly<{number: (function(*, *, *): number), color: (function(*, *, *=): Color|exports), array: (function(*, *, *=): *)}>}
     */
    exports.interpolate = Object.freeze({
        number: utils.number,
        color: color,
        array: array$1
    });

    function toString(type) {
        if (type.kind === 'array') {
            var itemType = toString(type.itemType);
            return typeof type.N === 'number' ?
                ("array<" + itemType + ", " + (type.N) + ">") :
                type.itemType.kind === 'value' ? 'array' : ("array<" + itemType + ">");
        } else {
            return type.kind;
        }
    }

    exports.toString = toString;

    /**
     * texpected, null, 
     * @private
     * @ignore
     * @param expected
     * @param t
     * @return {string|null}
     */
    function checkSubtype(expected, t) {
        if (t.kind === 'error') { // 
            return null;
        } else if (expected.kind === 'array') {
            if (t.kind === 'array'
                && ((t.N === 0 && t.itemType.kind === 'value') || !checkSubtype(expected.itemType, t.itemType))
                && (typeof expected.N !== 'number' || expected.N === t.N)) {
                return null;
            }
        } else if (expected.kind === t.kind) {
            return null;
        } else if (expected.kind === 'value') {
            for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
                var memberType = list[i];
                if (!checkSubtype(memberType, t)) {
                    return null;
                }
            }
        }
        return ("Expected " + (toString(expected)) + " but found " + (toString(t)) + " instead.");
    }

    exports.checkSubtype = checkSubtype;

    /**
     * 
     * @private
     * @ignore
     * @param spec
     * @return {boolean}
     */
    function supportsPropertyExpression(spec) {
        return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
    }

    exports.supportsPropertyExpression = supportsPropertyExpression;

    /**
     * 
     * @param spec
     * @return {boolean|boolean}
     */
    function supportsZoomExpression(spec) {
        return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
    }

    exports.supportsZoomExpression = supportsZoomExpression;

    /**
     * geometry
     * @private
     * @ignore
     * @param queryGeometry
     * @param translate
     * @param translateAnchor
     * @param bearing
     * @param pixelsToTileUnits
     * @return {[]|*}
     */
    function translate(queryGeometry, translate, translateAnchor, bearing, pixelsToTileUnits) {
        if (!translate[0] && !translate[1]) {
            return queryGeometry;
        }
        var pt = Point.convert(translate)._mult(pixelsToTileUnits);

        if (translateAnchor === "viewport") {
            pt._rotate(-bearing);
        }

        var translated = [];
        for (var i = 0; i < queryGeometry.length; i++) {
            var point = queryGeometry[i];
            translated.push(point.sub(pt));
        }
        return translated;
    }

    exports.translate = translate;

    /**
     * paint, 
     * @private
     * @ignore
     * @param property
     * @param layer
     * @param bucket
     * @return {number|*}
     */
    function getMaximumPaintValue(property, layer, bucket) {
        var value = layer.paint.get(property).value;
        if (value.kind === 'constant') {
            return value.value;
        } else {
            var binders = bucket.programConfigurations.get(layer.id).binders;
            return binders[property].maxValue;
        }
    }

    exports.getMaximumPaintValue = getMaximumPaintValue;

    /**
     * 
     * @private
     * @ignore
     * @param value
     * @return {{itemType: ({kind: string}|{kind: string}|{kind: string}|{kind: string}|{kind: string}|{kind: string}), kind: string, N: *}|{kind: string}}
     */
    function typeOf(value) {
        if (value === null) {
            return {kind: 'null'};
        } else if (typeof value === 'string') {
            return {kind: 'string'};
        } else if (typeof value === 'boolean') {
            return {kind: 'boolean'};
        } else if (typeof value === 'number') {
            return {kind: 'number'};
        } else if (Array.isArray(value)) {
            var length = value.length;
            var itemType;
            for (var i = 0, list = value; i < list.length; i += 1) {
                var item = list[i];
                var t = typeOf(item);
                if (!itemType) {
                    itemType = t;
                } else if (itemType === t) {
                    continue;
                } else {
                    itemType = {kind: 'value'};
                    break;
                }
            }
            return {
                kind: 'array',
                itemType: itemType || {kind: 'value'},
                N: length,
            };
        } else {
            return {kind: 'object'};
        }
    }

    exports.typeOf = typeOf;

    /**
     * value
     * @private
     * @ignore
     * @param mixed
     * @return {boolean}
     */
    function isValue(mixed) {
        if (mixed === null) {
            return true;
        } else if (typeof mixed === 'string') {
            return true;
        } else if (typeof mixed === 'boolean') {
            return true;
        } else if (typeof mixed === 'number') {
            return true;
        } else if (Array.isArray(mixed)) {
            for (var i = 0, list = mixed; i < list.length; i += 1) {
                var item = list[i];
                if (!isValue(item)) {
                    return false;
                }
            }
            return true;
        } else if (typeof mixed === 'object') {
            for (var key in mixed) {
                if (!isValue(mixed[key])) {
                    return false;
                }
            }
            return true;
        } else {
            return false;
        }
    }

    exports.isValue = isValue;

    exports.toString$1 = function (value) {
        var type = typeof value;
        if (value === null) {
            return '';
        } else if (type === 'string' || type === 'number' || type === 'boolean') {
            return String(value);
        } else if (value instanceof Color || value instanceof Formatted) {
            return value.toString();
        } else {
            return JSON.stringify(value);
        }
    };



    function array(itemType, N) {
        return {
            kind: 'array',
            itemType: itemType,
            N: N
        };
    }

    exports.array = array;


    function success(value) {
        return {result: 'success', value: value};
    }

    function error(value) {
        return {result: 'error', value: value};
    }

    exports.success = success;
    exports.error = error;

    exports.emitValidationErrors = function (emitter, errors) {
        var hasErrors = false;
        if (errors && errors.length) {
            for (var i = 0, list = errors; i < list.length; i += 1) {
                var error = list[i];
                hasErrors = true;
            }
        }
        return hasErrors;
    };

    exports.translateDistance = function (translate) {
        return Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]);
    };


});
},
'com/huayun/webgis/views/3d/layers/TileLayerView3D':function(){
define([
    "./LayerView3D",
    "../../../utils/utils",
    "../../../utils/extendClazz",
    "../../../gl/draw/drawRaster",
    "../../../gl/mode",
    "../../../data/ArrayType",
    "../../../utils/Constant",
    "../../../gl/members",
    "../../../gl/SegmentVector"
], function (LayerView3D, utils, extendClazz, drawRaster, mode, ArrayType, Constant, members, SegmentVector) {

    /**
     * @ignore
     * @param params
     * @constructor
     */
    function TileLayerView3D(params) {
        LayerView3D.call(this, params);
        this.visible = params.visible;
        this.id = params.id;
        this.layer = params.layer;
        this.view = params.view;
        this._tileTextures = {};

        this._sourcesDirty = true;
        this._fadeDirty = true;
        var quadTriangleIndices = new ArrayType.StructArrayLayout3ui6();
        quadTriangleIndices.emplaceBack(0, 1, 2);
        quadTriangleIndices.emplaceBack(2, 1, 3);
        this.quadTriangleIndexBuffer = this.view.context.createIndexBuffer(quadTriangleIndices);

        var EXTENT = Constant.layout.EXTENT;
        var rasterBoundsArray = new ArrayType.StructArrayLayout4i8();
        rasterBoundsArray.emplaceBack(0, 0, 0, 0);
        rasterBoundsArray.emplaceBack(EXTENT, 0, EXTENT, 0);
        rasterBoundsArray.emplaceBack(0, EXTENT, 0, EXTENT);
        rasterBoundsArray.emplaceBack(EXTENT, EXTENT, EXTENT, EXTENT);
        this.rasterBoundsBuffer = this.view.context.createVertexBuffer(rasterBoundsArray, members.rasterBoundsAttributes.members);
        this.rasterBoundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);
    }

    extendClazz(TileLayerView3D, LayerView3D);

    TileLayerView3D.prototype.refresh = function () {
        this._readyData();
        this.view.threeRender();
    };

    /**
     * 
     * @private
     */
    TileLayerView3D.prototype._readyData = function () {
        if (this.visible) {
            var tileInfo = this.layer.tileInfo,
                level = this.layer.maxLevel ? Math.min(this.view.viewpoint.targetZoom || this.view.viewpoint.level, this.layer.maxLevel):
                    this.view.viewpoint.targetZoom || this.view.viewpoint.level,
                center = this.view.viewpoint.center,
                resolution = tileInfo.getResolution(level);
            var zoomedBounds = this.view._bound.map(function (item) {
                return {
                    x: tileInfo.getColForX(item.x, resolution),
                    y: tileInfo.getRowForY(item.y, resolution)
                }
            });
            var range = tileInfo.getColRange(resolution);
            var cx = tileInfo.getColForX(center[0], resolution),
                cy = tileInfo.getRowForY(center[1], resolution);
            this.layer.sourceCache.updateTile(level, zoomedBounds, range, cx, cy);

            this._sourcesDirty = true;
            this.zoomedBounds = zoomedBounds;
            this.range = range;
            this.cx = cx;
            this.cy = cy;
        }
    }

    TileLayerView3D.prototype._render = function () {
        if (this.visible && this.zoomedBounds) {
            this.view.currentLayer++;
            var level = this.layer.maxLevel ? Math.min(this.view.viewpoint.level, this.layer.maxLevel): this.view.viewpoint.level;
            if (this._sourcesDirty) {
                this.layer.sourceCache.update(level, this.zoomedBounds, this.range, this.cx, this.cy);
                this._sourcesDirty = false;
                this._fadeDirty = false;
            }
            this.renderPass = 'translucent';
            var coords$2 = this.layer.sourceCache.getVisibleCoordinates(false, this.transform).slice().reverse();
            this.renderLayer(this, this.layer.sourceCache, null, coords$2);
        }
    }

    TileLayerView3D.prototype.renderLayer = function (painter, sourceCache, layer, coords, level) {
        if (!coords.length) {
            return;
        }
        drawRaster(painter, sourceCache, layer, coords);
    }

    TileLayerView3D.prototype.setVisible = function (visible) {
        this.visible = visible;
        if (visible) {
            this.refresh();
        } else {
            this.view.threeRender();
        }
    }

    TileLayerView3D.prototype.zoom = function () {
        if (this.visible) {
            this.transform = this.view.viewpoint;
            this.renderPass = 'translucent';
            var coords$2 = this.layer.sourceCache.updateTileMatrix(false, this.transform).slice().reverse();
            this.renderLayer(this, this.layer.sourceCache, null, coords$2);
        }
    };

    TileLayerView3D.prototype.depthModeForSublayer = function (n, mask, func) {
        var depth = 1 - ((1 + this.view.currentLayer) * this.view.numSublayers + n) * this.view.depthEpsilon;
        return new mode.DepthMode(func || this.view.context.gl.LEQUAL, mask, [depth, depth]);
    }

    TileLayerView3D.prototype.getTileTexture = function getTileTexture(size) {
        var textures = this._tileTextures[size];
        return textures && textures.length > 0 ? textures.pop() : null;
    };

    TileLayerView3D.prototype.saveTileTexture = function (texture) {
        var textures = this._tileTextures[texture.size[0]];
        if (!textures) {
            this._tileTextures[texture.size[0]] = [texture];
        } else {
            textures.push(texture);
        }
    };

    return TileLayerView3D;
});
},
'com/huayun/webgis/layers/support/TileSourceCache':function(){
/**
 * 
 * @see com.huayun.webgis.layers.support.TileSourceCache
 */
define([
    "./RasterTileSource",
    "./tileCover",
    "./Tile",

    "./funcUtils",
    "./TileCache",

    "./SourceFeatureState",

    "com/huayun/webgis/geometry/Point2D",
    "../../utils/utils"
], function (RasterTileSource, tileCover, Tile,
             funcUtils, TileCache, SourceFeatureState, Point2D, utils) {

    var sourceTypes = {
        raster: RasterTileSource
    };

    function isRasterType(type) {
        return type === 'raster' || type === 'image' || type === 'video';
    }

    /**
     * 
     * @alias com.huayun.webgis.layers.support.TileSourceCache
     * @ignore
     * @param id
     * @param options
     * @param width
     * @param height
     * @param url
     * @param layer
     * @param dispatcher
     * @constructor
     */
    function TileSourceCache(id, options, width, height, url, layer, dispatcher) {
        this.id = id;
        this._source = new sourceTypes[options.type](id, options, url, layer, dispatcher);
        this._tiles = {};
        this._cache = new TileCache(0, this._unloadTile.bind(this));
        this._timers = {};
        this._cacheTimers = {};
        this._maxTileCacheSize = null;
        this._coveredTiles = {};
        this.layer = layer;
        this.view = layer.layerView.view;
        this.updateCacheSize(width, height);
    }

    /**
     * 
     * @param width
     * @param height
     */
    TileSourceCache.prototype.updateTileSize = function (size) {
        this._source.setSize(size);
    };
    TileSourceCache.prototype.onRemove = function onRemove(map) {
        if (this._source && this._source.onRemove) {
            this._source.onRemove(map);
        }
    };

    TileSourceCache.prototype.loaded = function loaded() {
        if (this._sourceErrored) {
            return true;
        }
        if (!this._sourceLoaded) {
            return false;
        }
        for (var t in this._tiles) {
            var tile = this._tiles[t];
            if (tile.state !== 'loaded' && tile.state !== 'errored') {
                return false;
            }
        }
        return true;
    };

    TileSourceCache.prototype.getSource = function getSource() {
        return this._source;
    };

    TileSourceCache.prototype.pause = function pause() {
        this._paused = true;
    };

    TileSourceCache.prototype.resume = function resume() {
        if (!this._paused) {
            return;
        }
        var shouldReload = this._shouldReloadOnResume;
        this._paused = false;
        this._shouldReloadOnResume = false;
        if (shouldReload) {
            this.reload();
        }
        if (this.transform) {
            this.update(this.transform);
        }
    };

    TileSourceCache.prototype._loadTile = function _loadTile(tile, callback) {
        return this._source.loadTile(tile, callback);
    };

    TileSourceCache.prototype._unloadTile = function _unloadTile(tile) {
        if (this._source.unloadTile) {
            return this._source.unloadTile(tile, function () {});
        }
    };

    TileSourceCache.prototype._abortTile = function _abortTile(tile) {
        if (this._source.abortTile) {
            return this._source.abortTile(tile, function () {});
        }
    };

    TileSourceCache.prototype.serialize = function serialize() {
        return this._source.serialize();
    };

    TileSourceCache.prototype.getIds = function getIds() {
        var tileIDs = [];
        for (var key in this._tiles) {
            tileIDs.push(this._tiles[key].tileID);
        }
        return tileIDs;
    };

    TileSourceCache.prototype.getRenderableIds = function getRenderableIds() {
        var ids = [];
        for (var id in this._tiles) {
            if (this._isIdRenderable(id)) {
                ids.push(id);
            }
        }
        return ids.sort(utils.compareKeyZoom);
    };

    TileSourceCache.prototype.hasRenderableParent = function hasRenderableParent(tileID) {
        var parentTile = this.findLoadedParent(tileID, 0);
        if (parentTile) {
            return this._isIdRenderable(parentTile.tileID.key);
        }
        return false;
    };

    TileSourceCache.prototype._isIdRenderable = function _isIdRenderable(id) {
        return this._tiles[id] && this._tiles[id].hasData() &&
            !this._coveredTiles[id] && (!this._tiles[id].holdingForFade());
    };

    TileSourceCache.prototype.reload = function reload() {
        if (this._paused) {
            this._shouldReloadOnResume = true;
            return;
        }

        this._cache.reset();

        for (var i in this._tiles) {
            if (this._tiles[i].state !== "errored") {
                this._reloadTile(i, 'reloading');
            }
        }
    };

    TileSourceCache.prototype._reloadTile = function _reloadTile(id, state) {
        var tile = this._tiles[id];
        if (!tile) {
            return;
        }
        if (tile.state !== 'loading') {
            tile.state = state;
        }

        this._loadTile(tile, this._tileLoaded.bind(this, tile, id, state));
    };

    TileSourceCache.prototype.updateTileUrl = function(url) {
        this._source.updateTileUrl(url);
    };

    TileSourceCache.prototype._tileLoaded = function _tileLoaded(tile, id, previousState, err) {
        if (err) {
            tile.state = 'errored';
            if (err.status === 404) {
                this.update(this.transform);
            }
            return;
        }
        tile.timeAdded = utils.now();
        this._setTileReloadTimer(id, tile);
        this.layer.layerView._sourcesDirty = true;
        this.view.threeRender();
    };

    TileSourceCache.prototype.getTile = function getTile(tileID) {
        return this.getTileByID(tileID.key);
    };

    TileSourceCache.prototype.getTileByID = function getTileByID(id) {
        return this._tiles[id];
    };

    TileSourceCache.prototype.getZoom = function getZoom(transform) {
        return transform.level + transform.scaleZoom(transform.tileSize / this._source.tileSize);
    };

    TileSourceCache.prototype._retainLoadedChildren = function _retainLoadedChildren(idealTiles, zoom, maxCoveringZoom, retain) {
        for (var id in this._tiles) {
            var tile = this._tiles[id];
            if (retain[id] ||
                !tile.hasData() ||
                tile.tileID.overscaledZ <= zoom ||
                tile.tileID.overscaledZ > maxCoveringZoom
            ) {
                continue;
            }

            var topmostLoadedID = tile.tileID;
            while (tile && tile.tileID.overscaledZ > zoom + 1) {
                var parentID = tile.tileID.scaledTo(tile.tileID.overscaledZ - 1);

                tile = this._tiles[parentID.key];

                if (tile && tile.hasData()) {
                    topmostLoadedID = parentID;
                }
            }

            var tileID = topmostLoadedID;
            while (tileID.overscaledZ > zoom) {
                tileID = tileID.scaledTo(tileID.overscaledZ - 1);

                if (idealTiles[tileID.key]) {
                    retain[topmostLoadedID.key] = topmostLoadedID;
                    break;
                }
            }
        }
    };

    TileSourceCache.prototype.findLoadedParent = function findLoadedParent(tileID, minCoveringZoom) {
        for (var z = tileID.overscaledZ - 1; z >= minCoveringZoom; z--) {
            var parent = tileID.scaledTo(z);
            if (!parent) {
                return;
            }
            var id = String(parent.key);
            var tile = this._tiles[id];
            if (tile && tile.hasData()) {
                return tile;
            }
            if (this._cache.has(parent)) {
                return this._cache.get(parent);
            }
        }
    };

    TileSourceCache.prototype.updateCacheSize = function updateCacheSize(width, height) {
        var widthInTiles = Math.ceil(width / this._source.tileSize) + 1;
        var heightInTiles = Math.ceil(height / this._source.tileSize) + 1;
        var approxTilesInView = widthInTiles * heightInTiles;
        var commonZoomRange = 3;

        var viewDependentMaxSize = Math.floor(approxTilesInView * commonZoomRange);
        var maxSize = typeof this._maxTileCacheSize === 'number' ? Math.min(this._maxTileCacheSize, viewDependentMaxSize) : viewDependentMaxSize;
        this._cache.setMaxSize(maxSize);
    };

    TileSourceCache.prototype.update = function update(level, zoomedBounds, range, cx, cy) {
        this._coveredTiles = {};
        var idealTileIDs = tileCover(level, zoomedBounds, range);
        idealTileIDs = idealTileIDs.sort(function (a, b) {
            a = a.canonical;
            b = b.canonical;
            return Math.sqrt((cx - a.x) * (cx - a.x) + (cy - a.y) * (cy - a.y)) - Math.sqrt((cx - b.x) * (cx - b.x) + (cy - b.y) * (cy - b.y));
        });

        // debugger;
        var retain = this._updateRetainedTiles(idealTileIDs, level);

        var zoom = level;
        var minCoveringZoom = 0;
        var maxCoveringZoom = 15;

        /*if (isRasterType(this._source.type)) {
            var parentsForFading = {};
            var fadingTiles = {};
            var ids = Object.keys(retain);
            for (var i = 0, list = ids; i < list.length; i += 1) {
                var id = list[i];

                var tileID = retain[id];

                var tile = this._tiles[id];
                if (!tile || tile.fadeEndTime && tile.fadeEndTime <= utils.now()) {
                    continue;
                }

                // if the tile is loaded but still fading in, find parents to cross-fade with it
                var parentTile = this.findLoadedParent(tileID, minCoveringZoom);
                if (parentTile) {
                    this._addTile(parentTile.tileID);
                    parentsForFading[parentTile.tileID.key] = parentTile.tileID;
                }

                fadingTiles[id] = tileID;
            }

            // for tiles that are still fading in, also find children to cross-fade with
            this._retainLoadedChildren(fadingTiles, zoom, maxCoveringZoom, retain);

            for (var id$1 in parentsForFading) {
                if (!retain[id$1]) {
                    // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.
                    this._coveredTiles[id$1] = true;
                    retain[id$1] = parentsForFading[id$1];
                }
            }
        }*/

        for (var retainedId in retain) {
            // Make sure retained tiles always clear any existing fade holds
            // so that if they're removed again their fade timer starts fresh.
            this._tiles[retainedId].clearFadeHold();
        }

        // Remove the tiles we don't need anymore.
        var remove = utils.keysDifference(this._tiles, retain);
        for (var i$1 = 0, list$1 = remove; i$1 < list$1.length; i$1 += 1) {
            var tileID$1 = list$1[i$1];

            var tile$1 = this._tiles[tileID$1];
            /*if (tile$1.hasSymbolBuckets && !tile$1.holdingForFade()) {
                tile$1.setHoldDuration(300);
            } else if (!tile$1.hasSymbolBuckets || tile$1.symbolFadeFinished()) {
                this._removeTile(tileID$1);
            }*/
            this._removeTile(tileID$1);
        }
    };


    TileSourceCache.prototype.updateTile = function updateTile(level, zoomedBounds, range, cx, cy) {
        this._coveredTiles = {};

        var idealTileIDs = tileCover(level, zoomedBounds, range);

        idealTileIDs = idealTileIDs.sort(function (a, b) {
            a = a.canonical;
            b = b.canonical;
            return Math.sqrt((cx - a.x) * (cx - a.x) + (cy - a.y) * (cy - a.y)) - Math.sqrt((cx - b.x) * (cx - b.x) + (cy - b.y) * (cy - b.y));
        });
        this._updateRetainedTiles(idealTileIDs, level);
        return idealTileIDs;
    };

    TileSourceCache.prototype.releaseSymbolFadeTiles = function releaseSymbolFadeTiles() {
        for (var id in this._tiles) {
            if (this._tiles[id].holdingForFade()) {
                this._removeTile(id);
            }
        }
    };

    TileSourceCache.prototype._updateRetainedTiles = function _updateRetainedTiles(idealTileIDs, zoom) {
        var retain = {};
        var checked = {};
        var minCoveringZoom = Math.max(zoom - TileSourceCache.maxOverzooming, this._source.minzoom);
        var maxCoveringZoom = Math.max(zoom + TileSourceCache.maxUnderzooming, this._source.minzoom);

        var missingTiles = {};
        // countTile
        for (var i = 0, list = idealTileIDs; i < list.length; i += 1) {
            // for (var i = 0, list = idealTileIDs; i < 1; i += 1) {
            var tileID = list[i];
            var tile = this._addTile(tileID);
            retain[tileID.key] = tileID;
            if (tile.hasData()) {
                continue;
            }
            if (zoom < this._source.maxzoom) {
                missingTiles[tileID.key] = tileID;
            }
        }

        this._retainLoadedChildren(missingTiles, zoom, maxCoveringZoom, retain);

        for (var i$1 = 0, list$1 = idealTileIDs; i$1 < list$1.length; i$1 += 1) {
            // for (var i$1 = 0, list$1 = idealTileIDs; i$1 < 1; i$1 += 1) {
            var tileID$1 = list$1[i$1];

            var tile$1 = this._tiles[tileID$1.key];

            if (tile$1.hasData()) {
                continue;
            }

            // The tile we require is not yet loaded or does not exist;
            // Attempt to find children that fully cover it.

            if (zoom + 1 > this._source.maxzoom) {
                // We're looking for an overzoomed child tile.
                var childCoord = tileID$1.children(this._source.maxzoom)[0];
                var childTile = this.getTile(childCoord);
                if (!!childTile && childTile.hasData()) {
                    retain[childCoord.key] = childCoord;
                    continue; // tile is covered by overzoomed child
                }
            } else {
                // check if all 4 immediate children are loaded (i.e. the missing ideal tile is covered)
                var children = tileID$1.children(this._source.maxzoom);

                if (retain[children[0].key] &&
                    retain[children[1].key] &&
                    retain[children[2].key] &&
                    retain[children[3].key]) {
                    continue;
                } // tile is covered by children
            }

            // We couldn't find child tiles that entirely cover the ideal tile; look for parents now.

            // As we ascend up the tile pyramid of the ideal tile, we check whether the parent
            // tile has been previously requested (and errored because we only loop over tiles with no data)
            // in order to determine if we need to request its parent.
            var parentWasRequested = tile$1.wasRequested();

            for (var overscaledZ = tileID$1.overscaledZ - 1; overscaledZ >= minCoveringZoom; --overscaledZ) {
                var parentId = tileID$1.scaledTo(overscaledZ);

                // Break parent tile ascent if this route has been previously checked by another child.
                if (checked[parentId.key]) {
                    break;
                }
                checked[parentId.key] = true;

                tile$1 = this.getTile(parentId);
                if (!tile$1 && parentWasRequested) {
                    tile$1 = this._addTile(parentId);
                }
                if (tile$1) {
                    retain[parentId.key] = parentId;
                    // Save the current values, since they're the parent of the next iteration
                    // of the parent tile ascent loop.
                    parentWasRequested = tile$1.wasRequested();
                    if (tile$1.hasData()) {
                        break;
                    }
                }
            }
        }

        return retain;
    };

    TileSourceCache.prototype._reAddTile = function _reAddTile(tileID) {
        var tile = new Tile(tileID, this._source.tileSize * tileID.overscaleFactor());
        this._loadTile(tile, this._tileReAddLoaded.bind(this, tile, tileID.key, tile.state));
    };

    TileSourceCache.prototype._tileReAddLoaded = function _tileLoaded(tile, id, previousState, err) {
        this._removeTile(id);
        this._tiles[tile.tileID.key] = tile;
        if (err) {
            tile.state = 'errored';
            if (err.status === 404) {
                this.update(this.transform);
            }
            return;
        }
        tile.timeAdded = utils.now();
        this._setTileReloadTimer(id, tile);
        this.layer.layerView._sourcesDirty = true;
        this.view.threeRender();
    };

    TileSourceCache.prototype._addTile = function _addTile(tileID) {
        var tile = this._tiles[tileID.key];
        if (tile) {
            return tile;
        }
        tile = this._cache.getAndRemove(tileID);
        if (tile) {
            this._setTileReloadTimer(tileID.key, tile);
            tile.tileID = tileID;
            if (this._cacheTimers[tileID.key]) {
                clearTimeout(this._cacheTimers[tileID.key]);
                delete this._cacheTimers[tileID.key];
                this._setTileReloadTimer(tileID.key, tile);
            }
        }

        var cached = Boolean(tile);
        if (!cached) {
            tile = new Tile(tileID, this._source.tileSize * tileID.overscaleFactor());
            this._loadTile(tile, this._tileLoaded.bind(this, tile, tileID.key, tile.state));
        }
        if (!tile) {
            return (null);
        }

        tile.uses++;
        this._tiles[tileID.key] = tile;
        return tile;
    };

    TileSourceCache.prototype._setTileReloadTimer = function _setTileReloadTimer(id, tile) {
        var this$1 = this;

        if (id in this._timers) {
            clearTimeout(this._timers[id]);
            delete this._timers[id];
        }

        var expiryTimeout = tile.getExpiryTimeout();
        if (expiryTimeout) {
            this._timers[id] = setTimeout(function () {
                this$1._reloadTile(id, 'expired');
                delete this$1._timers[id];
            }, expiryTimeout);
        }
    };

    TileSourceCache.prototype._removeTile = function _removeTile(id) {
        var tile = this._tiles[id];
        if (!tile) {
            return;
        }
        tile.uses--;
        delete this._tiles[id];
        if (this._timers[id]) {
            clearTimeout(this._timers[id]);
            delete this._timers[id];
        }

        if (tile.uses > 0) {
            return;
        }

        if (tile.hasData()) {
            // this._cache.add(tile.tileID, tile, tile.getExpiryTimeout());
        } else {
            tile.aborted = true;
            this._abortTile(tile);
            this._unloadTile(tile);
        }
    };

    TileSourceCache.prototype.clearTiles = function clearTiles() {
        this._shouldReloadOnResume = false;
        this._paused = false;
        for (var id in this._tiles) {
            this._removeTile(id);
        }
        this._cache.reset();
    };

    TileSourceCache.prototype.clearOtherLevel = function clearOtherLevel(level) {
        this._shouldReloadOnResume = false;
        this._paused = false;
        for (var id in this._tiles) {
            var tile = this._tiles[id];
            if (tile.tileID.canonical.z !== level) {
                this._removeTile(id);
            }
        }
        // this._cache.reset();
    };

    TileSourceCache.prototype.tilesIn = function tilesIn(pointQueryGeometry, maxPitchScaleFactor, has3DLayer) {
        var this$1 = this;


        var tileResults = [];

        var transform = this.transform;
        if (!transform) {
            return tileResults;
        }

        var cameraPointQueryGeometry = has3DLayer ?
            transform.getCameraQueryGeometry(pointQueryGeometry) :
            pointQueryGeometry;

        var queryGeometry = pointQueryGeometry.map(function (p) {
            return transform.pointCoordinate(p);
        });
        var cameraQueryGeometry = cameraPointQueryGeometry.map(function (p) {
            return transform.pointCoordinate(p);
        });

        var ids = this.getIds();

        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;

        for (var i$1 = 0, list = cameraQueryGeometry; i$1 < list.length; i$1 += 1) {
            var p = list[i$1];

            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        }

        var loop = function (i) {
            var tile = this$1._tiles[ids[i]];
            if (tile.holdingForFade()) {
                // Tiles held for fading are covered by tiles that are closer to ideal
                return;
            }
            var tileID = tile.tileID;
            var scale = Math.pow(2, transform.level - tile.tileID.overscaledZ);
            var queryPadding = maxPitchScaleFactor * tile.queryPadding * __chunk_1.EXTENT / tile.tileSize / scale;

            var tileSpaceBounds = [
                tileID.getTilePoint(new __chunk_1.MercatorCoordinate(minX, minY)),
                tileID.getTilePoint(new __chunk_1.MercatorCoordinate(maxX, maxY))
            ];

            if (tileSpaceBounds[0].x - queryPadding < __chunk_1.EXTENT && tileSpaceBounds[0].y - queryPadding < __chunk_1.EXTENT &&
                tileSpaceBounds[1].x + queryPadding >= 0 && tileSpaceBounds[1].y + queryPadding >= 0) {

                var tileSpaceQueryGeometry = queryGeometry.map(function (c) {
                    return tileID.getTilePoint(c);
                });
                var tileSpaceCameraQueryGeometry = cameraQueryGeometry.map(function (c) {
                    return tileID.getTilePoint(c);
                });

                tileResults.push({
                    tile: tile,
                    tileID: tileID,
                    queryGeometry: tileSpaceQueryGeometry,
                    cameraQueryGeometry: tileSpaceCameraQueryGeometry,
                    scale: scale
                });
            }
        };

        for (var i = 0; i < ids.length; i++) loop(i);

        return tileResults;
    };

    TileSourceCache.prototype.getVisibleCoordinates = function getVisibleCoordinates(symbolLayer, transform) {
        var this$1 = this;
        var coords = this.getRenderableIds().map(function (id) {
            return this$1._tiles[id].tileID;
        });
        this.currentCoords = [];
        for (var i = 0, list = coords; i < list.length; i += 1) {
            var coord = list[i];
            var wrap = coord.toUnwrapped();
            if (!coord.geometry) {
                coord.geometry = this.layer.tileInfo.getGeometry(wrap);
            }
            coord.posMatrix = transform.calculatePosMatrix(wrap, coord.geometry, true);
            this.currentCoords.push(coord);
        }
        return coords;
    };

    TileSourceCache.prototype.updateTileMatrix = function updateTileMatrix(symbolLayer, transform) {
        var coords = this.currentCoords;
        for (var i = 0, list = coords; i < list.length; i += 1) {
            var coord = list[i];
            coord.posMatrix = transform.updatePosMatrix(coord.toUnwrapped(), coord.geometry, true);
        }
        return coords;
    };

    TileSourceCache.prototype.hasTransition = function hasTransition() {
        if (this._source.hasTransition()) {
            return true;
        }
        for (var id in this._tiles) {
            var tile = this._tiles[id];
            if (tile.fadeEndTime !== undefined && tile.fadeEndTime >= utils.now()) {
                return true;
            }
        }
        return false;
    };

    TileSourceCache.maxOverzooming = 10;
    TileSourceCache.maxUnderzooming = 3;
    return TileSourceCache;
});
},
'com/huayun/webgis/layers/support/Tile':function(){
define([
    "com/huayun/webgis/data/bucket/SymbolBucket",
    "com/huayun/webgis/gl/Texture",
    "../../utils/utils",
    "./EvaluationParameters",
    "com/huayun/webgis/data/GeoJSONFeature"
], function (SymbolBucket, Texture, utils, EvaluationParameters, GeoJSONFeature) {

    function parseCacheControl(cacheControl) {
        // Taken from [Wreck](https://github.com/hapijs/wreck)
        var re = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;

        var header = {};
        cacheControl.replace(re, function ($0, $1, $2, $3) {
            var value = $2 || $3;
            header[$1] = value ? value.toLowerCase() : true;
            return '';
        });

        if (header['max-age']) {
            var maxAge = parseInt(header['max-age'], 10);
            if (isNaN(maxAge)) {
                delete header['max-age'];
            } else {
                header['max-age'] = maxAge;
            }
        }

        return header;
    }

    function deserialize(input, style) {
        var output = {};
        for (var i$1 = 0, list$1 = input; i$1 < list$1.length; i$1 += 1) {
            var bucket = list$1[i$1];

            var layers = bucket.layerIds
                .map(function (id) {
                    return style[id];
                })
                .filter(Boolean);
            if (layers.length === 0) {
                return;
            }
            // look up StyleLayer objects from layer ids (since we don't
            // want to waste time serializing/copying them from the worker)
            (bucket).layers = layers;
            if ((bucket).stateDependentLayerIds) {
                (bucket).stateDependentLayers = (bucket).stateDependentLayerIds.map(function (lId) {
                    return layers.filter(function (l) {
                        return l.id === lId;
                    })[0];
                });
            }
            for (var i = 0, list = layers; i < list.length; i += 1) {
                var layer = list[i];

                output[layer.id] = bucket;
            }
        }
        return output;
    }

    var id = 1;

    var CLOCK_SKEW_RETRY_TIMEOUT = 30000;

    var Tile = function Tile(tileID, size) {
        this.tileID = tileID;
        this.uid = id++;
        this.uses = 0;
        this.tileSize = 256; //size;
        this.buckets = {};
        this.expirationTime = null;
        this.queryPadding = 0;
        this.hasSymbolBuckets = false;
        this.expiredRequestCount = 0;
        this.state = 'loading';
    };

    Tile.prototype.wasRequested = function wasRequested() {
        return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading';
    };

    /**
     * , 
     * @param data
     */
    Tile.prototype.setExpiryData = function setExpiryData(data) {
        // data.cacheControl = "max-age=43200,s-maxage=300";
        var prior = this.expirationTime;
        if (data.cacheControl) {
            var parsedCC = parseCacheControl(data.cacheControl);
            if (parsedCC['max-age']) {
                this.expirationTime = Date.now() + parsedCC['max-age'] * 1000;
            }
        }
        if (this.expirationTime) {
            var now = Date.now();
            var isExpired = false;
            if (this.expirationTime > now) {
                isExpired = false;
            } else if (!prior) {
                isExpired = true;
            } else if (this.expirationTime < prior) {
                isExpired = true;
            } else {
                var delta = this.expirationTime - prior;
                if (!delta) {
                    isExpired = true;
                } else {
                    this.expirationTime = now + Math.max(delta, CLOCK_SKEW_RETRY_TIMEOUT);
                }
            }
            if (isExpired) {
                this.expiredRequestCount++;
                this.state = 'expired';
            } else {
                this.expiredRequestCount = 0;
            }
        }
    };

    /**
     * 
     * @return {number}
     */
    Tile.prototype.getExpiryTimeout = function getExpiryTimeout() {
        if (this.expirationTime) {
            if (this.expiredRequestCount) {
                return 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31));
            } else {
                return Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
            }
        }
    };


    Tile.prototype.registerFadeDuration = function registerFadeDuration(duration) {
        var fadeEndTime = duration + this.timeAdded;
        if (fadeEndTime < utils.now()) {
            return;
        }
        if (this.fadeEndTime && fadeEndTime < this.fadeEndTime) {
            return;
        }

        this.fadeEndTime = fadeEndTime;
    };



    Tile.prototype.loadVectorData = function loadVectorData(data, layer, justReloaded) {
        if (this.hasData()) {
            this.unloadVectorData();
        }

        this.state = 'loaded';

        // empty GeoJSON tile
        if (!data) {
            this.collisionBoxArray = new CollisionBoxArray();
            return;
        }

        if (data.featureIndex) {
            this.latestFeatureIndex = data.featureIndex;
            if (data.rawTileData) {
                // Only vector tiles have rawTileData, and they won't update it for
                // 'reloadTile'
                this.latestRawTileData = data.rawTileData;
                this.latestFeatureIndex.rawTileData = data.rawTileData;
            } else if (this.latestRawTileData) {
                // If rawTileData hasn't updated, hold onto a pointer to the last
                // one we received
                this.latestFeatureIndex.rawTileData = this.latestRawTileData;
            }
        }
        this.collisionBoxArray = data.collisionBoxArray;
        this.buckets = deserialize(data.buckets, layer._layers);

        this.hasSymbolBuckets = false;
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            if (bucket instanceof SymbolBucket) {
                this.hasSymbolBuckets = true;
                if (justReloaded) {
                    bucket.justReloaded = true;
                } else {
                    break;
                }
            }
        }

        this.queryPadding = 0;
        for (var id$1 in this.buckets) {
            var bucket$1 = this.buckets[id$1];
            this.queryPadding = Math.max(this.queryPadding, layer._layers[id$1].queryRadius(bucket$1));
        }

        if (data.imageAtlas) {
            this.imageAtlas = data.imageAtlas;
        }
        if (data.glyphAtlasImage) {
            this.glyphAtlasImage = data.glyphAtlasImage;
        }
    };

    /**
     * Release any data or WebGL resources referenced by this tile.
     * @returns {undefined}
     * @private
     */
    Tile.prototype.unloadVectorData = function unloadVectorData() {
        for (var id in this.buckets) {
            this.buckets[id].destroy();
        }
        this.buckets = {};

        if (this.imageAtlasTexture) {
            this.imageAtlasTexture.destroy();
        }

        if (this.imageAtlas) {
            this.imageAtlas = null;
        }

        if (this.glyphAtlasTexture) {
            this.glyphAtlasTexture.destroy();
        }

        this.latestFeatureIndex = null;
        this.state = 'unloaded';
    };

    Tile.prototype.getBucket = function getBucket(layer) {
        return this.buckets[layer.id];
    };

    Tile.prototype.upload = function upload(context) {
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            if (bucket.uploadPending()) {
                bucket.upload(context);
            }
        }

        var gl = context.gl;
        if (this.imageAtlas && !this.imageAtlas.uploaded) {
            this.imageAtlasTexture = new Texture(context, this.imageAtlas.image, gl.RGBA);
            this.imageAtlas.uploaded = true;
        }

        if (this.glyphAtlasImage) {
            this.glyphAtlasTexture = new Texture(context, this.glyphAtlasImage, gl.ALPHA);
            this.glyphAtlasImage = null;
        }
    };

    Tile.prototype.prepare = function prepare(imageManager) {
        if (this.imageAtlas) {
            this.imageAtlas.patchUpdatedImages(imageManager, this.imageAtlasTexture);
        }
    };

// Queries non-symbol features rendered for this tile.
// Symbol features are queried globally
    Tile.prototype.queryRenderedFeatures = function (layers, sourceFeatureState, queryGeometry, cameraQueryGeometry, scale, params, transform, maxPitchScaleFactor, pixelPosMatrix) {
        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) {
            return {};
        }

        return this.latestFeatureIndex.query({
            queryGeometry: queryGeometry,
            cameraQueryGeometry: cameraQueryGeometry,
            scale: scale,
            tileSize: this.tileSize,
            pixelPosMatrix: pixelPosMatrix,
            transform: transform,
            params: params,
            queryPadding: this.queryPadding * maxPitchScaleFactor
        }, layers, sourceFeatureState);
    };

    Tile.prototype.querySourceFeatures = function querySourceFeatures(result, params) {
        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) {
            return;
        }

        var vtLayers = this.latestFeatureIndex.loadVTLayers();

        var sourceLayer = params ? params.sourceLayer : '';
        var layer = vtLayers._geojsonTileLayer || vtLayers[sourceLayer];

        if (!layer) {
            return;
        }

        var filter = createFilter(params && params.filter);
        var ref = this.tileID.canonical;
        var z = ref.z;
        var x = ref.x;
        var y = ref.y;
        var coord = {z: z, x: x, y: y};

        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            if (filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {
                var geojsonFeature = new GeoJSONFeature(feature, z, x, y);
                geojsonFeature.tile = coord;
                result.push(geojsonFeature);
            }
        }
    };

    Tile.prototype.clearMask = function clearMask() {
        if (this.segments) {
            this.segments.destroy();
            delete this.segments;
        }
        if (this.maskedBoundsBuffer) {
            this.maskedBoundsBuffer.destroy();
            delete this.maskedBoundsBuffer;
        }
        if (this.maskedIndexBuffer) {
            this.maskedIndexBuffer.destroy();
            delete this.maskedIndexBuffer;
        }
    };

    Tile.prototype.setMask = function setMask(mask, context) {

        // don't redo buffer work if the mask is the same;
        if (deepEqual(this.mask, mask)) {
            return;
        }

        this.mask = mask;
        this.clearMask();

        // We want to render the full tile, and keeping the segments/vertices/indices empty means
        // using the global shared buffers for covering the entire tile.
        if (deepEqual(mask, {'0': true})) {
            return;
        }

        var maskedBoundsArray = new StructArrayLayout4i8();
        var indexArray = new StructArrayLayout3ui6();

        this.segments = new SegmentVector();
        // Create a new segment so that we will upload (empty) buffers even when there is nothing to
        // draw for this tile.
        this.segments.prepareSegment(0, maskedBoundsArray, indexArray);

        var maskArray = Object.keys(mask);
        for (var i = 0; i < maskArray.length; i++) {
            var maskCoord = mask[+maskArray[i]];
            var vertexExtent = EXTENT >> maskCoord.z;
            var tlVertex = new pointGeometry(maskCoord.x * vertexExtent, maskCoord.y * vertexExtent);
            var brVertex = new pointGeometry(tlVertex.x + vertexExtent, tlVertex.y + vertexExtent);

            // not sure why flow is complaining here because it doesn't complain at L401
            var segment = (this.segments).prepareSegment(4, maskedBoundsArray, indexArray);

            maskedBoundsArray.emplaceBack(tlVertex.x, tlVertex.y, tlVertex.x, tlVertex.y);
            maskedBoundsArray.emplaceBack(brVertex.x, tlVertex.y, brVertex.x, tlVertex.y);
            maskedBoundsArray.emplaceBack(tlVertex.x, brVertex.y, tlVertex.x, brVertex.y);
            maskedBoundsArray.emplaceBack(brVertex.x, brVertex.y, brVertex.x, brVertex.y);

            var offset = segment.vertexLength;
            // 0, 1, 2
            // 1, 2, 3
            indexArray.emplaceBack(offset, offset + 1, offset + 2);
            indexArray.emplaceBack(offset + 1, offset + 2, offset + 3);

            segment.vertexLength += 4;
            segment.primitiveLength += 2;
        }

        this.maskedBoundsBuffer = context.createVertexBuffer(maskedBoundsArray, rasterBoundsAttributes.members);
        this.maskedIndexBuffer = context.createIndexBuffer(indexArray);
    };

    Tile.prototype.hasData = function hasData() {
        return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired';
    };

    Tile.prototype.patternsLoaded = function patternsLoaded() {
        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
    };



    Tile.prototype.setFeatureState = function setFeatureState(states, painter) {
        if (!this.latestFeatureIndex ||
            !this.latestFeatureIndex.rawTileData ||
            Object.keys(states).length === 0) {
            return;
        }

        var vtLayers = this.latestFeatureIndex.loadVTLayers();

        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            // Buckets are grouped by common source-layer
            var sourceLayerId = bucket.layers[0]['sourceLayer'] || '_geojsonTileLayer';
            var sourceLayer = vtLayers[sourceLayerId];
            var sourceLayerStates = states[sourceLayerId];
            if (!sourceLayer || !sourceLayerStates || Object.keys(sourceLayerStates).length === 0) {
                continue;
            }

            bucket.update(sourceLayerStates, sourceLayer, this.imageAtlas && this.imageAtlas.patternPositions || {});
            if (painter && painter.style) {
                this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));
            }
        }
    };

    Tile.prototype.holdingForFade = function holdingForFade() {
        return this.symbolFadeHoldUntil !== undefined;
    };

    Tile.prototype.symbolFadeFinished = function symbolFadeFinished() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < utils.now();
    };

    Tile.prototype.clearFadeHold = function clearFadeHold() {
        this.symbolFadeHoldUntil = undefined;
    };

    Tile.prototype.setHoldDuration = function setHoldDuration(duration) {
        this.symbolFadeHoldUntil = exported.now() + duration;
    };

    return Tile;
});
},
'com/huayun/webgis/symbols/support/glyphManager':function(){
define([
    "require",
    "exports",
    "dojo/request",
    "../../gl/TinySDF",
    "../../utils/image",
    "../../data/Pbf"
], function (require, exports, request, TinySDF, image, Pbf) {
    var entries = {};
    var urlTemplate = "font/{fontstack}/{range}.pbf";
    var border = 3;

    function readGlyph(tag, glyph, pbf) {
        if (tag === 1) {
            glyph.id = pbf.readVarint();
        } else if (tag === 2) {
            glyph.bitmap = pbf.readBytes();
        } else if (tag === 3) {
            glyph.width = pbf.readVarint();
        } else if (tag === 4) {
            glyph.height = pbf.readVarint();
        } else if (tag === 5) {
            glyph.left = pbf.readSVarint();
        } else if (tag === 6) {
            glyph.top = pbf.readSVarint();
        } else if (tag === 7) {
            glyph.advance = pbf.readVarint();
        }
    }

    function readFontstack(tag, glyphs, pbf) {
        if (tag === 3) {
            var ref = pbf.readMessage(readGlyph, {});
            var id = ref.id;
            var bitmap = ref.bitmap;
            var width = ref.width;
            var height = ref.height;
            var left = ref.left;
            var top = ref.top;
            var advance = ref.advance;
            glyphs.push({
                id: id,
                bitmap: new image.AlphaImage({
                    width: width + 2 * border,
                    height: height + 2 * border
                }, bitmap),
                metrics: {width: width, height: height, left: left, top: top, advance: advance}
            });
        }
    }

    function readFontstacks(tag, glyphs, pbf) {
        if (tag === 1) {
            pbf.readMessage(readFontstack, glyphs);
        }
    }

    function parseGlyphPBF(data) {
        return new Pbf(data).readFields(readFontstacks, []);
    }

    function parseFont(stack) {
        var font = stack.split(" ");
        if (font.length === 1) {
            return {
                fontWeight: '400',
                fontFamily: stack
            };
        } else if (font.length === 2) {
            return {
                fontWeight: font[0],
                fontFamily: font[1]
            }
        }
    }

    function _tinySDF(entry, stack, id) {
        var parse = parseFont(stack);
        var family = parse.fontFamily;
        var tinySDF = entry.tinySDF;
        if (!tinySDF) {
            var fontWeight = parse.fontWeight;
            if (/bold/i.test(stack)) {
                fontWeight = '900';
            } else if (/medium/i.test(stack)) {
                fontWeight = '500';
            } else if (/light/i.test(stack)) {
                fontWeight = '200';
            }
            tinySDF = entry.tinySDF = new TinySDF(24, 1, 8, .25, family, fontWeight);
        }
        var str = String.fromCharCode(id);
        if (id < 255) {
            return {
                id: id,
                bitmap: new image.AlphaImage({width: 26, height: 26}, tinySDF.draw(str)),
                metrics: {
                    width: 24,
                    height: 24,
                    left: 0,
                    top: -8,
                    advance: tinySDF.measureText(str).width
                }
            };
        } else {
            return {
                id: id,
                bitmap: new image.AlphaImage({width: 26, height: 26}, tinySDF.draw(str)),
                metrics: {
                    width: 24,
                    height: 24,
                    left: 0,
                    top: -8,
                    advance: 24
                }
            };
        }
    }

    exports.getGlyphs = function (glyphs) {
        var result = {};
        for (var stack in glyphs) {
            result[stack] = {};
            for (var i = 0, list = glyphs[stack]; i < list.length; i++) {
                var id = list[i];
                var entry = entries[stack];
                if (!entry) {
                    entry = entries[stack] = {
                        glyphs: {}
                    }
                }
                var glyph = entry.glyphs[id];
                if (glyph) {
                    result[stack][id] = glyph;
                    continue;
                }
                glyph = _tinySDF(entry, stack, id);
                if (glyph) {
                    result[stack][id] = glyph;
                }
            }
        }
        return result;
    }

    function loadGlyphRange(fontstack, range, callback) {
        var begin = range * 256;
        var end = begin + 255;
        var url = urlTemplate.replace('{fontstack}', fontstack).replace('{range}', (begin + "-" + end));
        request(require.toUrl(url), {handleAs: "arraybuffer"}).then(function (data) {
            var glyphs = {};
            for (var i = 0, list = parseGlyphPBF(data); i < list.length; i += 1) {
                var glyph = list[i];
                glyphs[glyph.id] = glyph;
            }
            callback(null, glyphs);
        }).catch(function (err) {
            callback(err);
        })
    }

    exports.getGlyphsFromPbf = function (glyphs, callback) {
        for (var stack in glyphs) {
            for (var i = 0, list = glyphs[stack]; i < list.length; i++) {
                var id = list[i];
                var entry = entries[stack];
                if (!entry) {
                    entry = entries[stack] = {
                        glyphs: {},
                        requests: {}
                    }
                }
                var glyph = entry.glyphs[id];
                if (glyph) {
                    callback(null, {stack: stack, id: id, glyph: glyph})
                    continue;
                }

                var range = Math.floor(id / 256);
                var requests = entry.requests[range];
                if (!requests) {
                    requests = entry.requests[range] = [];
                    loadGlyphRange(stack, range, function (err, response) {
                        if (response) {
                            for (var id in response) {
                                entry.glyphs[+id] = response[+id];
                            }
                        }
                        for (var i = 0, list = requests; i < list.length; i += 1) {
                            var cb = list[i];
                            cb(err, response)
                        }
                        delete entry.requests[range];
                    });
                }
                requests.push(function (err, result) {
                    if (err) {
                        callback(err);
                    } else if (result) {
                        callback(null, {stack: stack, id: id, glyph: result[id] || null})
                    }
                })
            }
        }
    }
});

},
'com/huayun/webgis/utils/Constant':function(){
define([
  "exports"
], function (exports) {

  exports.ONE_EM = 24;
  exports.MAX_GLYPHS = 65535;


  // webgl
  exports.glConstant = {
    ALWAYS: 0x0207,
    LEQUAL: 515,
    BACK: 0x0405,
    CCW: 0x0901,
    ZERO: 0x0000,
    ONE: 0x0001,
    ONE_MINUS_SRC_ALPHA: 0x0303,
    SRC_ALPHA: 770,
    KEEP: 0x1E00
  };

  exports.viewTypes = {
    'Int8': Int8Array,
    'Uint8': Uint8Array,
    'Int16': Int16Array,
    'Uint16': Uint16Array,
    'Int32': Int32Array,
    'Uint32': Uint32Array,
    'Float32': Float32Array
  };
  exports.AttributeType = {
    Int8: 'BYTE',
    Uint8: 'UNSIGNED_BYTE',
    Int16: 'SHORT',
    Uint16: 'UNSIGNED_SHORT',
    Int32: 'INT',
    Uint32: 'UNSIGNED_INT',
    Float32: 'FLOAT'
  };

  exports.types = {
    string: {kind: 'string'},
    number: {kind: 'number'},
    boolean: {kind: 'boolean'},
    object: {kind: 'object'}
  };

  exports.geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

  exports.layout = {
    EXTENT: 8192,
    border: 3,
    EXTRUDE_SCALE: 63,
    LINE_DISTANCE_BUFFER_BITS: 15,
    LINE_DISTANCE_SCALE: 1 / 2,
    MAX_LINE_DISTANCE: Math.pow(2, 14) / 0.5,
    SHARP_CORNER_OFFSET: 15,
    COS_HALF_SHARP_CORNER: Math.cos(75 / 2 * (Math.PI / 180)),
    EARCUT_MAX_RINGS: 500,
    padding: 1
  };

  exports.collisionBoxLayout = [
    {name: 'a_pos', components: 2, type: 'Int16', offset: 0},
    {name: 'a_anchor_pos', components: 2, type: 'Int16', offset: 4},
    {name: 'a_extrude', components: 2, type: 'Int16', offset: 8}
  ];

  exports.collisionCircleLayout = [
    {name: 'a_pos', components: 2, type: 'Int16', offset: 0},
    {name: 'a_anchor_pos', components: 2, type: 'Int16', offset: 4},
    {name: 'a_extrude', components: 2, type: 'Int16', offset: 8}
  ];

  var whitespace = {};
  whitespace[0x09] = true;
  whitespace[0x0a] = true;
  whitespace[0x0b] = true;
  whitespace[0x0c] = true;
  whitespace[0x0d] = true;
  whitespace[0x20] = true;
  exports.whitespace = whitespace;

  exports.verticalizedCharacterMap = {
    '!': '',
    '#': '',
    '$': '',
    '%': '',
    '&': '',
    '(': '',
    ')': '',
    '*': '',
    '+': '',
    ',': '',
    '-': '',
    '.': '',
    '/': '',
    ':': '',
    ';': '',
    '<': '',
    '=': '',
    '>': '',
    '?': '',
    '@': '',
    '[': '',
    '\\': '',
    ']': '',
    '^': '',
    '_': '',
    '`': '',
    '{': '',
    '|': '',
    '}': '',
    '~': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': '',
    '': ''
  };

  exports.unicodeBlockLookup = {
    // 'Basic Latin': (ch) => ch >= 0x0000 && ch <= 0x007F,
    'Latin-1 Supplement': function (ch) {
      return ch >= 0x0080 && ch <= 0x00FF;
    },
    // 'Latin Extended-A': (ch) => ch >= 0x0100 && ch <= 0x017F,
    // 'Latin Extended-B': (ch) => ch >= 0x0180 && ch <= 0x024F,
    // 'IPA Extensions': (ch) => ch >= 0x0250 && ch <= 0x02AF,
    // 'Spacing Modifier Letters': (ch) => ch >= 0x02B0 && ch <= 0x02FF,
    // 'Combining Diacritical Marks': (ch) => ch >= 0x0300 && ch <= 0x036F,
    // 'Greek and Coptic': (ch) => ch >= 0x0370 && ch <= 0x03FF,
    // 'Cyrillic': (ch) => ch >= 0x0400 && ch <= 0x04FF,
    // 'Cyrillic Supplement': (ch) => ch >= 0x0500 && ch <= 0x052F,
    // 'Armenian': (ch) => ch >= 0x0530 && ch <= 0x058F,
    //'Hebrew': (ch) => ch >= 0x0590 && ch <= 0x05FF,
    'Arabic': function (ch) {
      return ch >= 0x0600 && ch <= 0x06FF;
    },
    //'Syriac': (ch) => ch >= 0x0700 && ch <= 0x074F,
    'Arabic Supplement': function (ch) {
      return ch >= 0x0750 && ch <= 0x077F;
    },
    // 'Thaana': (ch) => ch >= 0x0780 && ch <= 0x07BF,
    // 'NKo': (ch) => ch >= 0x07C0 && ch <= 0x07FF,
    // 'Samaritan': (ch) => ch >= 0x0800 && ch <= 0x083F,
    // 'Mandaic': (ch) => ch >= 0x0840 && ch <= 0x085F,
    // 'Syriac Supplement': (ch) => ch >= 0x0860 && ch <= 0x086F,
    'Arabic Extended-A': function (ch) {
      return ch >= 0x08A0 && ch <= 0x08FF;
    },
    // 'Devanagari': (ch) => ch >= 0x0900 && ch <= 0x097F,
    // 'Bengali': (ch) => ch >= 0x0980 && ch <= 0x09FF,
    // 'Gurmukhi': (ch) => ch >= 0x0A00 && ch <= 0x0A7F,
    // 'Gujarati': (ch) => ch >= 0x0A80 && ch <= 0x0AFF,
    // 'Oriya': (ch) => ch >= 0x0B00 && ch <= 0x0B7F,
    // 'Tamil': (ch) => ch >= 0x0B80 && ch <= 0x0BFF,
    // 'Telugu': (ch) => ch >= 0x0C00 && ch <= 0x0C7F,
    // 'Kannada': (ch) => ch >= 0x0C80 && ch <= 0x0CFF,
    // 'Malayalam': (ch) => ch >= 0x0D00 && ch <= 0x0D7F,
    // 'Sinhala': (ch) => ch >= 0x0D80 && ch <= 0x0DFF,
    // 'Thai': (ch) => ch >= 0x0E00 && ch <= 0x0E7F,
    // 'Lao': (ch) => ch >= 0x0E80 && ch <= 0x0EFF,
    // 'Tibetan': (ch) => ch >= 0x0F00 && ch <= 0x0FFF,
    // 'Myanmar': (ch) => ch >= 0x1000 && ch <= 0x109F,
    // 'Georgian': (ch) => ch >= 0x10A0 && ch <= 0x10FF,
    'Hangul Jamo': function (ch) {
      return ch >= 0x1100 && ch <= 0x11FF;
    },
    // 'Ethiopic': (ch) => ch >= 0x1200 && ch <= 0x137F,
    // 'Ethiopic Supplement': (ch) => ch >= 0x1380 && ch <= 0x139F,
    // 'Cherokee': (ch) => ch >= 0x13A0 && ch <= 0x13FF,
    'Unified Canadian Aboriginal Syllabics': function (ch) {
      return ch >= 0x1400 && ch <= 0x167F;
    },
    // 'Ogham': (ch) => ch >= 0x1680 && ch <= 0x169F,
    // 'Runic': (ch) => ch >= 0x16A0 && ch <= 0x16FF,
    // 'Tagalog': (ch) => ch >= 0x1700 && ch <= 0x171F,
    // 'Hanunoo': (ch) => ch >= 0x1720 && ch <= 0x173F,
    // 'Buhid': (ch) => ch >= 0x1740 && ch <= 0x175F,
    // 'Tagbanwa': (ch) => ch >= 0x1760 && ch <= 0x177F,
    'Khmer': function (ch) {
      return ch >= 0x1780 && ch <= 0x17FF;
    },
    // 'Mongolian': (ch) => ch >= 0x1800 && ch <= 0x18AF,
    'Unified Canadian Aboriginal Syllabics Extended': function (ch) {
      return ch >= 0x18B0 && ch <= 0x18FF;
    },
    // 'Limbu': (ch) => ch >= 0x1900 && ch <= 0x194F,
    // 'Tai Le': (ch) => ch >= 0x1950 && ch <= 0x197F,
    // 'New Tai Lue': (ch) => ch >= 0x1980 && ch <= 0x19DF,
    // 'Khmer Symbols': (ch) => ch >= 0x19E0 && ch <= 0x19FF,
    // 'Buginese': (ch) => ch >= 0x1A00 && ch <= 0x1A1F,
    // 'Tai Tham': (ch) => ch >= 0x1A20 && ch <= 0x1AAF,
    // 'Combining Diacritical Marks Extended': (ch) => ch >= 0x1AB0 && ch <= 0x1AFF,
    // 'Balinese': (ch) => ch >= 0x1B00 && ch <= 0x1B7F,
    // 'Sundanese': (ch) => ch >= 0x1B80 && ch <= 0x1BBF,
    // 'Batak': (ch) => ch >= 0x1BC0 && ch <= 0x1BFF,
    // 'Lepcha': (ch) => ch >= 0x1C00 && ch <= 0x1C4F,
    // 'Ol Chiki': (ch) => ch >= 0x1C50 && ch <= 0x1C7F,
    // 'Cyrillic Extended-C': (ch) => ch >= 0x1C80 && ch <= 0x1C8F,
    // 'Georgian Extended': (ch) => ch >= 0x1C90 && ch <= 0x1CBF,
    // 'Sundanese Supplement': (ch) => ch >= 0x1CC0 && ch <= 0x1CCF,
    // 'Vedic Extensions': (ch) => ch >= 0x1CD0 && ch <= 0x1CFF,
    // 'Phonetic Extensions': (ch) => ch >= 0x1D00 && ch <= 0x1D7F,
    // 'Phonetic Extensions Supplement': (ch) => ch >= 0x1D80 && ch <= 0x1DBF,
    // 'Combining Diacritical Marks Supplement': (ch) => ch >= 0x1DC0 && ch <= 0x1DFF,
    // 'Latin Extended Additional': (ch) => ch >= 0x1E00 && ch <= 0x1EFF,
    // 'Greek Extended': (ch) => ch >= 0x1F00 && ch <= 0x1FFF,
    'General Punctuation': function (ch) {
      return ch >= 0x2000 && ch <= 0x206F;
    },
    // 'Superscripts and Subscripts': (ch) => ch >= 0x2070 && ch <= 0x209F,
    // 'Currency Symbols': (ch) => ch >= 0x20A0 && ch <= 0x20CF,
    // 'Combining Diacritical Marks for Symbols': (ch) => ch >= 0x20D0 && ch <= 0x20FF,
    'Letterlike Symbols': function (ch) {
      return ch >= 0x2100 && ch <= 0x214F;
    },
    'Number Forms': function (ch) {
      return ch >= 0x2150 && ch <= 0x218F;
    },
    // 'Arrows': (ch) => ch >= 0x2190 && ch <= 0x21FF,
    // 'Mathematical Operators': (ch) => ch >= 0x2200 && ch <= 0x22FF,
    'Miscellaneous Technical': function (ch) {
      return ch >= 0x2300 && ch <= 0x23FF;
    },
    'Control Pictures': function (ch) {
      return ch >= 0x2400 && ch <= 0x243F;
    },
    'Optical Character Recognition': function (ch) {
      return ch >= 0x2440 && ch <= 0x245F;
    },
    'Enclosed Alphanumerics': function (ch) {
      return ch >= 0x2460 && ch <= 0x24FF;
    },
    // 'Box Drawing': (ch) => ch >= 0x2500 && ch <= 0x257F,
    // 'Block Elements': (ch) => ch >= 0x2580 && ch <= 0x259F,
    'Geometric Shapes': function (ch) {
      return ch >= 0x25A0 && ch <= 0x25FF;
    },
    'Miscellaneous Symbols': function (ch) {
      return ch >= 0x2600 && ch <= 0x26FF;
    },
    // 'Dingbats': (ch) => ch >= 0x2700 && ch <= 0x27BF,
    // 'Miscellaneous Mathematical Symbols-A': (ch) => ch >= 0x27C0 && ch <= 0x27EF,
    // 'Supplemental Arrows-A': (ch) => ch >= 0x27F0 && ch <= 0x27FF,
    // 'Braille Patterns': (ch) => ch >= 0x2800 && ch <= 0x28FF,
    // 'Supplemental Arrows-B': (ch) => ch >= 0x2900 && ch <= 0x297F,
    // 'Miscellaneous Mathematical Symbols-B': (ch) => ch >= 0x2980 && ch <= 0x29FF,
    // 'Supplemental Mathematical Operators': (ch) => ch >= 0x2A00 && ch <= 0x2AFF,
    'Miscellaneous Symbols and Arrows': function (ch) {
      return ch >= 0x2B00 && ch <= 0x2BFF;
    },
    // 'Glagolitic': (ch) => ch >= 0x2C00 && ch <= 0x2C5F,
    // 'Latin Extended-C': (ch) => ch >= 0x2C60 && ch <= 0x2C7F,
    // 'Coptic': (ch) => ch >= 0x2C80 && ch <= 0x2CFF,
    // 'Georgian Supplement': (ch) => ch >= 0x2D00 && ch <= 0x2D2F,
    // 'Tifinagh': (ch) => ch >= 0x2D30 && ch <= 0x2D7F,
    // 'Ethiopic Extended': (ch) => ch >= 0x2D80 && ch <= 0x2DDF,
    // 'Cyrillic Extended-A': (ch) => ch >= 0x2DE0 && ch <= 0x2DFF,
    // 'Supplemental Punctuation': (ch) => ch >= 0x2E00 && ch <= 0x2E7F,
    'CJK Radicals Supplement': function (ch) {
      return ch >= 0x2E80 && ch <= 0x2EFF;
    },
    'Kangxi Radicals': function (ch) {
      return ch >= 0x2F00 && ch <= 0x2FDF;
    },
    'Ideographic Description Characters': function (ch) {
      return ch >= 0x2FF0 && ch <= 0x2FFF;
    },
    'CJK Symbols and Punctuation': function (ch) {
      return ch >= 0x3000 && ch <= 0x303F;
    },
    'Hiragana': function (ch) {
      return ch >= 0x3040 && ch <= 0x309F;
    },
    'Katakana': function (ch) {
      return ch >= 0x30A0 && ch <= 0x30FF;
    },
    'Bopomofo': function (ch) {
      return ch >= 0x3100 && ch <= 0x312F;
    },
    'Hangul Compatibility Jamo': function (ch) {
      return ch >= 0x3130 && ch <= 0x318F;
    },
    'Kanbun': function (ch) {
      return ch >= 0x3190 && ch <= 0x319F;
    },
    'Bopomofo Extended': function (ch) {
      return ch >= 0x31A0 && ch <= 0x31BF;
    },
    'CJK Strokes': function (ch) {
      return ch >= 0x31C0 && ch <= 0x31EF;
    },
    'Katakana Phonetic Extensions': function (ch) {
      return ch >= 0x31F0 && ch <= 0x31FF;
    },
    'Enclosed CJK Letters and Months': function (ch) {
      return ch >= 0x3200 && ch <= 0x32FF;
    },
    'CJK Compatibility': function (ch) {
      return ch >= 0x3300 && ch <= 0x33FF;
    },
    'CJK Unified Ideographs Extension A': function (ch) {
      return ch >= 0x3400 && ch <= 0x4DBF;
    },
    'Yijing Hexagram Symbols': function (ch) {
      return ch >= 0x4DC0 && ch <= 0x4DFF;
    },
    'CJK Unified Ideographs': function (ch) {
      return ch >= 0x4E00 && ch <= 0x9FFF;
    },
    'Yi Syllables': function (ch) {
      return ch >= 0xA000 && ch <= 0xA48F;
    },
    'Yi Radicals': function (ch) {
      return ch >= 0xA490 && ch <= 0xA4CF;
    },
    // 'Lisu': (ch) => ch >= 0xA4D0 && ch <= 0xA4FF,
    // 'Vai': (ch) => ch >= 0xA500 && ch <= 0xA63F,
    // 'Cyrillic Extended-B': (ch) => ch >= 0xA640 && ch <= 0xA69F,
    // 'Bamum': (ch) => ch >= 0xA6A0 && ch <= 0xA6FF,
    // 'Modifier Tone Letters': (ch) => ch >= 0xA700 && ch <= 0xA71F,
    // 'Latin Extended-D': (ch) => ch >= 0xA720 && ch <= 0xA7FF,
    // 'Syloti Nagri': (ch) => ch >= 0xA800 && ch <= 0xA82F,
    // 'Common Indic Number Forms': (ch) => ch >= 0xA830 && ch <= 0xA83F,
    // 'Phags-pa': (ch) => ch >= 0xA840 && ch <= 0xA87F,
    // 'Saurashtra': (ch) => ch >= 0xA880 && ch <= 0xA8DF,
    // 'Devanagari Extended': (ch) => ch >= 0xA8E0 && ch <= 0xA8FF,
    // 'Kayah Li': (ch) => ch >= 0xA900 && ch <= 0xA92F,
    // 'Rejang': (ch) => ch >= 0xA930 && ch <= 0xA95F,
    'Hangul Jamo Extended-A': function (ch) {
      return ch >= 0xA960 && ch <= 0xA97F;
    },
    // 'Javanese': (ch) => ch >= 0xA980 && ch <= 0xA9DF,
    // 'Myanmar Extended-B': (ch) => ch >= 0xA9E0 && ch <= 0xA9FF,
    // 'Cham': (ch) => ch >= 0xAA00 && ch <= 0xAA5F,
    // 'Myanmar Extended-A': (ch) => ch >= 0xAA60 && ch <= 0xAA7F,
    // 'Tai Viet': (ch) => ch >= 0xAA80 && ch <= 0xAADF,
    // 'Meetei Mayek Extensions': (ch) => ch >= 0xAAE0 && ch <= 0xAAFF,
    // 'Ethiopic Extended-A': (ch) => ch >= 0xAB00 && ch <= 0xAB2F,
    // 'Latin Extended-E': (ch) => ch >= 0xAB30 && ch <= 0xAB6F,
    // 'Cherokee Supplement': (ch) => ch >= 0xAB70 && ch <= 0xABBF,
    // 'Meetei Mayek': (ch) => ch >= 0xABC0 && ch <= 0xABFF,
    'Hangul Syllables': function (ch) {
      return ch >= 0xAC00 && ch <= 0xD7AF;
    },
    'Hangul Jamo Extended-B': function (ch) {
      return ch >= 0xD7B0 && ch <= 0xD7FF;
    },
    // 'High Surrogates': (ch) => ch >= 0xD800 && ch <= 0xDB7F,
    // 'High Private Use Surrogates': (ch) => ch >= 0xDB80 && ch <= 0xDBFF,
    // 'Low Surrogates': (ch) => ch >= 0xDC00 && ch <= 0xDFFF,
    'Private Use Area': function (ch) {
      return ch >= 0xE000 && ch <= 0xF8FF;
    },
    'CJK Compatibility Ideographs': function (ch) {
      return ch >= 0xF900 && ch <= 0xFAFF;
    },
    // 'Alphabetic Presentation Forms': (ch) => ch >= 0xFB00 && ch <= 0xFB4F,
    'Arabic Presentation Forms-A': function (ch) {
      return ch >= 0xFB50 && ch <= 0xFDFF;
    },
    // 'Variation Selectors': (ch) => ch >= 0xFE00 && ch <= 0xFE0F,
    'Vertical Forms': function (ch) {
      return ch >= 0xFE10 && ch <= 0xFE1F;
    },
    // 'Combining Half Marks': (ch) => ch >= 0xFE20 && ch <= 0xFE2F,
    'CJK Compatibility Forms': function (ch) {
      return ch >= 0xFE30 && ch <= 0xFE4F;
    },
    'Small Form Variants': function (ch) {
      return ch >= 0xFE50 && ch <= 0xFE6F;
    },
    'Arabic Presentation Forms-B': function (ch) {
      return ch >= 0xFE70 && ch <= 0xFEFF;
    },
    'Halfwidth and Fullwidth Forms': function (ch) {
      return ch >= 0xFF00 && ch <= 0xFFEF;
    }
    // 'Specials': (ch) => ch >= 0xFFF0 && ch <= 0xFFFF,
    // 'Linear B Syllabary': (ch) => ch >= 0x10000 && ch <= 0x1007F,
    // 'Linear B Ideograms': (ch) => ch >= 0x10080 && ch <= 0x100FF,
    // 'Aegean Numbers': (ch) => ch >= 0x10100 && ch <= 0x1013F,
    // 'Ancient Greek Numbers': (ch) => ch >= 0x10140 && ch <= 0x1018F,
    // 'Ancient Symbols': (ch) => ch >= 0x10190 && ch <= 0x101CF,
    // 'Phaistos Disc': (ch) => ch >= 0x101D0 && ch <= 0x101FF,
    // 'Lycian': (ch) => ch >= 0x10280 && ch <= 0x1029F,
    // 'Carian': (ch) => ch >= 0x102A0 && ch <= 0x102DF,
    // 'Coptic Epact Numbers': (ch) => ch >= 0x102E0 && ch <= 0x102FF,
    // 'Old Italic': (ch) => ch >= 0x10300 && ch <= 0x1032F,
    // 'Gothic': (ch) => ch >= 0x10330 && ch <= 0x1034F,
    // 'Old Permic': (ch) => ch >= 0x10350 && ch <= 0x1037F,
    // 'Ugaritic': (ch) => ch >= 0x10380 && ch <= 0x1039F,
    // 'Old Persian': (ch) => ch >= 0x103A0 && ch <= 0x103DF,
    // 'Deseret': (ch) => ch >= 0x10400 && ch <= 0x1044F,
    // 'Shavian': (ch) => ch >= 0x10450 && ch <= 0x1047F,
    // 'Osmanya': (ch) => ch >= 0x10480 && ch <= 0x104AF,
    // 'Osage': (ch) => ch >= 0x104B0 && ch <= 0x104FF,
    // 'Elbasan': (ch) => ch >= 0x10500 && ch <= 0x1052F,
    // 'Caucasian Albanian': (ch) => ch >= 0x10530 && ch <= 0x1056F,
    // 'Linear A': (ch) => ch >= 0x10600 && ch <= 0x1077F,
    // 'Cypriot Syllabary': (ch) => ch >= 0x10800 && ch <= 0x1083F,
    // 'Imperial Aramaic': (ch) => ch >= 0x10840 && ch <= 0x1085F,
    // 'Palmyrene': (ch) => ch >= 0x10860 && ch <= 0x1087F,
    // 'Nabataean': (ch) => ch >= 0x10880 && ch <= 0x108AF,
    // 'Hatran': (ch) => ch >= 0x108E0 && ch <= 0x108FF,
    // 'Phoenician': (ch) => ch >= 0x10900 && ch <= 0x1091F,
    // 'Lydian': (ch) => ch >= 0x10920 && ch <= 0x1093F,
    // 'Meroitic Hieroglyphs': (ch) => ch >= 0x10980 && ch <= 0x1099F,
    // 'Meroitic Cursive': (ch) => ch >= 0x109A0 && ch <= 0x109FF,
    // 'Kharoshthi': (ch) => ch >= 0x10A00 && ch <= 0x10A5F,
    // 'Old South Arabian': (ch) => ch >= 0x10A60 && ch <= 0x10A7F,
    // 'Old North Arabian': (ch) => ch >= 0x10A80 && ch <= 0x10A9F,
    // 'Manichaean': (ch) => ch >= 0x10AC0 && ch <= 0x10AFF,
    // 'Avestan': (ch) => ch >= 0x10B00 && ch <= 0x10B3F,
    // 'Inscriptional Parthian': (ch) => ch >= 0x10B40 && ch <= 0x10B5F,
    // 'Inscriptional Pahlavi': (ch) => ch >= 0x10B60 && ch <= 0x10B7F,
    // 'Psalter Pahlavi': (ch) => ch >= 0x10B80 && ch <= 0x10BAF,
    // 'Old Turkic': (ch) => ch >= 0x10C00 && ch <= 0x10C4F,
    // 'Old Hungarian': (ch) => ch >= 0x10C80 && ch <= 0x10CFF,
    // 'Hanifi Rohingya': (ch) => ch >= 0x10D00 && ch <= 0x10D3F,
    // 'Rumi Numeral Symbols': (ch) => ch >= 0x10E60 && ch <= 0x10E7F,
    // 'Old Sogdian': (ch) => ch >= 0x10F00 && ch <= 0x10F2F,
    // 'Sogdian': (ch) => ch >= 0x10F30 && ch <= 0x10F6F,
    // 'Elymaic': (ch) => ch >= 0x10FE0 && ch <= 0x10FFF,
    // 'Brahmi': (ch) => ch >= 0x11000 && ch <= 0x1107F,
    // 'Kaithi': (ch) => ch >= 0x11080 && ch <= 0x110CF,
    // 'Sora Sompeng': (ch) => ch >= 0x110D0 && ch <= 0x110FF,
    // 'Chakma': (ch) => ch >= 0x11100 && ch <= 0x1114F,
    // 'Mahajani': (ch) => ch >= 0x11150 && ch <= 0x1117F,
    // 'Sharada': (ch) => ch >= 0x11180 && ch <= 0x111DF,
    // 'Sinhala Archaic Numbers': (ch) => ch >= 0x111E0 && ch <= 0x111FF,
    // 'Khojki': (ch) => ch >= 0x11200 && ch <= 0x1124F,
    // 'Multani': (ch) => ch >= 0x11280 && ch <= 0x112AF,
    // 'Khudawadi': (ch) => ch >= 0x112B0 && ch <= 0x112FF,
    // 'Grantha': (ch) => ch >= 0x11300 && ch <= 0x1137F,
    // 'Newa': (ch) => ch >= 0x11400 && ch <= 0x1147F,
    // 'Tirhuta': (ch) => ch >= 0x11480 && ch <= 0x114DF,
    // 'Siddham': (ch) => ch >= 0x11580 && ch <= 0x115FF,
    // 'Modi': (ch) => ch >= 0x11600 && ch <= 0x1165F,
    // 'Mongolian Supplement': (ch) => ch >= 0x11660 && ch <= 0x1167F,
    // 'Takri': (ch) => ch >= 0x11680 && ch <= 0x116CF,
    // 'Ahom': (ch) => ch >= 0x11700 && ch <= 0x1173F,
    // 'Dogra': (ch) => ch >= 0x11800 && ch <= 0x1184F,
    // 'Warang Citi': (ch) => ch >= 0x118A0 && ch <= 0x118FF,
    // 'Nandinagari': (ch) => ch >= 0x119A0 && ch <= 0x119FF,
    // 'Zanabazar Square': (ch) => ch >= 0x11A00 && ch <= 0x11A4F,
    // 'Soyombo': (ch) => ch >= 0x11A50 && ch <= 0x11AAF,
    // 'Pau Cin Hau': (ch) => ch >= 0x11AC0 && ch <= 0x11AFF,
    // 'Bhaiksuki': (ch) => ch >= 0x11C00 && ch <= 0x11C6F,
    // 'Marchen': (ch) => ch >= 0x11C70 && ch <= 0x11CBF,
    // 'Masaram Gondi': (ch) => ch >= 0x11D00 && ch <= 0x11D5F,
    // 'Gunjala Gondi': (ch) => ch >= 0x11D60 && ch <= 0x11DAF,
    // 'Makasar': (ch) => ch >= 0x11EE0 && ch <= 0x11EFF,
    // 'Tamil Supplement': (ch) => ch >= 0x11FC0 && ch <= 0x11FFF,
    // 'Cuneiform': (ch) => ch >= 0x12000 && ch <= 0x123FF,
    // 'Cuneiform Numbers and Punctuation': (ch) => ch >= 0x12400 && ch <= 0x1247F,
    // 'Early Dynastic Cuneiform': (ch) => ch >= 0x12480 && ch <= 0x1254F,
    // 'Egyptian Hieroglyphs': (ch) => ch >= 0x13000 && ch <= 0x1342F,
    // 'Egyptian Hieroglyph Format Controls': (ch) => ch >= 0x13430 && ch <= 0x1343F,
    // 'Anatolian Hieroglyphs': (ch) => ch >= 0x14400 && ch <= 0x1467F,
    // 'Bamum Supplement': (ch) => ch >= 0x16800 && ch <= 0x16A3F,
    // 'Mro': (ch) => ch >= 0x16A40 && ch <= 0x16A6F,
    // 'Bassa Vah': (ch) => ch >= 0x16AD0 && ch <= 0x16AFF,
    // 'Pahawh Hmong': (ch) => ch >= 0x16B00 && ch <= 0x16B8F,
    // 'Medefaidrin': (ch) => ch >= 0x16E40 && ch <= 0x16E9F,
    // 'Miao': (ch) => ch >= 0x16F00 && ch <= 0x16F9F,
    // 'Ideographic Symbols and Punctuation': (ch) => ch >= 0x16FE0 && ch <= 0x16FFF,
    // 'Tangut': (ch) => ch >= 0x17000 && ch <= 0x187FF,
    // 'Tangut Components': (ch) => ch >= 0x18800 && ch <= 0x18AFF,
    // 'Kana Supplement': (ch) => ch >= 0x1B000 && ch <= 0x1B0FF,
    // 'Kana Extended-A': (ch) => ch >= 0x1B100 && ch <= 0x1B12F,
    // 'Small Kana Extension': (ch) => ch >= 0x1B130 && ch <= 0x1B16F,
    // 'Nushu': (ch) => ch >= 0x1B170 && ch <= 0x1B2FF,
    // 'Duployan': (ch) => ch >= 0x1BC00 && ch <= 0x1BC9F,
    // 'Shorthand Format Controls': (ch) => ch >= 0x1BCA0 && ch <= 0x1BCAF,
    // 'Byzantine Musical Symbols': (ch) => ch >= 0x1D000 && ch <= 0x1D0FF,
    // 'Musical Symbols': (ch) => ch >= 0x1D100 && ch <= 0x1D1FF,
    // 'Ancient Greek Musical Notation': (ch) => ch >= 0x1D200 && ch <= 0x1D24F,
    // 'Mayan Numerals': (ch) => ch >= 0x1D2E0 && ch <= 0x1D2FF,
    // 'Tai Xuan Jing Symbols': (ch) => ch >= 0x1D300 && ch <= 0x1D35F,
    // 'Counting Rod Numerals': (ch) => ch >= 0x1D360 && ch <= 0x1D37F,
    // 'Mathematical Alphanumeric Symbols': (ch) => ch >= 0x1D400 && ch <= 0x1D7FF,
    // 'Sutton SignWriting': (ch) => ch >= 0x1D800 && ch <= 0x1DAAF,
    // 'Glagolitic Supplement': (ch) => ch >= 0x1E000 && ch <= 0x1E02F,
    // 'Nyiakeng Puachue Hmong': (ch) => ch >= 0x1E100 && ch <= 0x1E14F,
    // 'Wancho': (ch) => ch >= 0x1E2C0 && ch <= 0x1E2FF,
    // 'Mende Kikakui': (ch) => ch >= 0x1E800 && ch <= 0x1E8DF,
    // 'Adlam': (ch) => ch >= 0x1E900 && ch <= 0x1E95F,
    // 'Indic Siyaq Numbers': (ch) => ch >= 0x1EC70 && ch <= 0x1ECBF,
    // 'Ottoman Siyaq Numbers': (ch) => ch >= 0x1ED00 && ch <= 0x1ED4F,
    // 'Arabic Mathematical Alphabetic Symbols': (ch) => ch >= 0x1EE00 && ch <= 0x1EEFF,
    // 'Mahjong Tiles': (ch) => ch >= 0x1F000 && ch <= 0x1F02F,
    // 'Domino Tiles': (ch) => ch >= 0x1F030 && ch <= 0x1F09F,
    // 'Playing Cards': (ch) => ch >= 0x1F0A0 && ch <= 0x1F0FF,
    // 'Enclosed Alphanumeric Supplement': (ch) => ch >= 0x1F100 && ch <= 0x1F1FF,
    // 'Enclosed Ideographic Supplement': (ch) => ch >= 0x1F200 && ch <= 0x1F2FF,
    // 'Miscellaneous Symbols and Pictographs': (ch) => ch >= 0x1F300 && ch <= 0x1F5FF,
    // 'Emoticons': (ch) => ch >= 0x1F600 && ch <= 0x1F64F,
    // 'Ornamental Dingbats': (ch) => ch >= 0x1F650 && ch <= 0x1F67F,
    // 'Transport and Map Symbols': (ch) => ch >= 0x1F680 && ch <= 0x1F6FF,
    // 'Alchemical Symbols': (ch) => ch >= 0x1F700 && ch <= 0x1F77F,
    // 'Geometric Shapes Extended': (ch) => ch >= 0x1F780 && ch <= 0x1F7FF,
    // 'Supplemental Arrows-C': (ch) => ch >= 0x1F800 && ch <= 0x1F8FF,
    // 'Supplemental Symbols and Pictographs': (ch) => ch >= 0x1F900 && ch <= 0x1F9FF,
    // 'Chess Symbols': (ch) => ch >= 0x1FA00 && ch <= 0x1FA6F,
    // 'Symbols and Pictographs Extended-A': (ch) => ch >= 0x1FA70 && ch <= 0x1FAFF,
    // 'CJK Unified Ideographs Extension B': (ch) => ch >= 0x20000 && ch <= 0x2A6DF,
    // 'CJK Unified Ideographs Extension C': (ch) => ch >= 0x2A700 && ch <= 0x2B73F,
    // 'CJK Unified Ideographs Extension D': (ch) => ch >= 0x2B740 && ch <= 0x2B81F,
    // 'CJK Unified Ideographs Extension E': (ch) => ch >= 0x2B820 && ch <= 0x2CEAF,
    // 'CJK Unified Ideographs Extension F': (ch) => ch >= 0x2CEB0 && ch <= 0x2EBEF,
    // 'CJK Compatibility Ideographs Supplement': (ch) => ch >= 0x2F800 && ch <= 0x2FA1F,
    // 'Tags': (ch) => ch >= 0xE0000 && ch <= 0xE007F,
    // 'Variation Selectors Supplement': (ch) => ch >= 0xE0100 && ch <= 0xE01EF,
    // 'Supplementary Private Use Area-A': (ch) => ch >= 0xF0000 && ch <= 0xFFFFF,
    // 'Supplementary Private Use Area-B': (ch) => ch >= 0x100000 && ch <= 0x10FFFF,
  };
});
},
'com/huayun/webgis/geometry/Extent':function(){
/**
 * 
 * @module com/huayun/webgis/geometry
 * @see com.huayun.webgis.geometry.Extent
 */
define([
  "./Geometry"
], function (Geometry) {
  /**
   * 
   * @constructor
   * @alias com.huayun.webgis.geometry.Extent
   * @extends {Geometry}
   * @param {number} xmin x
   * @param {number} ymin y
   * @param {number} xmax x
   * @param {number} ymax x
   * @property {number} xmin x
   * @property {number} ymin y
   * @property {number} xmax x
   * @property {number} ymax x
   * @property {number} width 
   * @property {number} height 
   * @property {Object} center 
   */
  var Extent = function (xmin, ymin, xmax, ymax, spatialReference) {
    Geometry.call(this);
    this.spatialReference = spatialReference;
    this.xmin = xmin;
    this.ymin = ymin;
    this.xmax = xmax;
    this.ymax = ymax;
  };

  if (Geometry) Extent.__proto__ = Geometry;
  Extent.prototype = Object.create(Geometry && Geometry.prototype);
  Extent.prototype.constructor = Extent;

  var prototypeAccessors = {
    minx: {configurable: true},
    miny: {configurable: true},
    maxx: {configurable: true},
    maxy: {configurable: true}, // 
    width: {configurable: false},
    height: {configurable: false},
    center: {configurable: false}
  };

  prototypeAccessors.minx.get = function () {
    return this.xmin;
  };

  prototypeAccessors.minx.set = function (min) {
    this.xmin = min;
  };

  prototypeAccessors.miny.get = function () {
    return this.ymin;
  };

  prototypeAccessors.miny.set = function (min) {
    this.ymin = min;
  };

  prototypeAccessors.maxx.get = function () {
    return this.xmax;
  };

  prototypeAccessors.maxx.set = function (max) {
    this.xmax = max;
  };

  prototypeAccessors.maxy.get = function () {
    return this.ymax;
  };

  prototypeAccessors.maxy.set = function (max) {
    this.ymax = max;
  };

  prototypeAccessors.width.get = function () {
    return Math.abs(this.xmax - this.xmin);
  };

  prototypeAccessors.height.get = function () {
    return Math.abs(this.ymax - this.ymin);
  };

  prototypeAccessors.center.get = function () {
    // return new Point(, );
    return {
      x: .5 * (this.xmin + this.xmax),
      y: .5 * (this.ymin + this.ymax),
      z: 0,
      type: "point"
    }
  };

  Extent.prototype = {
    getCenter: function () {
      // return new Point(.5 * (this.xmin + this.xmax), .5 * (this.ymin + this.ymax));
      return {
        x: .5 * (this.xmin + this.xmax),
        y: .5 * (this.ymin + this.ymax),
        z: 0,
        type: "point"
      }
    },

    getWidth: function () {
      return Math.abs(this.xmax - this.xmin);
    },

    getHeight: function () {
      return Math.abs(this.ymax - this.ymin);
    },

    /**
     * 
     * @param a 
     * @return {boolean} 
     */
    equals: function (a) {
      if (!a) return !1;
      return this.xmin === a.xmin && this.ymin === a.ymin && this.xmax === a.xmax && this.ymax === a.ymax;
    }
  };

  Object.defineProperties(Extent.prototype, prototypeAccessors);
  return Extent;
});

},
'com/huayun/webgis/utils/classifyRings':function(){
define([
    "./utils",
    "./quickselect"
], function (utils, quickselect) {
    function compareAreas(a, b) {
        return b.area - a.area;
    }

    function classifyRings(rings, maxRings) {
        var len = rings.length;
        if (len <= 1) {
            return [rings];
        }

        var polygons = [];
        var polygon, ccw;
        for (var i = 0; i < len; i++) {
            var area = utils.calculateSignedArea(rings[i]);
            if (area === 0) {
                continue;
            }
            rings[i].area = Math.abs(area);
            if (ccw === undefined) {
                ccw = area < 0;
            }
            if (ccw === area < 0) {
                if (polygon) {
                    polygons.push(polygon);
                }
                polygon = [rings[i]];
            } else {
                polygon.push(rings[i]);
            }
        }
        if (polygon) {
            polygons.push(polygon);
        }
        if (maxRings > 1) {
            for (var j = 0; j < polygons.length; j++) {
                if (polygons[j].length <= maxRings) {
                    continue;
                }
                quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);
                polygons[j] = polygons[j].slice(0, maxRings);
            }
        }
        return polygons;
    }

    return classifyRings;
})
},
'com/huayun/webgis/layers/support/expression/FormattedSection':function(){
define([], function () {

    var FormattedSection = function FormattedSection(text, scale, fontStack) {
        this.text = text;
        this.scale = scale;
        this.fontStack = fontStack;
    };

    return FormattedSection;
})
},
'com/huayun/webgis/Feature':function(){
/**
 * 
 * @module   com/huayun/webgis
 * @see   com.huayun.webgis.Feature
 */
define([
    "./utils/Color"
], function (Color) {
    /**
     * , geometryattributes
     * @constructor
     * @alias com.huayun.webgis.Feature
     * @param {Object} params 
     * @param {Object|Array} params.attributes 
     * @param {Geometry} params.geometry 
     * @property {Object|Array} attributes 
     * @property {Geometry} geometry 
     */
    function Feature(params) {
        this.attributes = params.attributes === undefined || params.attributes === null ? {} : params.attributes;
        this.type = params.type;
        this.geometry = params.geometry;

        if (this.attributes.hasOwnProperty("color")) {
            var color = this.attributes.color;
            if (color instanceof Array) {
                this.attributes.color = color;
            } else {
                color = Color.parse(color);
                this.attributes.color = [color.r, color.g, color.b, color.a];
            }
        }
    }
    return Feature;
});

},
'com/huayun/webgis/layers/support/expression/Formatted':function(){
define([
    "./FormattedSection"
], function (FormattedSection) {

    var Formatted = function Formatted(sections) {
        this.sections = sections;
    };

    Formatted.fromString = function (unformatted) {
        return new Formatted([new FormattedSection(unformatted, null, null)]);
    };

    Formatted.prototype.toString = function () {
        return this.sections.map(function (section) {
            return section.text;
        }).join('');
    };

    Formatted.prototype.serialize = function () {
        var serialized = ["format"];
        for (var i = 0, list = this.sections; i < list.length; i += 1) {
            var section = list[i];
            serialized.push(section.text);
            var options = {};
            if (section.fontStack) {
                options["text-font"] = ["literal", section.fontStack.split(',')];
            }
            if (section.scale) {
                options["font-scale"] = section.scale;
            }
            serialized.push(options);
        }
        return serialized;
    };

    return Formatted;
});
},
'com/huayun/webgis/utils/quickselect':function(){
define([], function () {
    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

    function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
    }

    function swap$1(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                quickselectStep(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap$1(arr, left, k);
            if (compare(arr[right], t) > 0) {
                swap$1(arr, left, right);
            }

            while (i < j) {
                swap$1(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) {
                    i++;
                }
                while (compare(arr[j], t) > 0) {
                    j--;
                }
            }

            if (compare(arr[left], t) === 0) {
                swap$1(arr, left, j);
            } else {
                j++;
                swap$1(arr, j, right);
            }

            if (j <= k) {
                left = j + 1;
            }
            if (k <= j) {
                right = j - 1;
            }
        }
    }

    return quickselect;
})
},
'com/huayun/webgis/gl/programCache':function(){
define([
    "exports",
    "./ProgramSimplify",
    "./VertexFragShader"
], function (exports, ProgramSimplify, VertexFragShader) {
    var programCache = {};

    exports.useProgramSimplify = function (context, name, programConfiguration) {
        var key = name + "-" + context.id;
        if (!programCache[key]) {
            programCache[key] = new ProgramSimplify(context, VertexFragShader[name], programConfiguration, VertexFragShader.programUniforms[name]);
        }
        return programCache[key];
    };
});

},
'com/huayun/webgis/gl/dataTransfer':function(){
define([
    "require",
    "exports",
    "../layers/support/OverscaledTileID",
    "../layers/support/CanonicalTileID",
    "../layers/support/expression/Formatted",
    "../utils/Color",
    "../utils/image",
    "./GridIndex",
    "../data/ArrayType",
    "./SegmentVector",
    "../geometry/Anchor",
    "./ImagePosition",
    "./ImageAtlas"
], function (e, f, OverscaledTileID, CanonicalTileID, Formatted, Color, image,
             GridIndex, ArrayType, SegmentVector, Anchor, ImagePosition, ImageAtlas) {
    var registry = {};

    function register(name, klass, options) {
        if (options === void 0) options = {};

        (Object.defineProperty)(klass, '_classRegistryKey', {
            value: name,
            writeable: false
        });
        registry[name] = {
            klass: klass,
            omit: options.omit || [],
            shallow: options.shallow || []
        };
    }

    f.register = register;

    register('Object', Object);

    register('StructArrayLayout2i4', ArrayType.StructArrayLayout2i4);
    register('StructArrayLayout3ui6', ArrayType.StructArrayLayout3ui6);
    register('StructArrayLayout2ui4', ArrayType.StructArrayLayout2ui4);
    register('StructArrayLayout2i4ub8', ArrayType.StructArrayLayout2i4ub8);
    register('StructArrayLayout4i4ui16', ArrayType.StructArrayLayout4i4ui16);
    register('StructArrayLayout3f12', ArrayType.StructArrayLayout3f12);
    register('StructArrayLayout1ul4', ArrayType.StructArrayLayout1ul4);
    register('StructArrayLayout2i2i2i12', ArrayType.StructArrayLayout2i2i2i12);
    register('StructArrayLayout2ub2f12', ArrayType.StructArrayLayout2ub2f12);
    register('GlyphOffsetArray', ArrayType.GlyphOffsetArray);
    register('SymbolInstanceArray', ArrayType.SymbolInstanceArray);
    register('SymbolLineVertexArray', ArrayType.SymbolLineVertexArray);
    register('StructArrayLayout2f8', ArrayType.StructArrayLayout2f8);
    register('PlacedSymbolArray', ArrayType.PlacedSymbolArray);
    register('StructArrayLayout2i4i12', ArrayType.StructArrayLayout2i4i12);
    register('StructArrayLayout1f4', ArrayType.StructArrayLayout1f4);
    register('StructArrayLayout3i6', ArrayType.StructArrayLayout3i6);

    register('SegmentVector', SegmentVector);
    register("CollisionBoxArray", ArrayType.CollisionBoxArray);
    register('Grid', GridIndex);
    register('FeatureIndexArray', ArrayType.FeatureIndexArray);

    register('CanonicalTileID', CanonicalTileID);
    register('OverscaledTileID', OverscaledTileID, {omit: ['posMatrix']});


    register('Anchor', Anchor);

    register('ImagePosition', ImagePosition);
    register('ImageAtlas', ImageAtlas);

    register('Color', Color);


    register('AlphaImage', image.AlphaImage);
    register('RGBAImage', image.RGBAImage);
    register('Error', Error);


    function serialize(input, transferables) {
        if (input === null ||
            input === undefined ||
            typeof input === 'boolean' ||
            typeof input === 'number' ||
            typeof input === 'string' ||
            input instanceof Boolean ||
            input instanceof Number ||
            input instanceof String ||
            input instanceof Date ||
            input instanceof RegExp) {
            return input;
        }

        if (input instanceof ArrayBuffer) {
            if (transferables) {
                transferables.push(input);
            }
            return input;
        }

        if (ArrayBuffer.isView(input)) {
            var view = (input);
            if (transferables) {
                transferables.push(view.buffer);
            }
            return view;
        }

        if (input instanceof ImageData) {
            if (transferables) {
                transferables.push(input.data.buffer);
            }
            return input;
        }

        if (Array.isArray(input)) {
            var serialized = [];
            for (var i = 0, list = input; i < list.length; i += 1) {
                var item = list[i];

                serialized.push(serialize(item, transferables));
            }
            return serialized;
        }

        if (typeof input === 'object') {
            var klass = (input.constructor);
            var name = klass._classRegistryKey;
            if (!name) {
                // debugger;
                console.log(name);
                throw new Error("can't serialize object of unregistered class");
            }

            var properties = klass.serialize ?
                // (Temporary workaround) allow a class to provide static
                // `serialize()` and `deserialize()` methods to bypass the generic
                // approach.
                // This temporary workaround lets us use the generic serialization
                // approach for objects whose members include instances of dynamic
                // StructArray types. Once we refactor StructArray to be static,
                // we can remove this complexity.
                (klass.serialize(input, transferables)) : {};

            if (!klass.serialize) {
                for (var key in input) {
                    // any cast due to https://github.com/facebook/flow/issues/5393
                    if (!(input).hasOwnProperty(key)) {
                        continue;
                    }
                    if (registry[name].omit.indexOf(key) >= 0) {
                        continue;
                    }
                    var property = (input)[key];
                    properties[key] = registry[name].shallow.indexOf(key) >= 0 ?
                        property :
                        serialize(property, transferables);

                    // console.timeEnd("parse");
                }
                if (input instanceof Error) {
                    properties.message = input.message;
                }
            } else {
                // make sure statically serialized object survives transfer of $name property
            }

            if (properties.$name) {
                throw new Error('$name property is reserved for worker serialization logic.');
            }
            if (name !== 'Object') {
                properties.$name = name;
            }
            return properties;
        }

        throw new Error(("can't serialize object of type " + (typeof input)));
    }

    function deserialize(input) {
        if (input === null ||
            input === undefined ||
            typeof input === 'boolean' ||
            typeof input === 'number' ||
            typeof input === 'string' ||
            input instanceof Boolean ||
            input instanceof Number ||
            input instanceof String ||
            input instanceof Date ||
            input instanceof RegExp ||
            input instanceof ArrayBuffer ||
            ArrayBuffer.isView(input) ||
            input instanceof ImageData) {
            return input;
        }

        if (Array.isArray(input)) {
            return input.map(deserialize);
        }

        if (typeof input === 'object') {
            var name = (input).$name || 'Object';

            var ref = registry[name];
            if (ref === undefined) ;
            var klass = ref.klass;
            if (!klass) {
                throw new Error(("can't deserialize unregistered class " + name));
            }

            if (klass.deserialize) {
                return (klass.deserialize)(input);
            }

            var result = Object.create(klass.prototype);

            for (var i = 0, list = Object.keys(input); i < list.length; i += 1) {
                var key = list[i];

                if (key === '$name') {
                    continue;
                }
                var value = (input)[key];
                result[key] = registry[name].shallow.indexOf(key) >= 0 ? value : deserialize(value);
            }

            return result;
        }
        throw new Error(("can't deserialize object of type " + (typeof input)));
    }

    f.serialize = serialize;
    f.deserialize = deserialize;
});
},
'com/huayun/webgis/data/queryIntersects':function(){
define(["exports", "../utils/utils", "custom/gl-matrix-min"], function (exports, utils, glMatrix) {

    function polygonContainsPoint(ring, p) {
        var c = false;
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var p1 = ring[i];
            var p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
        return c;
    }

    function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
        return utils.isCounterClockwise(a0, b0, b1) !== utils.isCounterClockwise(a1, b0, b1) &&
            utils.isCounterClockwise(a0, a1, b0) !== utils.isCounterClockwise(a0, a1, b1);
    }

    function lineIntersectsLine(lineA, lineB) {
        if (lineA.length === 0 || lineB.length === 0) {
            return false;
        }
        for (var i = 0; i < lineA.length - 1; i++) {
            var a0 = lineA[i];
            var a1 = lineA[i + 1];
            for (var j = 0; j < lineB.length - 1; j++) {
                var b0 = lineB[j];
                var b1 = lineB[j + 1];
                if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) {
                    return true;
                }
            }
        }
        return false;
    }

    function distToSegmentSquared(p, v, w) {
        var l2 = v.distSqr(w);
        if (l2 === 0) {
            return p.distSqr(v);
        }
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) {
            return p.distSqr(v);
        }
        if (t > 1) {
            return p.distSqr(w);
        }
        return p.distSqr(w.sub(v)._mult(t)._add(v));
    }

    function pointIntersectsBufferedLine(p, line, radius) {
        var radiusSquared = radius * radius;
        if (line.length === 1) {
            return p.distSqr(line[0]) < radiusSquared;
        }
        for (var i = 1; i < line.length; i++) {
            var v = line[i - 1], w = line[i];
            if (distToSegmentSquared(p, v, w) < radiusSquared) {
                return true;
            }
        }
        return false;
    }

    function lineIntersectsBufferedLine(lineA, lineB, radius) {
        if (lineA.length > 1) {
            if (lineIntersectsLine(lineA, lineB)) {
                return true;
            }
            for (var j = 0; j < lineB.length; j++) {
                if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) {
                    return true;
                }
            }
        }
        for (var k = 0; k < lineA.length; k++) {
            if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) {
                return true;
            }
        }
        return false;
    }

    function polygonIntersectsBufferedMultiLine(polygon, multiLine, symbol, resolution) {
        multiLine = multiLine.path;
        var w = symbol.uniforms.u_width || 1;
        var radius = (w + 4) * resolution / 2;
        for (var i = 0; i < multiLine.length; i++) {
            var line = multiLine[i];

            if (polygon.length >= 3) {
                for (var k = 0; k < line.length; k++) {
                    if (polygonContainsPoint(polygon, line[k])) {
                        return true;
                    }
                }
            }

            if (lineIntersectsBufferedLine(polygon, line, radius)) {
                return true;
            }
        }
        return false;
    }

    function multiPolygonContainsPoint(rings, p) {
        var c = false,
            ring, p1, p2;

        for (var k = 0; k < rings.length; k++) {
            ring = rings[k];
            for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                p1 = ring[i];
                p2 = ring[j];
                if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                    c = !c;
                }
            }
        }
        return c;
    }

    function polygonIntersectsMultiPolygon(polygon, multiPolygon) {
        multiPolygon = multiPolygon.path;
        if (polygon.length === 1) {
            return multiPolygonContainsPoint(multiPolygon, polygon[0]);
        }
        for (var m = 0; m < multiPolygon.length; m++) {
            var ring = multiPolygon[m];
            for (var n = 0; n < ring.length; n++) {
                if (polygonContainsPoint(polygon, ring[n])) {
                    return true;
                }
            }
        }
        for (var i = 0; i < polygon.length; i++) {
            if (multiPolygonContainsPoint(multiPolygon, polygon[i])) {
                return true;
            }
        }
        for (var k = 0; k < multiPolygon.length; k++) {
            if (lineIntersectsLine(polygon, multiPolygon[k])) {
                return true;
            }
        }
        return false;
    }

    function getPixelPosMatrix(transform, matrix) {
        var t = glMatrix.mat4.identity([]);
        glMatrix.mat4.translate(t, t, [1, 1, 0]);
        glMatrix.mat4.scale(t, t, [transform.width * 0.5, transform.height * 0.5, 1]);
        return glMatrix.mat4.multiply(t, t, matrix);
    }

    function polygonIntersectsBufferedPoint(polygon, point, radius) {
        if (polygonContainsPoint(polygon, point)) { return true; }
        if (pointIntersectsBufferedLine(point, polygon, radius)) { return true; }
        return false;
    }

    function polygonIntersectsCircle(queryGeometry, geometry, symbol, resolution, radius, viewpoint) {
        geometry = geometry.center;
        var pixelPosMatrix = getPixelPosMatrix(viewpoint, symbol.uniforms.u_matrix);
        var stroke = symbol.strokeWidth;
        var alignWithMap = symbol.pitchWithMap;
        var transformedPolygon = alignWithMap ? queryGeometry : utils.projectQueryGeometry(queryGeometry, pixelPosMatrix);
        // var transformedSize = alignWithMap ? size * resolution : size;
        var transformedSize = radius + stroke * resolution;
        var point = geometry;
        var transformedPoint = alignWithMap ? point :  utils.projectPoint(point, pixelPosMatrix);

        var adjustedSize = transformedSize;
        var projectedCenter = glMatrix.vec4.transformMat4([], [point.x, point.y, 0, 1], pixelPosMatrix);
        if (!symbol.scaleWithPitch && alignWithMap) {
            adjustedSize *= projectedCenter[3] / viewpoint.cameraToCenterDistance;
        } else if (symbol.scaleWithPitch && !alignWithMap) {
            adjustedSize *= viewpoint.cameraToCenterDistance / projectedCenter[3];
        }
        if (polygonIntersectsBufferedPoint(transformedPolygon, transformedPoint, adjustedSize)) { return true; }
    }

    function polygonIntersectsPoint(queryGeometry, geometry, symbol, resolution, radius, viewpoint) {
        var pixelPosMatrix = getPixelPosMatrix(viewpoint, symbol.uniforms.u_matrix);
        var stroke = symbol.strokeWidth || 0;
        radius = symbol.uniforms.radius;
        var size  = radius + stroke;
        var alignWithMap = symbol.pitchWithMap;
        var transformedPolygon = alignWithMap ? queryGeometry : utils.projectQueryGeometry(queryGeometry, pixelPosMatrix);
        // var transformedSize = alignWithMap ? size * resolution : size;
        var transformedSize = (radius + stroke);// * resolution;
        var point = geometry;
        var transformedPoint = alignWithMap ? point : utils.projectPoint(point, pixelPosMatrix);

        var adjustedSize = transformedSize;
        var projectedCenter = glMatrix.vec4.transformMat4([], [point.x, point.y, 0, 1], pixelPosMatrix);
        if (!symbol.scaleWithPitch && alignWithMap) {
            adjustedSize *= projectedCenter[3] / viewpoint.cameraToCenterDistance;
        } else if (symbol.scaleWithPitch && !alignWithMap) {
            adjustedSize *= viewpoint.cameraToCenterDistance / projectedCenter[3];
        }
        if (polygonIntersectsBufferedPoint(transformedPolygon, transformedPoint, adjustedSize)) { return true; }
    }

    exports.line = polygonIntersectsBufferedMultiLine;
    exports.polygon = polygonIntersectsMultiPolygon;
    exports.imageFill = polygonIntersectsMultiPolygon;

    exports.circle = polygonIntersectsCircle;
    exports.point = polygonIntersectsPoint;

    function polygonIntersectsImage(queryGeometry, geometry, symbol, resolution, radius, viewpoint) {
        var pixelPosMatrix = getPixelPosMatrix(viewpoint, symbol.uniforms.u_matrix);
        var transformedPolygon = utils.projectQueryGeometry(queryGeometry, pixelPosMatrix);
        // var transformedSize = alignWithMap ? size * resolution : size;
        var transformedPoint = utils.projectPoint(geometry, pixelPosMatrix);

        var hw = symbol.width/2,
          hh = symbol.height/2;
        var polygon = {
          path: [
            [
              {
                x: transformedPoint.x - hw,
                y: transformedPoint.y - hh
              },
              {
                x: transformedPoint.x + hw,
                y: transformedPoint.y - hh
              },
              {
                x: transformedPoint.x + hw,
                y: transformedPoint.y + hh
              },
              {
                x: transformedPoint.x - hw,
                y: transformedPoint.y + hh
              }
            ]
          ]
        };
        if (polygonIntersectsMultiPolygon(transformedPolygon, polygon)) { return true; }
    }
    exports.image = polygonIntersectsImage;
    exports.canvas = polygonIntersectsImage;

    exports.text = function () {
        return false;
    }
});
},
'com/huayun/webgis/utils/utils':function(){
define([
    "exports",
    "custom/gl-matrix-min",
    "./Constant",
    "./Color",
    "../layers/support/expression/Formatted",
    "../data/ArrayType",
    "../layers/support/UnitBezier",
    "../geometry/Point"
], function (exports, glMatrix, Constant, Color, Formatted, ArrayType, UnitBezier, pointGeometry) {

    var EXTENT = Constant.layout.EXTENT;

    /**
     * 
     * @private
     * @ignore
     * @type {any}
     */
    exports.now = self.performance && self.performance.now ? self.performance.now.bind(self.performance) : Date.now.bind(Date);

    /**
     * 
     * @private
     * @ignore
     * @param dest
     * @return {*}
     */
    exports.extend = Object.assign ? Object.assign : function (dest) {
        var sources = [], len = arguments.length - 1;
        while (len-- > 0) sources[len] = arguments[len + 1];
        for (var i = 0, list = sources; i < list.length; i += 1) {
            var src = list[i];
            for (var k in src) {
                dest[k] = src[k];
            }
        }
        return dest;
    };

    /**
     * 
     * @private
     * @ignore
     * @param value
     * @return {boolean}
     */
    exports.isFunction = function (value) {
        return typeof value === 'object' && value !== null && !Array.isArray(value);
    };

    /**
     * 
     * @ignore
     * @private
     * @param input
     * @return {*}
     */
    function clone(input) {
        if (Array.isArray(input)) {
            return input.map(clone);
        } else if (typeof input === 'object' && input) {
            return ((mapObject(input, clone)));
        } else {
            return input;
        }
    }

    exports.clone = clone;

    /**
     * @ignore
     * @private
     * , callback
     * @param array 
     * @param fn , (data, callback)
     * @param callback 
     * @return {*}
     */
    exports.asyncAll = function (array, fn, callback) {
        if (!array.length) {
            return callback(null, []);
        }
        var remaining = array.length;
        var results = new Array(array.length);
        var error = null;
        array.forEach(function (item, i) {
            fn(item, function (err, result) {
                if (err) {
                    error = err;
                }
                results[i] = result;
                if (--remaining === 0) {
                    callback(error, results);
                }
            });
        });
    };

    /**
     * 
     * @private
     * @ignore
     * @param {Object} obj 
     * @return {[]}
     */
    exports.values = function (obj) {
        var result = [];
        for (var k in obj) {
            result.push(obj[k]);
        }
        return result;
    }

    /**
     * 
     * @private
     * @ignore
     * @param a
     * @param b
     * @param c
     * @return {boolean}
     */
    exports.isCounterClockwise = function isCounterClockwise(a, b, c) {
        return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
    };

    /**
     * 
     * @private
     * @ignore
     * @param a
     * @param b
     * @param t
     * @return {number}
     */
    exports.number = function (a, b, t) {
        return (a * (1 - t)) + (b * t);
    };

    /**
     * 
     * @private
     * @ignore
     * @param val
     * @return {string|"undefined"|"object"|"boolean"|"number"|"string"|"function"|"symbol"|"bigint"}
     */
    exports.getType = function (val) {
        if (val instanceof Number) {
            return 'number';
        } else if (val instanceof String) {
            return 'string';
        } else if (val instanceof Boolean) {
            return 'boolean';
        } else if (Array.isArray(val)) {
            return 'array';
        } else if (val === null) {
            return 'null';
        } else {
            return typeof val;
        }
    };

    /**
     * undefined
     * @private
     * @ignore
     * @return {*}
     */
    exports.coalesce = function () {
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] !== undefined) {
                return arguments[i];
            }
        }
    };

    /**
     * @private
     * @param t
     * @return {number}
     */
    function easeCubicInOut(t) {
        if (t <= 0) {
            return 0;
        }
        if (t >= 1) {
            return 1;
        }
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    }

    exports.easeCubicInOut = easeCubicInOut;

    /**
     * 
     * @private
     * @ignore
     * @param string
     * @param suffix
     * @return {boolean}
     */
    exports.endsWith = function (string, suffix) {
        return string.indexOf(suffix, string.length - suffix.length) !== -1;
    };

    /**
     * rgba
     * @private
     * @ignore
     * @param r
     * @param g
     * @param b
     * @param a
     * @return {*}
     */
    function validateRGBA(r, g, b, a) {
        if (!(
            typeof r === 'number' && r >= 0 && r <= 255 &&
            typeof g === 'number' && g >= 0 && g <= 255 &&
            typeof b === 'number' && b >= 0 && b <= 255
        )) {
            var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
            return ("Invalid rgba value [" + (value.join(', ')) + "]: 'r', 'g', and 'b' must be between 0 and 255.");
        }
        if (!(typeof a === 'undefined' || (typeof a === 'number' && a >= 0 && a <= 1))) {
            return ("Invalid rgba value [" + ([r, g, b, a].join(', ')) + "]: 'a' must be between 0 and 1.");
        }
        return null;
    }

    exports.validateRGBA = validateRGBA;

    function bezier(p1x, p1y, p2x, p2y) {
        var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
        return function (t) {
            return bezier.solve(t);
        };
    }
    exports.bezier = bezier;

    //---------------------------------------------

    exports.topDownFeatureComparator = function (a, b) {
        return b - a;
    }

    /**
     * 
     * @param feature 
     * @return {[]}
     */
    exports.loadGeometry = function (feature) {
        var scale = EXTENT / feature.extent;
        var geometry = feature.loadGeometry();
        for (var r = 0; r < geometry.length; r++) {
            var ring = geometry[r];
            for (var p = 0; p < ring.length; p++) {
                var point = ring[p];
                // 
                point.x = Math.round(point.x * scale);
                point.y = Math.round(point.y * scale);
            }
        }
        return geometry;
    };

    /**
     * 
     * @param {Array} a 
     * @param {Array} b 
     * @return {Boolean} 
     */
    exports.arraysIntersect = function (a, b) {
        for (var i = 0; i < a.length; i++) {
            if (b.indexOf(a[i]) >= 0) return true;
        }
        return false;
    }

    /**
     * 
     * @private
     * @param input 
     * @param iterator 
     * @param context
     * @return {{}}
     */
    function mapObject(input, iterator, context) {
        var output = {};
        for (var key in input) {
            output[key] = iterator.call(context || this, input[key], key, input);
        }
        return output;
    }

    exports.mapObject = mapObject;


    /**
     * @private
     * @param ring
     * @return {number}
     */

    exports.calculateSignedArea = function (ring) {
        var sum = 0;
        for (var i = 0, len = ring.length, j = len - 1, p1 = (void 0), p2 = (void 0); i < len; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }
        return sum;
    }

    exports.keysDifference = function (obj, other) {
        var difference = [];
        for (var i in obj) {
            if (!(i in other)) {
                difference.push(i);
            }
        }
        return difference;
    }


    function projectQueryGeometry(queryGeometry, pixelPosMatrix) {
        return queryGeometry.map(function (p) {
            return projectPoint(p, pixelPosMatrix);
        });
    }

    function projectPoint(p, pixelPosMatrix) {
        var point = glMatrix.vec4.transformMat4([], [p.x, p.y, 0, 1], pixelPosMatrix);
        return new pointGeometry(point[0] / point[3], point[1] / point[3]);
    }

    exports.projectPoint = projectPoint;

    exports.projectQueryGeometry = projectQueryGeometry;



    exports.bindAll = function (fns, context) {
        fns.forEach(function (fn) {
            if (!context[fn]) {
                return;
            }
            context[fn] = context[fn].bind(context);
        });
    };

    exports.getPixelPosMatrix = function (transform, tileID) {
        var t = glMatrix.mat4.identity([]);
        glMatrix.mat4.translate(t, t, [1, 1, 0]);
        glMatrix.mat4.scale(t, t, [transform.width * 0.5, transform.height * 0.5, 1]);
        return glMatrix.mat4.multiply(t, t, transform.calculatePosMatrix(tileID.toUnwrapped()));
    };

    function pointIntersectsBufferedLine(p, line, radius) {
        var radiusSquared = radius * radius;
        if (line.length === 1) {
            return p.distSqr(line[0]) < radiusSquared;
        }
        for (var i = 1; i < line.length; i++) {
            var v = line[i - 1], w = line[i];
            if (distToSegmentSquared(p, v, w) < radiusSquared) {
                return true;
            }
        }
        return false;
    }

    function distToSegmentSquared(p, v, w) {
        var l2 = v.distSqr(w);
        if (l2 === 0) {
            return p.distSqr(v);
        }
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) {
            return p.distSqr(v);
        }
        if (t > 1) {
            return p.distSqr(w);
        }
        return p.distSqr(w.sub(v)._mult(t)._add(v));
    }

    function polygonContainsPoint(ring, p) {
        var c = false;
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var p1 = ring[i];
            var p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
        return c;
    }

    function polygonIntersectsBufferedPoint(polygon, point, radius) {
        if (polygonContainsPoint(polygon, point)) {
            return true;
        }
        if (pointIntersectsBufferedLine(point, polygon, radius)) {
            return true;
        }
        return false;
    }

    exports.polygonIntersectsBufferedPoint = polygonIntersectsBufferedPoint;
    exports.polygonContainsPoint = polygonContainsPoint;


    function sortTilesIn(a, b) {
        var idA = a.tileID;
        var idB = b.tileID;
        return (idA.overscaledZ - idB.overscaledZ) || (idA.canonical.y - idB.canonical.y) || (idA.wrap - idB.wrap) || (idA.canonical.x - idB.canonical.x);
    }


    exports.sortTilesIn = sortTilesIn;

    exports.ease = bezier(0.25, 0.1, 0.25, 1);


    exports.isEntirelyOutside = function (ring) {
        return ring.every(function (p) {
                return p.x < 0;
            }) ||
            ring.every(function (p) {
                return p.x > EXTENT;
            }) ||
            ring.every(function (p) {
                return p.y < 0;
            }) ||
            ring.every(function (p) {
                return p.y > EXTENT;
            });
    };

    exports.isBoundaryEdge = function (p1, p2) {
        return (p1.x === p2.x && (p1.x < 0 || p1.x > EXTENT)) ||
            (p1.y === p2.y && (p1.y < 0 || p1.y > EXTENT));
    };

    exports.pick = function (src, properties) {
        var result = {};
        for (var i = 0; i < properties.length; i++) {
            var k = properties[i];
            if (k in src) {
                result[k] = src[k];
            }
        }
        return result;
    };

    exports.align = function (offset, size) {
        return Math.ceil(offset / size) * size;
    };

    function sort(ids, positions, left, right) {
        if (left >= right) {
            return;
        }

        var pivot = ids[(left + right) >> 1];
        var i = left - 1;
        var j = right + 1;

        while (true) {
            do {
                i++;
            } while (ids[i] < pivot);
            do {
                j--;
            } while (ids[j] > pivot);
            if (i >= j) {
                break;
            }
            swap(ids, i, j);
            swap(positions, 3 * i, 3 * j);
            swap(positions, 3 * i + 1, 3 * j + 1);
            swap(positions, 3 * i + 2, 3 * j + 2);
        }

        sort(ids, positions, left, j);
        sort(ids, positions, j + 1, right);
    }

    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    exports.sort = sort;
    exports.swap = swap;

    function deepEqual(a, b) {
        if (Array.isArray(a)) {
            if (!Array.isArray(b) || a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        if (typeof a === 'object' && a !== null && b !== null) {
            if (!(typeof b === 'object')) {
                return false;
            }
            var keys = Object.keys(a);
            if (keys.length !== Object.keys(b).length) {
                return false;
            }
            for (var key in a) {
                if (!deepEqual(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        return a === b;
    }

    exports.deepEqual = deepEqual;


    function supportsPropertyExpression(spec) {
        return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
    }

    exports.supportsPropertyExpression = supportsPropertyExpression;

    function supportsZoomExpression(spec) {
        return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
    }

    exports.supportsZoomExpression = supportsZoomExpression;

    function supportsInterpolation(spec) {
        return !!spec.expression && spec.expression.interpolated;
    }

    exports.supportsInterpolation = supportsInterpolation;


    function findStopLessThanOrEqualTo(stops, input) {
        var lastIndex = stops.length - 1;
        var lowerIndex = 0;
        var upperIndex = lastIndex;
        var currentIndex = 0;
        var currentValue, nextValue;

        while (lowerIndex <= upperIndex) {
            currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
            currentValue = stops[currentIndex];
            nextValue = stops[currentIndex + 1];

            if (currentValue <= input) {
                if (currentIndex === lastIndex || input < nextValue) { // Search complete
                    return currentIndex;
                }

                lowerIndex = currentIndex + 1;
            } else if (currentValue > input) {
                upperIndex = currentIndex - 1;
            } else {
                throw new Error('Input is not a number.');
            }
        }

        return 0;
    }

    exports.findStopLessThanOrEqualTo = findStopLessThanOrEqualTo;


    exports.pixelsToTileUnits = function (tile, pixelValue, z) {
        return pixelValue * (Constant.layout.EXTENT / (tile.tileSize * Math.pow(2, z - tile.tileID.overscaledZ)));
    };

    function paintAttributeNames(property, type) {
        var attributeNameExceptions = {
            'text-opacity': ['opacity'],
            'icon-opacity': ['opacity'],
            'text-color': ['fill_color'],
            'icon-color': ['fill_color'],
            'text-halo-color': ['halo_color'],
            'icon-halo-color': ['halo_color'],
            'text-halo-blur': ['halo_blur'],
            'icon-halo-blur': ['halo_blur'],
            'text-halo-width': ['halo_width'],
            'icon-halo-width': ['halo_width'],
            'line-gap-width': ['gapwidth'],
            'line-pattern': ['pattern_to', 'pattern_from'],
            'fill-pattern': ['pattern_to', 'pattern_from'],
            'fill-extrusion-pattern': ['pattern_to', 'pattern_from']
        };
        return attributeNameExceptions[property] || [property.replace((type + "-"), '').replace(/-/g, '_')];
    }

    exports.paintAttributeNames = paintAttributeNames;

    function getLayoutException(property) {
        var propertyExceptions = {
            'line-pattern': {
                'source': ArrayType.StructArrayLayout8ui16,
                'composite': ArrayType.StructArrayLayout8ui16
            },
            'fill-pattern': {
                'source': ArrayType.StructArrayLayout8ui16,
                'composite': ArrayType.StructArrayLayout8ui16
            },
            'fill-extrusion-pattern': {
                'source': ArrayType.StructArrayLayout8ui16,
                'composite': ArrayType.StructArrayLayout8ui16
            }
        };

        return propertyExceptions[property];
    }

    exports.getLayoutException = getLayoutException;

    function layoutType(property, type, binderType) {
        var defaultLayouts = {
            'color': {
                'source': ArrayType.StructArrayLayout2f8,
                'composite': ArrayType.StructArrayLayout4f16
            },
            'number': {
                'source': ArrayType.StructArrayLayout1f4,
                'composite': ArrayType.StructArrayLayout2f8
            }
        };

        var layoutException = getLayoutException(property);
        return layoutException && layoutException[binderType] ||
            defaultLayouts[type][binderType];
    }

    exports.layoutType = layoutType;

    function clamp(n, min, max) {
        return Math.min(max, Math.max(min, n));
    }

    exports.clamp = clamp;

    function packUint8ToFloat(a, b) {
        // coerce a and b to 8-bit ints
        a = clamp(Math.floor(a), 0, 255);
        b = clamp(Math.floor(b), 0, 255);
        return 256 * a + b;
    }

    exports.packUint8ToFloat = packUint8ToFloat;

    function packColor(color) {
        return [
            packUint8ToFloat(255 * color.r, 255 * color.g),
            packUint8ToFloat(255 * color.b, 255 * color.a)
        ];
    }

    exports.packColor = packColor;


    function charHasUprightVerticalOrientation(ch) {
        if (ch === 0x02EA || ch === 0x02EB) {
            return true;
        }
        if (ch < 0x1100) {
            return false;
        }

        if (Constant.unicodeBlockLookup['Bopomofo Extended'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Bopomofo'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['CJK Compatibility Forms'](ch)) {
            if (!((ch >= 0xFE49 /* dashed overline */ && ch <= 0xFE4F) /* wavy low line */)) {
                return true;
            }
        }
        if (Constant.unicodeBlockLookup['CJK Compatibility Ideographs'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['CJK Compatibility'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['CJK Radicals Supplement'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['CJK Strokes'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['CJK Symbols and Punctuation'](ch)) {
            if (!((ch >= 0x3008 /* left angle bracket */ && ch <= 0x3011) /* right black lenticular bracket */) &&
                !((ch >= 0x3014 /* left tortoise shell bracket */ && ch <= 0x301F) /* low double prime quotation mark */) &&
                ch !== 0x3030 /* wavy dash */) {
                return true;
            }
        }
        if (Constant.unicodeBlockLookup['CJK Unified Ideographs Extension A'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['CJK Unified Ideographs'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Enclosed CJK Letters and Months'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Hangul Compatibility Jamo'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Hangul Jamo Extended-A'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Hangul Jamo Extended-B'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Hangul Jamo'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Hangul Syllables'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Hiragana'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Ideographic Description Characters'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Kanbun'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Kangxi Radicals'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Katakana Phonetic Extensions'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Katakana'](ch)) {
            if (ch !== 0x30FC /* katakana-hiragana prolonged sound mark */) {
                return true;
            }
        }
        if (Constant.unicodeBlockLookup['Halfwidth and Fullwidth Forms'](ch)) {
            if (ch !== 0xFF08 /* fullwidth left parenthesis */ &&
                ch !== 0xFF09 /* fullwidth right parenthesis */ &&
                ch !== 0xFF0D /* fullwidth hyphen-minus */ &&
                !((ch >= 0xFF1A /* fullwidth colon */ && ch <= 0xFF1E) /* fullwidth greater-than sign */) &&
                ch !== 0xFF3B /* fullwidth left square bracket */ &&
                ch !== 0xFF3D /* fullwidth right square bracket */ &&
                ch !== 0xFF3F /* fullwidth low line */ &&
                !(ch >= 0xFF5B /* fullwidth left curly bracket */ && ch <= 0xFFDF) &&
                ch !== 0xFFE3 /* fullwidth macron */ &&
                !(ch >= 0xFFE8 /* halfwidth forms light vertical */ && ch <= 0xFFEF)) {
                return true;
            }
        }
        if (Constant.unicodeBlockLookup['Small Form Variants'](ch)) {
            if (!((ch >= 0xFE58 /* small em dash */ && ch <= 0xFE5E) /* small right tortoise shell bracket */) &&
                !((ch >= 0xFE63 /* small hyphen-minus */ && ch <= 0xFE66) /* small equals sign */)) {
                return true;
            }
        }
        if (Constant.unicodeBlockLookup['Unified Canadian Aboriginal Syllabics'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Unified Canadian Aboriginal Syllabics Extended'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Vertical Forms'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Yijing Hexagram Symbols'](ch)) {
            return true;
        }
        if (Constant.unicodeBlockLookup['Yi Syllables'](ch)) {
            return true;
        }
        return !!Constant.unicodeBlockLookup['Yi Radicals'](ch);
    }

    exports.charHasUprightVerticalOrientation = charHasUprightVerticalOrientation;

    function allowsVerticalWritingMode(chars) {
        for (var i = 0, list = chars; i < list.length; i += 1) {
            var ch = list[i];

            if (charHasUprightVerticalOrientation(ch.charCodeAt(0))) {
                return true;
            }
        }
        return false;
    }

    exports.allowsVerticalWritingMode = allowsVerticalWritingMode;


    function compareKeyZoom(a, b) {
        return ((a % 32) - (b % 32)) || (b - a);
    }

    exports.compareKeyZoom = compareKeyZoom;
});
},
'com/huayun/webgis/layers/support/RasterTileSource':function(){
/**
 * 
 * @see com.huayun.webgis.layers.support.RasterTileSource
 */
define([
    "../../facade/TileFacade",
    "../../gl/Texture"
], function (TileFacade, Texture) {
    /**
     * 
     * @ignore
     * @alias com.huayun.webgis.layers.support.RasterTileSource
     * @param id
     * @param options
     * @param url
     * @param layer
     * @constructor
     */
    function RasterTileSource(id, options, url, layer) {
        this.id = id;
        this.type = 'raster';
        this.minzoom = options.minzoom;
        this.maxzoom = options.maxzoom;
        this.roundZoom = true;
        this.scheme = 'xyz';
        this.tileSize = options.tileSize || 256;
        this.url = url;
        this.layer = layer;
    }

    RasterTileSource.prototype.hasTile = function hasTile(tileID) {
        // return !this.tileBounds || this.tileBounds.contains(tileID.canonical);
    };

    RasterTileSource.prototype.updateTileUrl = function (url) {
        this.url = url;
    };

    /**
     * 
     * @param tile
     * @param callback
     */
    RasterTileSource.prototype.loadTile = function loadTile(tile, callback) {
        var this$1 = this;
        var url = tile.tileID.canonical.url([this.url]);
        tile.request = TileFacade.loadTile(url, function (err, img) {
            delete tile.request;
            if (tile.aborted) {
                tile.state = 'unloaded';
                callback(null);
            } else if (err) {
                tile.state = 'errored';
                callback(err);
            } else if (img) {
                var context = this$1.layer.layerView.view.context;
                var gl = context.gl;
                tile.texture = this$1.layer.layerView.getTileTexture(img.width);
                if (tile.texture) {
                    tile.texture.update(img, {useMipmap: true});
                } else {
                    tile.texture = new Texture(context, img, gl.RGBA, {useMipmap: true});
                    tile.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
                    if (context.extTextureFilterAnisotropic) {
                        gl.texParameterf(gl.TEXTURE_2D, context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, context.extTextureFilterAnisotropicMax);
                    }
                }
                tile.state = 'loaded';
                callback(null);
            }
        })
    };

    /**
     * 
     * @param tile
     * @param callback
     */
    RasterTileSource.prototype.abortTile = function abortTile(tile, callback) {
        if (tile.request) {
            tile.request.cancel();
            delete tile.request;
        }
        callback();
    };

    /**
     * 
     * @param tile
     * @param callback
     */
    RasterTileSource.prototype.unloadTile = function unloadTile(tile, callback) {
        if (tile.texture) {
            this.layer.layerView.saveTileTexture(tile.texture);
        }
        callback();
    };

    RasterTileSource.prototype.hasTransition = function hasTransition() {
        return false;
    };

    return RasterTileSource;
})
},
'com/huayun/webgis/data/GeoJSONFeature':function(){
/**
 * 
 * @see com.huayun.webgis.work.GeoJSONFeature
 */
define([], function () {
    /**
     * 
     * @ignore
     * @alias com.huayun.webgis.work.GeoJSONFeature
     * @param vectorTileFeature
     * @param z
     * @param x
     * @param y
     * @property {String} type 
     * @property {Object} properties 
     * @property {String} id id
     * @property {Object} geometry 
     * @constructor
     */
    var GeoJSONFeature = function GeoJSONFeature(vectorTileFeature, z, x, y) {
        this.type = 'GeoJSONFeature';
        this._vectorTileFeature = vectorTileFeature;
        vectorTileFeature._z = z;
        vectorTileFeature._x = x;
        vectorTileFeature._y = y;
        this.properties = vectorTileFeature.properties;
        if (vectorTileFeature.id != null) {
            this.id = vectorTileFeature.id;
        }
    };

    var prototypeAccessors = {
        geometry: {configurable: true}
    };

    prototypeAccessors.geometry.get = function () {
        if (this._geometry === undefined) {
            this._geometry = this._vectorTileFeature.toGeoJSON(
                this._vectorTileFeature._x,
                this._vectorTileFeature._y,
                this._vectorTileFeature._z
            ).geometry;
        }
        return this._geometry;
    };

    prototypeAccessors.geometry.set = function (g) {
        this._geometry = g;
    };

    GeoJSONFeature.prototype.toJSON = function () {
        var json = {
            geometry: this.geometry
        };
        for (var i in this) {
            if (i === '_geometry' || i === '_vectorTileFeature') {
                continue;
            }
            json[i] = this[i];
        }
        return json;
    }

    Object.defineProperties(GeoJSONFeature.prototype, prototypeAccessors);

    return GeoJSONFeature;
});
},
'com/huayun/webgis/layers/support/ZoomHistory':function(){
define([], function () {
    var ZoomHistory = function ZoomHistory() {
        this.first = true;
    };
    ZoomHistory.prototype.update = function update(z, now) {
        var floorZ = Math.floor(z);

        if (this.first) {
            this.first = false;
            this.lastIntegerZoom = floorZ;
            this.lastIntegerZoomTime = 0;
            this.lastZoom = z;
            this.lastFloorZoom = floorZ;
            return true;
        }

        if (this.lastFloorZoom > floorZ) {
            this.lastIntegerZoom = floorZ + 1;
            this.lastIntegerZoomTime = now;
        } else if (this.lastFloorZoom < floorZ) {
            this.lastIntegerZoom = floorZ;
            this.lastIntegerZoomTime = now;
        }

        if (z !== this.lastZoom) {
            this.lastZoom = z;
            this.lastFloorZoom = floorZ;
            return true;
        }
        return false;
    };

    return ZoomHistory;
});
},
'com/huayun/webgis/gl/mode':function(){
define([
    "exports",
    "../utils/Color",
    "../utils/Constant"
], function (exports, Color, Constant) {

    var DepthMode = function DepthMode(depthFunc, depthMask, depthRange) {
        this.func = depthFunc;
        this.mask = depthMask;
        this.range = depthRange;
    };
    DepthMode.ReadOnly = false;
    DepthMode.ReadWrite = true;
    DepthMode.disabled = new DepthMode(Constant.glConstant.ALWAYS, DepthMode.ReadOnly, [0, 1]);
    DepthMode.opaque = new DepthMode(Constant.glConstant.LEQUAL, DepthMode.ReadWrite, [0, 1]);


    /**
     * webglcull
     * @param enable
     * @param mode
     * @param frontFace
     * @constructor
     */
    var CullFaceMode = function CullFaceMode(enable, mode, frontFace) {
        this.enable = enable;
        this.mode = mode;
        this.frontFace = frontFace;
    };
    CullFaceMode.disabled = new CullFaceMode(false, Constant.glConstant.BACK, Constant.glConstant.CCW);
    CullFaceMode.backCCW = new CullFaceMode(true, Constant.glConstant.BACK, Constant.glConstant.CCW);

    /**
     * webgl
     * @param blendFunction
     * @param blendColor
     * @param mask
     * @constructor
     */
    var ColorMode = function ColorMode(blendFunction, blendColor, mask) {
        this.blendFunction = blendFunction;
        this.blendColor = blendColor;
        this.mask = mask;
    };
    ColorMode.Replace = [Constant.glConstant.ONE, Constant.glConstant.ZERO];
    ColorMode.disabled = new ColorMode(ColorMode.Replace, Color.transparent, [false, false, false, false]);
    ColorMode.unblended = new ColorMode(ColorMode.Replace, Color.transparent, [true, true, true, true]);
    ColorMode.alphaBlended = new ColorMode([Constant.glConstant.ONE, Constant.glConstant.ONE_MINUS_SRC_ALPHA], Color.transparent, [true, true, true, true]);
    ColorMode.srcBlended = new ColorMode([Constant.glConstant.SRC_ALPHA, Constant.glConstant.ONE_MINUS_SRC_ALPHA], Color.transparent, [true, true, true, true]);

    /**
     * webgl
     * @param test
     * @param ref
     * @param mask
     * @param fail
     * @param depthFail
     * @param pass
     * @constructor
     */
    var StencilMode = function StencilMode(test, ref, mask, fail, depthFail, pass) {
        this.test = test;
        this.ref = ref;
        this.mask = mask;
        this.fail = fail;
        this.depthFail = depthFail;
        this.pass = pass;
    };
    StencilMode.disabled = new StencilMode({
        func: Constant.glConstant.ALWAYS,
        mask: 0
    }, 0, 0, Constant.glConstant.KEEP, Constant.glConstant.KEEP, Constant.glConstant.KEEP);

    exports.DepthMode = DepthMode;
    exports.CullFaceMode = CullFaceMode;
    exports.ColorMode = ColorMode;
    exports.StencilMode = StencilMode;

});
},
'dojo/request':function(){
define([
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});

},
'com/huayun/webgis/symbols/PointSymbol':function(){
/**
 * Symbol
 * @module com/huayun/webgis/symbols
 * @see com.huayun.webgis.symbols.PointSymbol
 */
define([
    "./Symbol",
    "../utils/Color"
], function (BaseSymbol, Color) {
    /**
     * Symbol
     * @constructor
     * @alias com.huayun.webgis.symbols.PointSymbol
     * @extends {Symbol}
     * @param {Object} params 
     * @param {String} params.color 
     * @param {number} params.opacity 
     * @param {number} params.radius 
     * @param {number} params.strokeWidth 
     * @param {number} params.strokeOpacity 
     * @param {String} params.strokeColor  
     * @property {String} color  
     * @property {number} opacity  
     * @property {number} radius  
     * @property {number} strokeWidth  
     * @property {number} strokeOpacity 
     */
    var PointSymbol = function (params) {
        BaseSymbol.call(this, params);
        this.type = "point";
        var color = Color.parse(params.color||"#FF0000"),
            opacity = params.opacity ===  undefined?1: params.opacity,
            radius = params.radius || 5,
            strokeColor = Color.parse(params.strokeColor||"#FFFFFF"),
            strokeWidth = params.strokeWidth || 0,
            strokeOpacity = params.strokeOpacity || 1;
        this.color = color;
        this.opacity = opacity;
        this.radius = radius;
        this.strokeWidth = strokeWidth;

        this.pitchWithMap = !!params.pitchWithMap;
        this.scaleWithPitch = !!params.scaleWithPitch;
        this.uniforms = {
            "color": [color.r, color.g, color.b, color.a],
            "opacity": opacity,
            "u_device_pixel_ratio": 1,
            "u_pitch_with_map": this.pitchWithMap,
            "u_scale_with_map": this.scaleWithPitch,
            "blur": 0,
            "radius": radius,
            "stroke_color": [strokeColor.r, strokeColor.g, strokeColor.b, strokeColor.a],
            "stroke_width": strokeWidth,
            "stroke_opacity": strokeOpacity
        };
    };
    if (BaseSymbol) PointSymbol.__proto__ = BaseSymbol;
    PointSymbol.prototype = Object.create(BaseSymbol && BaseSymbol.prototype);
    PointSymbol.prototype.constructor = PointSymbol;

    return PointSymbol;
});
},
'com/huayun/webgis/layers/support/TileInfo':function(){
define(["dojo/_base/declare", "../../geometry/MapPoint", "./LOD", "../../geometry/Extent"], function (declare, MapPoint, LOD, Extent) {
    return declare("com.huayun.webgis.layers.support.TileInfo", [], {
        size: 256,
        dpi: 96,
        format: "PNG8",
        origin: null,
        lods: [],
        fullExtent: null,

        constructor: function (params) {
            this.lods = params.lods;
            this.origin = params.origin;
            this.size = params.size ? params.size : 256;
            this.dpi = params.dpi ? params.dpi : 96;
            this.fullExtent = params.fullExtent;
            // this.baseResolution =
            this.lods.forEach(function (item) {
                if (item.level === 0) {
                    this.baseResolution = item.resolution;
                }
            }.bind(this))
        },

        toString: function () {
            return "size: " + this.size + " dpi: " + this.dpi;
        },

        /**
         * 
         * @param {number} zoom - 
         * @return {number} - 
         */
        getResolution: function (zoom) {
            return this.baseResolution / Math.pow(2, zoom);
        },

        /**
         * 
         * @param {number} resolution - 
         */
        getLevel: function (resolution) {
            return Math.log2(this.baseResolution / resolution);
        },

        /**
         * 
         * @param {number} tempResolution - 
         * @return {Object} 
         */
        findNestZoom: function (tempResolution) {
            var lods = this.lods,
                len = lods.length, ratio = 0;
            for (var j = len - 1; j > -1; j--) {
                ratio = lods[j].resolution / tempResolution;
                if (ratio < 1.9 && ratio > 0.95) {
                    return {
                        resolution: lods[j].resolution,
                        level: j
                    };
                }
            }
            return {
                level: len - 1,
                resolution: lods[len - 1].resolution
            };
        },


        getColForX: function (x, resolution) {
            return (x - this.origin.x) / (resolution * this.size);
        },

        getRowForY: function (y, resolution) {
            return (this.origin.y - y) / (resolution * this.size);
        },
        getColRange: function (resolution) {
            var ymin = this.fullExtent.miny,
                ymax = this.fullExtent.maxy;
            return [
                Math.floor((this.origin.y - ymax) / (resolution * this.size)),
                Math.ceil((this.origin.y - ymin) / (resolution * this.size))
            ]
        },
        getXForCol: function (x, resolution) {
            // return (x - this.origin.x) / (resolution * this.size);
            return (resolution * this.size) * x + this.origin.x;
        },
        getYForRow: function (y, resolution) {
            // return (this.origin.y - y) / (resolution * this.size);
            return this.origin.y - (resolution * this.size) * y;
        },
        getColForSceneX: function (x, resolution) {
            // return (x - this.origin.x) / (resolution * this.size);
            return (x - this.origin.x / resolution) / this.size;
        },
        getRowForSceneY: function (y, resolution) {
            return (this.origin.y / resolution - y) / this.size;
        },
        getSceneXForCol: function (x, resolution) {
            return this.size * x + this.origin.x / resolution;
        },
        getSceneYForRow: function (y, resolution) {
            // return (this.origin.y - y) / (resolution * this.size);
            return this.origin.y / resolution - this.size * y;
        },

        getSceneXForCol2: function (x, oldR, r) {
            // return this.size * x + this.origin.x / resolution;
            return (this.size * oldR * x + this.origin.x) / r;
        },

        getSceneYForRow2: function (y, oldR, r) {
            // return (this.origin.y - y) / (resolution * this.size);
            // return this.origin.y / resolution -  this.size * y;
            return (this.origin.y - this.size * oldR * y) / r;
        },
        getGeometry: function (unwrappedTileID, zoom) {
            var canonical = unwrappedTileID.canonical;
            var r = this.getResolution(zoom|| canonical.z);
            var x = this.getXForCol(canonical.x, r),
                y = this.getYForRow(canonical.y, r);
            return [x, y];
        },
        getSceneXForX: function (x, zoom) {
            return x / this.getResolution(zoom);
        },
        getSceneYForY: function (y, zoom) {
            return y / this.getResolution(zoom);
        },
        tileXYToRectangle: function (x, y, level) {
            var resolution = this.getResolution(level);
            var west = this.getXForCol(x, resolution);
            var east = this.getXForCol(x + 1, resolution);
            var north = this.getYForRow(y, resolution);
            var south = this.getYForRow(y + 1, resolution);
            return {
                west: west,
                east: east,
                north: north,
                south: south
            }
        }
    })
});
},
'com/huayun/webgis/gl/ImagePosition':function(){
define([], function () {
    var padding = 1;

    var ImagePosition = function ImagePosition(paddedRect, ref) {
        var pixelRatio = ref.pixelRatio;
        var version = ref.version;
        this.paddedRect = paddedRect;
        this.pixelRatio = pixelRatio;
        this.version = version;
    };

    var prototypeAccessors = {
        tl: {configurable: true},
        br: {configurable: true},
        tlbr: {configurable: true},
        displaySize: {configurable: true}
    };

    prototypeAccessors.tl.get = function () {
        return [
            this.paddedRect.x + padding,
            this.paddedRect.y + padding
        ];
    };

    prototypeAccessors.br.get = function () {
        return [
            this.paddedRect.x + this.paddedRect.w - padding,
            this.paddedRect.y + this.paddedRect.h - padding
        ];
    };

    prototypeAccessors.tlbr.get = function () {
        return this.tl.concat(this.br);
    };

    prototypeAccessors.displaySize.get = function () {
        return [
            (this.paddedRect.w - padding * 2) / this.pixelRatio,
            (this.paddedRect.h - padding * 2) / this.pixelRatio
        ];
    };

    Object.defineProperties(ImagePosition.prototype, prototypeAccessors);

    return ImagePosition;
});
},
'com/huayun/webgis/utils/extendClazz':function(){
define([], function () {
    function extendClazz(clazz, parent) {
        if (parent) clazz.__proto__ = parent;
        clazz.prototype = Object.create(parent && parent.prototype);
        clazz.prototype.constructor = clazz;
    }

    return extendClazz;
})
},
'com/huayun/webgis/gl/VertexFragShader':function(){
define([
    "exports",
    "../data/uniform",
    "dojo/text!./shaders/rect.vertex.glsl",
    "dojo/text!./shaders/rect.fragment.glsl",
    "dojo/text!./shaders/terrain.vertex.glsl",
    "dojo/text!./shaders/terrain.fragment.glsl",
    "dojo/text!./shaders/height_map.vertex.glsl",
    "dojo/text!./shaders/height_map.fragment.glsl",
    "dojo/text!./shaders/tiffTerrain.vertex.glsl",
    "dojo/text!./shaders/tifTerrain.fragment.glsl",
    "dojo/text!./shaders/water.vertex.glsl",
    "dojo/text!./shaders/water.fragment.glsl",
    "dojo/text!./shaders/fill_extrusion.vertex.glsl",
    "dojo/text!./shaders/fill_extrusion.fragment.glsl",
    "dojo/text!./shaders/background.vertex.glsl",
    "dojo/text!./shaders/background.fragment.glsl",
    "dojo/text!./shaders/mesh.vertex.glsl",
    "dojo/text!./shaders/mesh.fragment.glsl",
    "dojo/text!./shaders/cylinder.vertex.glsl",
    "dojo/text!./shaders/cylinder.fragment.glsl",
    "dojo/text!./shaders/cone.vertex.glsl",
    "dojo/text!./shaders/cone.fragment.glsl",
    "dojo/text!./shaders/line.vertex.glsl",
    "dojo/text!./shaders/line.fragment.glsl"
], function (exports, uniform,
             rectVertex,
             reactFragment,
             terrainVertex,
             terrainFragment,
             heightMapVertex,
             heightMapFragment,
             tiffTerrainVertex,
             tiffTerrainFragment,
             waterVertex,
             waterFragment,
             fillExtrusionVert,
             fillExtrusionFrag,
             bgVertex,
             bgFragment,
             meshVertex,
             meshFragment,
             cylinderVertex,
             cylinderFragment,
             coneVertex,
             coneFragment,
             mylineVertex,
             mylineFragment
) {

    //------------------------------------------------------------------------------------------------------------------background
    var backgroundVert = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "#endif\n" +
        "\n" +
        "attribute vec2 a_pos;\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "\n" +
        "void main() {\n" +
        "    gl_Position = u_matrix * vec4(a_pos, -1, 1);\n" +
        "}";

    var backgroundFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform vec4 u_color;\n" +
        "uniform float u_opacity;\n" +
        "\n" +
        "void main() {\n" +
        "    gl_FragColor = u_color * u_opacity;\n" +
        "\n" +
        "#ifdef OVERDRAW_INSPECTOR\n" +
        "    gl_FragColor = vec4(1.0);\n" +
        "#endif\n" +
        "}";

    var backgroundUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_color': new uniform.UniformColor(context, locations.u_color)
        });
    };

    //------------------------------------------------------------------------------------------------------------------
    var clippingMaskVert = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "attribute vec2 a_pos;\n" +
        "uniform mat4 u_matrix;\n" +
        "\n" +
        "void main() {\n" +
        "    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n" +
        "}";

    var clippingMaskFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "void main() {\n" +
        "    gl_FragColor = vec4(1.0);\n" +
        "}";
    var clippingMaskUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)
        });
    };
    //------------------------------------------------------------------------------------------------------------------OK

    //------------------------------------------------------------------------------------------------------------------fill
    /**
     * 
     * @type {string}
     */
    var fillVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "vec2 unpack_float(const float packedValue) {\n" +
        "    int packedIntValue = int(packedValue);\n" +
        "    int v0 = packedIntValue / 256;\n" +
        "    return vec2(v0, packedIntValue - v0 * 256);\n" +
        "}\n" +
        "\n" +
        "vec4 decode_color(const vec2 encodedColor) {\n" +
        "    return vec4(\n" +
        "        unpack_float(encodedColor[0]) / 255.0,\n" +
        "        unpack_float(encodedColor[1]) / 255.0\n" +
        "    );\n" +
        "}\n" +
        "\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "\n" +
        "vec4 unpack_mix_color(const vec4 packedColors, const float t) {\n" +
        "    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n" +
        "    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n" +
        "    return mix(minColor, maxColor, t);\n" +
        "}\n" +
        "\n" +
        "attribute vec2 a_pos;\n" +
        "uniform mat4 u_matrix;\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "uniform lowp float u_color_t;\n" +
        "attribute highp vec4 a_color;\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "uniform lowp float u_opacity_t;\n" +
        "attribute lowp vec2 a_opacity;\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "void main() {\n" +
        "    #ifndef HAS_UNIFORM_u_color\n" +
        "        color = unpack_mix_color(a_color, u_color_t);\n" +
        "    #else\n" +
        "        highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_opacity\n" +
        "        opacity = unpack_mix_vec2(a_opacity, u_opacity_t);\n" +
        "    #else\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n" +
        "}";

    /**
     * 
     * @type {string}
     */
    var fillFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "void main() {\n" +
        "    #ifdef HAS_UNIFORM_u_color\n" +
        "        highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_opacity\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "    gl_FragColor = color * opacity;\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "        gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "}";
    /**
     * uniform
     * @param context
     * @param locations
     */
    var fillUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)/*,
      'iz': new uniform.Uniform1f(context, locations.iz)*/
        });
    };

    //------------------------------------------------------------------------------------------------------------------fill

    //------------------------------------------------------------------------------------------------------------------
    /**
     * 
     * @type {string}
     */
    var lineVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "#endif\n" +
        "\n" +
        "vec2 unpack_float(const float packedValue) {\n" +
        "    int packedIntValue = int(packedValue);\n" +
        "    int v0 = packedIntValue / 256;\n" +
        "    return vec2(v0, packedIntValue - v0 * 256);\n" +
        "}\n" +
        "vec4 decode_color(const vec2 encodedColor) {\n" +
        "    return vec4(\n" +
        "        unpack_float(encodedColor[0]) / 255.0,\n" +
        "        unpack_float(encodedColor[1]) / 255.0\n" +
        "    );\n" +
        "}\n" +
        "\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "\n" +
        "vec4 unpack_mix_color(const vec4 packedColors, const float t) {\n" +
        "    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n" +
        "    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n" +
        "    return mix(minColor, maxColor, t);\n" +
        "}\n" +
        "\n" +
        "#define scale 0.015873016\n" +
        "\n" +
        "attribute vec2 a_pos_normal;\n" +
        "attribute vec4 a_data;\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform mediump float u_ratio;\n" +
        "uniform vec2 u_units_to_pixels;\n" +
        "uniform lowp float u_device_pixel_ratio;\n" +
        "\n" +
        "varying vec2 v_normal;\n" +
        "varying vec2 v_width2;\n" +
        "varying float v_gamma_scale;\n" +
        "varying highp float v_linesofar;\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "uniform lowp float u_color_t;\n" +
        "attribute highp vec4 a_color;\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_blur\n" +
        "uniform lowp float u_blur_t;\n" +
        "attribute lowp vec2 a_blur;\n" +
        "varying lowp float blur;\n" +
        "#else\n" +
        "uniform lowp float u_blur;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "uniform lowp float u_opacity_t;\n" +
        "attribute lowp vec2 a_opacity;\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_gapwidth\n" +
        "uniform lowp float u_gapwidth_t;\n" +
        "attribute mediump vec2 a_gapwidth;\n" +
        "#else\n" +
        "uniform mediump float u_gapwidth;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_offset\n" +
        "uniform lowp float u_offset_t;\n" +
        "attribute lowp vec2 a_offset;\n" +
        "#else\n" +
        "uniform lowp float u_offset;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_width\n" +
        "uniform lowp float u_width_t;\n" +
        "attribute mediump vec2 a_width;\n" +
        "#else\n" +
        "uniform mediump float u_width;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "void main() {\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_color\n" +
        "        color = unpack_mix_color(a_color, u_color_t);\n" +
        "    #else\n" +
        "        highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_blur\n" +
        "        blur = unpack_mix_vec2(a_blur, u_blur_t);\n" +
        "    #else\n" +
        "        lowp float blur = u_blur;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_opacity\n" +
        "        opacity = unpack_mix_vec2(a_opacity, u_opacity_t);\n" +
        "    #else\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_gapwidth\n" +
        "        mediump float gapwidth = unpack_mix_vec2(a_gapwidth, u_gapwidth_t);\n" +
        "    #else\n" +
        "        mediump float gapwidth = u_gapwidth;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_offset\n" +
        "        lowp float offset = unpack_mix_vec2(a_offset, u_offset_t);\n" +
        "    #else\n" +
        "        lowp float offset = u_offset;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_width\n" +
        "        mediump float width = unpack_mix_vec2(a_width, u_width_t);\n" +
        "    #else\n" +
        "        mediump float width = u_width;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    // the distance over which the line edge fades out.\n" +
        "    // Retina devices need a smaller distance to avoid aliasing.\n" +
        "    float ANTIALIASING = 1.0 / u_device_pixel_ratio / 2.0;\n" +
        "\n" +
        "    vec2 a_extrude = a_data.xy - 128.0;\n" +
        "    float a_direction = mod(a_data.z, 4.0) - 1.0;\n" +
        "\n" +
        "    v_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0;\n" +
        "\n" +
        "    vec2 pos = floor(a_pos_normal * 0.5);\n" +
        "\n" +
        "    // x is 1 if it's a round cap, 0 otherwise\n" +
        "    // y is 1 if the normal points up, and -1 if it points down\n" +
        "    // We store these in the least significant bit of a_pos_normal\n" +
        "    mediump vec2 normal = a_pos_normal - 2.0 * pos;\n" +
        "    normal.y = normal.y * 2.0 - 1.0;\n" +
        "    v_normal = normal;\n" +
        "\n" +
        "    // these transformations used to be applied in the JS and native code bases.\n" +
        "    // moved them into the shader for clarity and simplicity.\n" +
        "    gapwidth = gapwidth / 2.0;\n" +
        "    float halfwidth = width / 2.0;\n" +
        "    offset = -1.0 * offset;\n" +
        "\n" +
        "    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n" +
        "    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n" +
        "\n" +
        "    // Scale the extrusion vector down to a normal and then up by the line width\n" +
        "    // of this vertex.\n" +
        "    mediump vec2 dist = outset * a_extrude * scale;\n" +
        "\n" +
        "    // Calculate the offset when drawing a line that is to the side of the actual line.\n" +
        "    // We do this by creating a vector that points towards the extrude, but rotate\n" +
        "    // it when we're drawing round end points (a_direction = -1 or 1) since their\n" +
        "    // extrude vector points in another direction.\n" +
        "    mediump float u = 0.5 * a_direction;\n" +
        "    mediump float t = 1.0 - abs(u);\n" +
        "    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n" +
        "\n" +
        "    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n" +
        "    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 1.1, 1.0) + projected_extrude;\n" +
        "\n" +
        "    // calculate how much the perspective view squishes or stretches the extrude\n" +
        "    float extrude_length_without_perspective = length(dist);\n" +
        "    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);\n" +
        "    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n" +
        "\n" +
        "    v_width2 = vec2(outset, inset);\n" +
        "}";
    /**
     * 
     * @type {string}
     */
    var lineFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "#endif\n" +
        "uniform lowp float u_device_pixel_ratio;\n" +
        "varying vec2 v_width2;\n" +
        "varying vec2 v_normal;\n" +
        "varying float v_gamma_scale;\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "#ifndef HAS_UNIFORM_u_blur\n" +
        "varying lowp float blur;\n" +
        "#else\n" +
        "uniform lowp float u_blur;\n" +
        "#endif\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "void main() {\n" +
        "    #ifdef HAS_UNIFORM_u_color\n" +
        "        highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "    #ifdef HAS_UNIFORM_u_blur\n" +
        "        lowp float blur = u_blur;\n" +
        "    #endif\n" +
        "    #ifdef HAS_UNIFORM_u_opacity\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "        float dist = length(v_normal) * v_width2.s;\n" +
        "        float blur2 = (blur + 1.0 / u_device_pixel_ratio) * v_gamma_scale;\n" +
        "        float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n" +
        "        gl_FragColor = color * (alpha * opacity);\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "        gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "}\n";
    exports.line = {
        vertexSource: lineVertex,
        fragmentSource: lineFrag
    };

    /**
     * uniform
     * @param context
     * @param locations
     */
    var lineUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_ratio': new uniform.Uniform1f(context, locations.u_ratio),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_units_to_pixels': new uniform.Uniform2f(context, locations.u_units_to_pixels)
        });
    };
    //------------------------------------------------------------------------------------------------------------------OK

    //------------------------------------------------------------------------------------------------------------------
    /**
     * 
     * @type {string}
     */
    var lineDashVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "vec2 unpack_float(const float packedValue) {\n" +
        "    int packedIntValue = int(packedValue);\n" +
        "    int v0 = packedIntValue / 256;\n" +
        "    return vec2(v0, packedIntValue - v0 * 256);\n" +
        "}\n" +
        "\n" +
        "vec4 decode_color(const vec2 encodedColor) {\n" +
        "    return vec4(\n" +
        "        unpack_float(encodedColor[0]) / 255.0,\n" +
        "        unpack_float(encodedColor[1]) / 255.0\n" +
        "    );\n" +
        "}\n" +
        "\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "\n" +
        "vec4 unpack_mix_color(const vec4 packedColors, const float t) {\n" +
        "    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n" +
        "    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n" +
        "    return mix(minColor, maxColor, t);\n" +
        "}\n" +
        "\n" +
        "#define scale 0.015873016\n" +
        "#define LINE_DISTANCE_SCALE 2.0\n" +
        "\n" +
        "attribute vec2 a_pos_normal;\n" +
        "attribute vec4 a_data;\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform mediump float u_ratio;\n" +
        "uniform lowp float u_device_pixel_ratio;\n" +
        "uniform vec2 u_patternscale_a;\n" +
        "uniform float u_tex_y_a;\n" +
        "uniform vec2 u_patternscale_b;\n" +
        "uniform float u_tex_y_b;\n" +
        "uniform vec2 u_units_to_pixels;\n" +
        "\n" +
        "varying vec2 v_normal;\n" +
        "varying vec2 v_width2;\n" +
        "varying vec2 v_tex_a;\n" +
        "varying vec2 v_tex_b;\n" +
        "varying float v_gamma_scale;\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "uniform lowp float u_color_t;\n" +
        "attribute highp vec4 a_color;\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_blur\n" +
        "uniform lowp float u_blur_t;\n" +
        "attribute lowp vec2 a_blur;\n" +
        "varying lowp float blur;\n" +
        "#else\n" +
        "uniform lowp float u_blur;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "uniform lowp float u_opacity_t;\n" +
        "attribute lowp vec2 a_opacity;\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_gapwidth\n" +
        "uniform lowp float u_gapwidth_t;\n" +
        "attribute mediump vec2 a_gapwidth;\n" +
        "#else\n" +
        "uniform mediump float u_gapwidth;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_offset\n" +
        "uniform lowp float u_offset_t;\n" +
        "attribute lowp vec2 a_offset;\n" +
        "#else\n" +
        "uniform lowp float u_offset;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_width\n" +
        "uniform lowp float u_width_t;\n" +
        "attribute mediump vec2 a_width;\n" +
        "varying mediump float width;\n" +
        "#else\n" +
        "uniform mediump float u_width;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_floorwidth\n" +
        "uniform lowp float u_floorwidth_t;\n" +
        "attribute lowp vec2 a_floorwidth;\n" +
        "varying lowp float floorwidth;\n" +
        "#else\n" +
        "uniform lowp float u_floorwidth;\n" +
        "#endif\n" +
        "\n" +
        "void main() {\n" +
        "    #ifndef HAS_UNIFORM_u_color\n" +
        "        color = unpack_mix_color(a_color, u_color_t);\n" +
        "    #else\n" +
        "        highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_blur\n" +
        "        blur = unpack_mix_vec2(a_blur, u_blur_t);\n" +
        "    #else\n" +
        "        lowp float blur = u_blur;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_opacity\n" +
        "        opacity = unpack_mix_vec2(a_opacity, u_opacity_t);\n" +
        "    #else\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_gapwidth\n" +
        "        mediump float gapwidth = unpack_mix_vec2(a_gapwidth, u_gapwidth_t);\n" +
        "    #else\n" +
        "        mediump float gapwidth = u_gapwidth;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_offset\n" +
        "        lowp float offset = unpack_mix_vec2(a_offset, u_offset_t);\n" +
        "    #else\n" +
        "        lowp float offset = u_offset;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_width\n" +
        "        width = unpack_mix_vec2(a_width, u_width_t);\n" +
        "    #else\n" +
        "        mediump float width = u_width;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_floorwidth\n" +
        "        floorwidth = unpack_mix_vec2(a_floorwidth, u_floorwidth_t);\n" +
        "    #else\n" +
        "        lowp float floorwidth = u_floorwidth;\n" +
        "    #endif\n" +
        "\n" +
        "    float ANTIALIASING = 1.0 / u_device_pixel_ratio / 2.0;\n" +
        "    vec2 a_extrude = a_data.xy - 128.0;\n" +
        "    float a_direction = mod(a_data.z, 4.0) - 1.0;\n" +
        "    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n" +
        "\n" +
        "    vec2 pos = floor(a_pos_normal * 0.5);\n" +
        "\n" +
        "    mediump vec2 normal = a_pos_normal - 2.0 * pos;\n" +
        "    normal.y = normal.y * 2.0 - 1.0;\n" +
        "    v_normal = normal;\n" +
        "\n" +
        "    gapwidth = gapwidth / 2.0;\n" +
        "    float halfwidth = width / 2.0;\n" +
        "    offset = -1.0 * offset;\n" +
        "    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n" +
        "    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n" +
        "    mediump vec2 dist =outset * a_extrude * scale;\n" +
        "    mediump float u = 0.5 * a_direction;\n" +
        "    mediump float t = 1.0 - abs(u);\n" +
        "    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n" +
        "    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n" +
        "    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 1.1, 1.0) + projected_extrude;\n" +
        "    float extrude_length_without_perspective = length(dist);\n" +
        "    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);\n" +
        "    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n" +
        "    v_tex_a = vec2(a_linesofar * u_patternscale_a.x / floorwidth, normal.y * u_patternscale_a.y + u_tex_y_a);\n" +
        "    v_tex_b = vec2(a_linesofar * u_patternscale_b.x / floorwidth, normal.y * u_patternscale_b.y + u_tex_y_b);\n" +
        "    v_width2 = vec2(outset, inset);\n" +
        "}";

    /**
     * 
     * @type {string}
     */
    var lineDashFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform lowp float u_device_pixel_ratio;\n" +
        "uniform sampler2D u_image;\n" +
        "uniform float u_sdfgamma;\n" +
        "uniform float u_mix;\n" +
        "\n" +
        "varying vec2 v_normal;\n" +
        "varying vec2 v_width2;\n" +
        "varying vec2 v_tex_a;\n" +
        "varying vec2 v_tex_b;\n" +
        "varying float v_gamma_scale;\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_blur\n" +
        "varying lowp float blur;\n" +
        "#else\n" +
        "uniform lowp float u_blur;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_width\n" +
        "varying mediump float width;\n" +
        "#else\n" +
        "uniform mediump float u_width;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_floorwidth\n" +
        "varying lowp float floorwidth;\n" +
        "#else\n" +
        "uniform lowp float u_floorwidth;\n" +
        "#endif\n" +
        "\n" +
        "void main() {\n" +
        "    #ifdef HAS_UNIFORM_u_color\n" +
        "        highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_blur\n" +
        "        lowp float blur = u_blur;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_opacity\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_width\n" +
        "        mediump float width = u_width;\n" +
        "    #endif\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_floorwidth\n" +
        "        lowp float floorwidth = u_floorwidth;\n" +
        "    #endif\n" +
        "    float dist = length(v_normal) * v_width2.s;\n" +
        "\n" +
        "    float blur2 = (blur + 1.0 / u_device_pixel_ratio) * v_gamma_scale;\n" +
        "    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n" +
        "    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n" +
        "    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n" +
        "    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n" +
        "    alpha *= smoothstep(0.5 - u_sdfgamma / floorwidth, 0.5 + u_sdfgamma / floorwidth, sdfdist);\n" +
        "\n" +
        "    gl_FragColor = color * (alpha * opacity);\n" +
        "\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "        gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "}";

    /**
     * uniform
     * @param context
     * @param locations
     */
    var lineSDFUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_ratio': new uniform.Uniform1f(context, locations.u_ratio),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_units_to_pixels': new uniform.Uniform2f(context, locations.u_units_to_pixels),
            'u_patternscale_a': new uniform.Uniform2f(context, locations.u_patternscale_a),
            'u_patternscale_b': new uniform.Uniform2f(context, locations.u_patternscale_b),
            'u_sdfgamma': new uniform.Uniform1f(context, locations.u_sdfgamma),
            'u_image': new uniform.Uniform1i(context, locations.u_image),
            'u_tex_y_a': new uniform.Uniform1f(context, locations.u_tex_y_a),
            'u_tex_y_b': new uniform.Uniform1f(context, locations.u_tex_y_b),
            'u_mix': new uniform.Uniform1f(context, locations.u_mix)
        });
    };
    //------------------------------------------------------------------------------------------------------------------OK


    //------------------------------------------------------------------------------------------------------------------
    /**
     * 
     * @type {string}
     */
    var symbolVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "vec2 unpack_float(const float packedValue) {\n" +
        "    int packedIntValue = int(packedValue);\n" +
        "    int v0 = packedIntValue / 256;\n" +
        "    return vec2(v0, packedIntValue - v0 * 256);\n" +
        "}\n" +
        "vec2 unpack_opacity(const float packedOpacity) {\n" +
        "    int intOpacity = int(packedOpacity) / 2;\n" +
        "    return vec2(float(intOpacity) / 127.0, mod(packedOpacity, 2.0));\n" +
        "}\n" +
        "vec4 decode_color(const vec2 encodedColor) {\n" +
        "    return vec4(\n" +
        "        unpack_float(encodedColor[0]) / 255.0,\n" +
        "        unpack_float(encodedColor[1]) / 255.0\n" +
        "    );\n" +
        "}\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "vec4 unpack_mix_color(const vec4 packedColors, const float t) {\n" +
        "    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n" +
        "    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n" +
        "    return mix(minColor, maxColor, t);\n" +
        "}\n" +
        "const float PI = 3.141592653589793;\n" +
        "\n" +
        "attribute vec4 a_pos_offset;\n" +
        "attribute vec4 a_data;\n" +
        "attribute vec3 a_projected_pos;\n" +
        "attribute float a_fade_opacity;\n" +
        "\n" +
        "uniform bool u_is_size_zoom_constant;\n" +
        "uniform bool u_is_size_feature_constant;\n" +
        "uniform highp float u_size_t; \n" +
        "uniform highp float u_size; \n" +
        "uniform mat4 u_matrix;\n" +
        "uniform mat4 u_label_plane_matrix;\n" +
        "uniform mat4 u_coord_matrix;\n" +
        "uniform bool u_is_text;\n" +
        "uniform bool u_pitch_with_map;\n" +
        "uniform highp float u_pitch;\n" +
        "uniform bool u_rotate_symbol;\n" +
        "uniform highp float u_aspect_ratio;\n" +
        "uniform highp float u_camera_to_center_distance;\n" +
        "uniform float u_fade_change;\n" +
        "uniform vec2 u_texsize;\n" +
        "\n" +
        "varying vec2 v_data0;\n" +
        "varying vec3 v_data1;\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_fill_color\n" +
        "uniform lowp float u_fill_color_t;\n" +
        "attribute highp vec4 a_fill_color;\n" +
        "varying highp vec4 fill_color;\n" +
        "#else\n" +
        "uniform highp vec4 u_fill_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_halo_color\n" +
        "uniform lowp float u_halo_color_t;\n" +
        "attribute highp vec4 a_halo_color;\n" +
        "varying highp vec4 halo_color;\n" +
        "#else\n" +
        "uniform highp vec4 u_halo_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "uniform lowp float u_opacity_t;\n" +
        "attribute lowp vec2 a_opacity;\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_halo_width\n" +
        "uniform lowp float u_halo_width_t;\n" +
        "attribute lowp vec2 a_halo_width;\n" +
        "varying lowp float halo_width;\n" +
        "#else\n" +
        "uniform lowp float u_halo_width;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_halo_blur\n" +
        "uniform lowp float u_halo_blur_t;\n" +
        "attribute lowp vec2 a_halo_blur;\n" +
        "varying lowp float halo_blur;\n" +
        "#else\n" +
        "uniform lowp float u_halo_blur;\n" +
        "#endif\n" +
        "\n" +
        "void main() { \n" +
        "    #ifndef HAS_UNIFORM_u_fill_color\n" +
        "        fill_color = unpack_mix_color(a_fill_color, u_fill_color_t);\n" +
        "    #else\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "    #endif\n" +
        "    \n" +
        "        \n" +
        "    #ifndef HAS_UNIFORM_u_halo_color\n" +
        "        halo_color = unpack_mix_color(a_halo_color, u_halo_color_t);\n" +
        "    #else\n" +
        "        highp vec4 halo_color = u_halo_color;\n" +
        "    #endif\n" +
        "    \n" +
        "        \n" +
        "    #ifndef HAS_UNIFORM_u_opacity\n" +
        "        opacity = unpack_mix_vec2(a_opacity, u_opacity_t);\n" +
        "    #else\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "    \n" +
        "        \n" +
        "    #ifndef HAS_UNIFORM_u_halo_width\n" +
        "        halo_width = unpack_mix_vec2(a_halo_width, u_halo_width_t);\n" +
        "    #else\n" +
        "        lowp float halo_width = u_halo_width;\n" +
        "    #endif\n" +
        "    \n" +
        "        \n" +
        "    #ifndef HAS_UNIFORM_u_halo_blur\n" +
        "        halo_blur = unpack_mix_vec2(a_halo_blur, u_halo_blur_t);\n" +
        "    #else\n" +
        "        lowp float halo_blur = u_halo_blur;\n" +
        "    #endif\n" +
        "    vec2 a_pos = a_pos_offset.xy;\n" +
        "    vec2 a_offset = a_pos_offset.zw;\n" +
        "\n" +
        "    vec2 a_tex = a_data.xy;\n" +
        "    vec2 a_size = a_data.zw;\n" +
        "\n" +
        "    highp float segment_angle = -a_projected_pos[2];\n" +
        "    float size;\n" +
        "    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\n" +
        "        size = mix(a_size[0], a_size[1], u_size_t) / 256.0;\n" +
        "    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\n" +
        "        size = a_size[0] / 256.0;\n" +
        "    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {\n" +
        "        size = u_size;\n" +
        "    } else {\n" +
        "        size = u_size;\n" +
        "    }\n" +
        "    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n" +
        "    highp float camera_to_anchor_distance = projectedPoint.w;\n" +
        "    highp float distance_ratio = u_pitch_with_map ? camera_to_anchor_distance / u_camera_to_center_distance : u_camera_to_center_distance / camera_to_anchor_distance;\n" +
        "    highp float perspective_ratio = clamp( 0.5 + 0.5 * distance_ratio, 0.0, 4.0);\n" +
        "    size *= perspective_ratio;\n" +
        "    float fontScale = u_is_text ? size / 24.0 : size;\n" +
        "    highp float symbol_rotation = 0.0;\n" +
        "    if (u_rotate_symbol) {\n" +
        "        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n" +
        "        vec2 a = projectedPoint.xy / projectedPoint.w;\n" +
        "        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n" +
        "        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n" +
        "    }\n" +
        "    highp float angle_sin = sin(segment_angle + symbol_rotation);\n" +
        "    highp float angle_cos = cos(segment_angle + symbol_rotation);\n" +
        "    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n" +
        "    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n" +
        "    gl_Position = u_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n" +
        "    float gamma_scale = gl_Position.w;\n" +
        "    vec2 tex = a_tex / u_texsize;\n" +
        "    vec2 fade_opacity = unpack_opacity(a_fade_opacity);\n" +
        "    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;\n" +
        "    float interpolated_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));\n" +
        "    v_data0 = vec2(tex.x, tex.y);\n" +
        "    v_data1 = vec3(gamma_scale, size, interpolated_fade_opacity);\n" +
        "}";

    /**
     * 
     * @type {string}
     */
    var symbolFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "#define SDF_PX 8.0\n" +
        "uniform bool u_is_halo;\n" +
        "uniform sampler2D u_texture;\n" +
        "uniform highp float u_gamma_scale;\n" +
        "uniform lowp float u_device_pixel_ratio;\n" +
        "uniform bool u_is_text;\n" +
        "\n" +
        "varying vec2 v_data0;\n" +
        "varying vec3 v_data1;\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_fill_color\n" +
        "varying highp vec4 fill_color;\n" +
        "#else\n" +
        "uniform highp vec4 u_fill_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_halo_color\n" +
        "varying highp vec4 halo_color;\n" +
        "#else\n" +
        "uniform highp vec4 u_halo_color;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_halo_width\n" +
        "varying lowp float halo_width;\n" +
        "#else\n" +
        "uniform lowp float u_halo_width;\n" +
        "#endif\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_halo_blur\n" +
        "varying lowp float halo_blur;\n" +
        "#else\n" +
        "uniform lowp float u_halo_blur;\n" +
        "#endif\n" +
        "void main() {\n" +
        "    #ifdef HAS_UNIFORM_u_fill_color\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "    #endif\n" +
        "    #ifdef HAS_UNIFORM_u_halo_color\n" +
        "        highp vec4 halo_color = u_halo_color;\n" +
        "    #endif\n" +
        "    #ifdef HAS_UNIFORM_u_opacity\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "    #ifdef HAS_UNIFORM_u_halo_width\n" +
        "        lowp float halo_width = u_halo_width;\n" +
        "    #endif\n" +
        "    #ifdef HAS_UNIFORM_u_halo_blur\n" +
        "        lowp float halo_blur = u_halo_blur;\n" +
        "    #endif\n" +
        "\n" +
        "    float EDGE_GAMMA = 0.105 / u_device_pixel_ratio;\n" +
        "    vec2 tex = v_data0.xy;\n" +
        "    float gamma_scale = v_data1.x;\n" +
        "    float size = v_data1.y;\n" +
        "    float fade_opacity = v_data1[2];\n" +
        "    float fontScale = u_is_text ? size / 24.0 : size;\n" +
        "    lowp vec4 color = fill_color;\n" +
        "    highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);\n" +
        "    lowp float buff = (256.0 - 64.0) / 256.0;\n" +
        "    if (u_is_halo) {\n" +
        "        color = halo_color;\n" +
        "        gamma = (halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);\n" +
        "        buff = (6.0 - halo_width / fontScale) / SDF_PX;\n" +
        "    }\n" +
        "    lowp float dist = texture2D(u_texture, tex).a;\n" +
        "    highp float gamma_scaled = gamma * gamma_scale;\n" +
        "    highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n" +
        "    gl_FragColor = color * (alpha * opacity * fade_opacity);\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "        gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "}";

    /**
     * uniform
     * @param context
     * @param locations
     */
    var symbolSDFUniforms = function (context, locations) {
        return ({
            'u_is_size_zoom_constant': new uniform.Uniform1i(context, locations.u_is_size_zoom_constant),
            'u_is_size_feature_constant': new uniform.Uniform1i(context, locations.u_is_size_feature_constant),
            'u_size_t': new uniform.Uniform1f(context, locations.u_size_t),
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_pitch': new uniform.Uniform1f(context, locations.u_pitch),
            'u_rotate_symbol': new uniform.Uniform1i(context, locations.u_rotate_symbol),
            'u_aspect_ratio': new uniform.Uniform1f(context, locations.u_aspect_ratio),
            'u_fade_change': new uniform.Uniform1f(context, locations.u_fade_change),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_label_plane_matrix': new uniform.UniformMatrix4f(context, locations.u_label_plane_matrix),
            'u_coord_matrix': new uniform.UniformMatrix4f(context, locations.u_coord_matrix),
            'u_is_text': new uniform.Uniform1f(context, locations.u_is_text),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_gamma_scale': new uniform.Uniform1f(context, locations.u_gamma_scale),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_is_halo': new uniform.Uniform1f(context, locations.u_is_halo)
        });
    };
    //------------------------------------------------------------------------------------------------------------------OK

    //------------------------------------------------------------------------------------------------------------------Icon
    /**
     * 
     * @type {string}
     */
    var symbolIconVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "vec2 unpack_opacity(const float packedOpacity) {\n" +
        "    int intOpacity = int(packedOpacity) / 2;\n" +
        "    return vec2(float(intOpacity) / 127.0, mod(packedOpacity, 2.0));\n" +
        "}\n" +
        "\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "\n" +
        "const float PI = 3.141592653589793;\n" +
        "attribute vec4 a_pos_offset;\n" +
        "attribute vec4 a_data;\n" +
        "attribute vec3 a_projected_pos;\n" +
        "attribute float a_fade_opacity;\n" +
        "\n" +
        "uniform bool u_is_size_zoom_constant;\n" +
        "uniform bool u_is_size_feature_constant;\n" +
        "uniform highp float u_size_t;\n" +
        "uniform highp float u_size;\n" +
        "uniform highp float u_camera_to_center_distance;\n" +
        "uniform highp float u_pitch;\n" +
        "uniform bool u_rotate_symbol;\n" +
        "uniform highp float u_aspect_ratio;\n" +
        "uniform float u_fade_change;\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform mat4 u_label_plane_matrix;\n" +
        "uniform mat4 u_coord_matrix;\n" +
        "\n" +
        "uniform bool u_is_text;\n" +
        "uniform bool u_pitch_with_map;\n" +
        "\n" +
        "uniform vec2 u_texsize;\n" +
        "\n" +
        "varying vec2 v_tex;\n" +
        "varying float v_fade_opacity;\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "uniform lowp float u_opacity_t;\n" +
        "attribute lowp vec2 a_opacity;\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "void main() {\n" +
        "    \n" +
        "    #ifndef HAS_UNIFORM_u_opacity\n" +
        "        opacity = unpack_mix_vec2(a_opacity, u_opacity_t);\n" +
        "    #else\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "    vec2 a_pos = a_pos_offset.xy;\n" +
        "    vec2 a_offset = a_pos_offset.zw;\n" +
        "\n" +
        "    vec2 a_tex = a_data.xy;\n" +
        "    vec2 a_size = a_data.zw;\n" +
        "\n" +
        "    highp float segment_angle = -a_projected_pos[2];\n" +
        "\n" +
        "    float size;\n" +
        "    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\n" +
        "        size = mix(a_size[0], a_size[1], u_size_t) / 256.0;\n" +
        "    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\n" +
        "        size = a_size[0] / 256.0;\n" +
        "    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {\n" +
        "        size = u_size;\n" +
        "    } else {\n" +
        "        size = u_size;\n" +
        "    }\n" +
        "\n" +
        "    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n" +
        "    highp float camera_to_anchor_distance = projectedPoint.w;\n" +
        "    highp float distance_ratio = u_pitch_with_map ? camera_to_anchor_distance / u_camera_to_center_distance : u_camera_to_center_distance / camera_to_anchor_distance;\n" +
        "    highp float perspective_ratio = clamp(0.5 + 0.5 * distance_ratio, 0.0, 4.0);\n" +
        "\n" +
        "    size *= perspective_ratio;\n" +
        "\n" +
        "    float fontScale = u_is_text ? size / 24.0 : size;\n" +
        "\n" +
        "    highp float symbol_rotation = 0.0;\n" +
        "    if (u_rotate_symbol) {\n" +
        "        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n" +
        "        vec2 a = projectedPoint.xy / projectedPoint.w;\n" +
        "        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n" +
        "        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n" +
        "    }\n" +
        "    highp float angle_sin = sin(segment_angle + symbol_rotation);\n" +
        "    highp float angle_cos = cos(segment_angle + symbol_rotation);\n" +
        "    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n" +
        "    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n" +
        "    gl_Position = u_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.99, 1.0);\n" +
        "    v_tex = a_tex / u_texsize;\n" +
        "    vec2 fade_opacity = unpack_opacity(a_fade_opacity);\n" +
        "    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;\n" +
        "    v_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));\n" +
        "}";

    /**
     * 
     * @type {string}
     */
    var symbolIconFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "uniform sampler2D u_texture;\n" +
        "varying vec2 v_tex;\n" +
        "varying float v_fade_opacity;\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "void main() {\n" +
        "    #ifdef HAS_UNIFORM_u_opacity\n" +
        "        lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "    lowp float alpha = opacity * v_fade_opacity;\n" +
        "    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n" +
        "\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "        gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "}";
    /**
     * uniform
     * @param context
     * @param locations
     */
    var symbolIconUniforms = function (context, locations) {
        return ({
            'u_is_size_zoom_constant': new uniform.Uniform1i(context, locations.u_is_size_zoom_constant),
            'u_is_size_feature_constant': new uniform.Uniform1i(context, locations.u_is_size_feature_constant),
            'u_size_t': new uniform.Uniform1f(context, locations.u_size_t),
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_pitch': new uniform.Uniform1f(context, locations.u_pitch),
            'u_rotate_symbol': new uniform.Uniform1i(context, locations.u_rotate_symbol),
            'u_aspect_ratio': new uniform.Uniform1f(context, locations.u_aspect_ratio),
            'u_fade_change': new uniform.Uniform1f(context, locations.u_fade_change),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_label_plane_matrix': new uniform.UniformMatrix4f(context, locations.u_label_plane_matrix),
            'u_coord_matrix': new uniform.UniformMatrix4f(context, locations.u_coord_matrix),
            'u_is_text': new uniform.Uniform1f(context, locations.u_is_text),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture)
        });
    };

    var basicSymbolV = "const float PI = 3.141592653589793;\n" +
        "    attribute vec4 a_pos_offset;\n" +
        "    attribute vec4 a_data;\n" +
        "    attribute vec3 a_projected_pos;\n" +
        "\n" +
        "    uniform highp float u_size; // used when size is both zoom and feature constant\n" +
        "    uniform mat4 u_matrix;\n" +
        "    uniform mat4 u_label_plane_matrix;\n" +
        "    uniform mat4 u_coord_matrix;\n" +
        "    uniform bool u_is_text;\n" +
        "    uniform bool u_pitch_with_map;\n" +
        "    uniform highp float u_pitch;\n" +
        "    uniform bool u_rotate_symbol;\n" +
        "    uniform highp float u_aspect_ratio;\n" +
        "    uniform highp float u_camera_to_center_distance;\n" +
        "    uniform float u_fade_change;\n" +
        "    uniform vec2 u_texsize;\n" +
        "\n" +
        "    varying vec2 v_data0;\n" +
        "    varying vec3 v_data1;\n" +
        "\n" +
        "    uniform highp vec4 u_fill_color;\n" +
        "    uniform highp vec4 u_halo_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform lowp float u_halo_width;\n" +
        "    uniform lowp float u_halo_blur;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "        highp vec4 halo_color = u_halo_color;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        lowp float halo_width = u_halo_width;\n" +
        "        lowp float halo_blur = u_halo_blur;\n" +
        "\n" +
        "        vec2 a_pos = a_pos_offset.xy;\n" +
        "        vec2 a_offset = a_pos_offset.zw;\n" +
        "        vec2 a_tex = a_data.xy;\n" +
        "        vec2 a_size = a_data.zw;\n" +
        "        highp float segment_angle = -a_projected_pos[2];\n" +
        "        float size = u_size;\n" +
        "\n" +
        "        vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n" +
        "        highp float camera_to_anchor_distance = projectedPoint.w;\n" +
        "        highp float distance_ratio = u_pitch_with_map ? camera_to_anchor_distance / u_camera_to_center_distance : u_camera_to_center_distance / camera_to_anchor_distance;\n" +
        "        highp float perspective_ratio = clamp(\n" +
        "        0.5 + 0.5 * distance_ratio,\n" +
        "        0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n" +
        "        4.0);\n" +
        "\n" +
        "        size *= perspective_ratio;\n" +
        "        float fontScale = u_is_text ? size / 24.0 : size;\n" +
        "        highp float symbol_rotation = 0.0;\n" +
        "        if (u_rotate_symbol) {\n" +
        "            vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n" +
        "            vec2 a = projectedPoint.xy / projectedPoint.w;\n" +
        "            vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n" +
        "            symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n" +
        "        }\n" +
        "\n" +
        "        highp float angle_sin = sin(segment_angle + symbol_rotation);\n" +
        "        highp float angle_cos = cos(segment_angle + symbol_rotation);\n" +
        "        mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n" +
        "\n" +
        "        vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n" +
        "        gl_Position = u_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n" +
        "        float gamma_scale = gl_Position.w;\n" +
        "\n" +
        "        vec2 tex = a_tex / u_texsize;\n" +
        "        float interpolated_fade_opacity = 1.0;\n" +
        "\n" +
        "        v_data0 = vec2(tex.x, tex.y);\n" +
        "        v_data1 = vec3(gamma_scale, size, interpolated_fade_opacity);\n" +
        "    }";

    var basicSymbolF = "precision mediump float;\n" +
        "\n" +
        "    #define SDF_PX 8.0\n" +
        "\n" +
        "    uniform bool u_is_halo;\n" +
        "    uniform sampler2D u_texture;\n" +
        "    uniform highp float u_gamma_scale;\n" +
        "    uniform lowp float u_device_pixel_ratio;\n" +
        "    uniform bool u_is_text;\n" +
        "\n" +
        "    varying vec2 v_data0;\n" +
        "    varying vec3 v_data1;\n" +
        "\n" +
        "    uniform highp vec4 u_fill_color;\n" +
        "    uniform highp vec4 u_halo_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform lowp float u_halo_width;\n" +
        "    uniform lowp float u_halo_blur;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "        highp vec4 halo_color = u_halo_color;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        lowp float halo_width = u_halo_width;\n" +
        "        lowp float halo_blur = u_halo_blur;\n" +
        "\n" +
        "        float EDGE_GAMMA = 0.105 / u_device_pixel_ratio;\n" +
        "\n" +
        "        vec2 tex = v_data0.xy;\n" +
        "        float gamma_scale = v_data1.x;\n" +
        "        float size = v_data1.y;\n" +
        "        float fade_opacity = v_data1[2];\n" +
        "\n" +
        "        float fontScale = u_is_text ? size / 24.0 : size;\n" +
        "\n" +
        "        lowp vec4 color = fill_color;\n" +
        "        highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);\n" +
        "        lowp float buff = (256.0 - 64.0) / 256.0;\n" +
        "        if (u_is_halo) {\n" +
        "            color = halo_color;\n" +
        "            gamma = (halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);\n" +
        "            buff = (6.0 - halo_width / fontScale) / SDF_PX;\n" +
        "        }\n" +
        "        lowp float dist = texture2D(u_texture, tex).a;\n" +
        "        highp float gamma_scaled = gamma * gamma_scale;\n" +
        "        highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n" +
        "        gl_FragColor = color * (alpha * opacity * fade_opacity);\n" +
        "    }";

    var basicSymbolUniform = function (context, locations) {
        return ({
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_pitch': new uniform.Uniform1f(context, locations.u_pitch),
            'u_rotate_symbol': new uniform.Uniform1i(context, locations.u_rotate_symbol),
            'u_aspect_ratio': new uniform.Uniform1f(context, locations.u_aspect_ratio),
            'u_fade_change': new uniform.Uniform1f(context, locations.u_fade_change),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_label_plane_matrix': new uniform.UniformMatrix4f(context, locations.u_label_plane_matrix),
            'u_coord_matrix': new uniform.UniformMatrix4f(context, locations.u_coord_matrix),
            'u_is_text': new uniform.Uniform1f(context, locations.u_is_text),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_gamma_scale': new uniform.Uniform1f(context, locations.u_gamma_scale),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_is_halo': new uniform.Uniform1f(context, locations.u_is_halo),
            'u_fill_color': new uniform.Uniform4f(context, locations.u_fill_color),
            'u_halo_color': new uniform.Uniform4f(context, locations.u_halo_color),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_halo_width': new uniform.Uniform1f(context, locations.u_halo_width),
            'u_halo_blur': new uniform.Uniform1f(context, locations.u_halo_blur)

        });
    };
    //------------------------------------------------------------------------------------------------------------------IconOK


    //------------------------------------------------------------------------------------------------------------------Heatmap
    var heatmapVertex = "#define HAS_UNIFORM_u_radius\n" +
        "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform float u_extrude_scale;\n" +
        "uniform float u_opacity;\n" +
        "uniform float u_intensity;\n" +
        "\n" +
        "attribute vec2 a_pos;\n" +
        "\n" +
        "varying vec2 v_extrude;\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_weight\n" +
        "uniform lowp float u_weight_t;\n" +
        "attribute highp vec2 a_weight;\n" +
        "varying highp float weight;\n" +
        "#else\n" +
        "uniform highp float u_weight;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_radius\n" +
        "uniform lowp float u_radius_t;\n" +
        "attribute mediump vec2 a_radius;\n" +
        "#else\n" +
        "uniform mediump float u_radius;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "const highp float ZERO = 1.0 / 255.0 / 16.0;\n" +
        "\n" +
        "// #define GAUSS_COEF 0.3989422804014327\n" +
        "#define GAUSS_COEF 1.0\n" +
        "\n" +
        "void main(void) {\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_weight\n" +
        "    weight = unpack_mix_vec2(a_weight, u_weight_t);\n" +
        "    #else\n" +
        "    highp float weight = u_weight;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_radius\n" +
        "    mediump float radius = unpack_mix_vec2(a_radius, u_radius_t);\n" +
        "    #else\n" +
        "    mediump float radius = u_radius;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    vec2 unscaled_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n" +
        "\n" +
        "    // S = sqrt(-2.0 * log(ZERO / (weight * u_intensity * GAUSS_COEF))) / 3.0\n" +
        "    float S = sqrt(-2.0 * log(ZERO / weight / u_intensity / GAUSS_COEF)) / 3.0;\n" +
        "\n" +
        "    // Pass the varying in units of radius\n" +
        "    v_extrude = S * unscaled_extrude;\n" +
        "\n" +
        "    // Scale by radius and the zoom-based scale factor to produce actual\n" +
        "    // mesh position\n" +
        "    vec2 extrude = v_extrude * radius * u_extrude_scale;\n" +
        "\n" +
        "    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n" +
        "    // in extrusion data\n" +
        "    vec4 pos = vec4(floor(a_pos * 0.5) + extrude, 0, 1);\n" +
        "\n" +
        "    gl_Position = u_matrix * pos;\n" +
        "}";

    var heatmapFrag = "#define HAS_UNIFORM_u_radius\n" +
        "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform highp float u_intensity;\n" +
        "\n" +
        "varying vec2 v_extrude;\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_weight\n" +
        "varying highp float weight;\n" +
        "#else\n" +
        "uniform highp float u_weight;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "// Gaussian kernel coefficient: 1 / sqrt(2 * PI)\n" +
        "#define GAUSS_COEF 0.3989422804014327\n" +
        "\n" +
        "void main() {\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_weight\n" +
        "    highp float weight = u_weight;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    // Kernel density estimation with a Gaussian kernel of size 5x5\n" +
        "    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n" +
        "    float val = weight * u_intensity * GAUSS_COEF * exp(d);\n" +
        "\n" +
        "    gl_FragColor = vec4(val, 1.0, 1.0, 1.0);\n" +
        "\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "    gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "}";

    var heatmapUniforms = function (context, locations) {
        return ({
            'u_extrude_scale': new uniform.Uniform1f(context, locations.u_extrude_scale),
            'u_intensity': new uniform.Uniform1f(context, locations.u_intensity),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)
        });
    };
    //------------------------------------------------------------------------------------------------------------------heatmapOK

    //------------------------------------------------------------------------------------------------------------------heatmap-texture
    var heatmapTextureVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform vec2 u_world;\n" +
        "attribute vec2 a_pos;\n" +
        "varying vec2 v_pos;\n" +
        "\n" +
        "void main() {\n" +
        "    gl_Position = u_matrix * vec4(a_pos * u_world, 0, 1);\n" +
        "\n" +
        "    v_pos.x = a_pos.x;\n" +
        "    v_pos.y = 1.0 - a_pos.y;\n" +
        "}";

    var heatmapTextureFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform sampler2D u_image;\n" +
        "uniform sampler2D u_color_ramp;\n" +
        "uniform float u_opacity;\n" +
        "varying vec2 v_pos;\n" +
        "\n" +
        "void main() {\n" +
        "    float t = texture2D(u_image, v_pos).r;\n" +
        "    vec4 color = texture2D(u_color_ramp, vec2(t, 0.5));\n" +
        "    gl_FragColor = color * u_opacity;\n" +
        "\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "    gl_FragColor = vec4(0.0);\n" +
        "    #endif\n" +
        "}";

    var heatmapTextureUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_world': new uniform.Uniform2f(context, locations.u_world),
            'u_image': new uniform.Uniform1i(context, locations.u_image),
            'u_color_ramp': new uniform.Uniform1i(context, locations.u_color_ramp),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity)
        });
    };

    //------------------------------------------------------------------------------------------------------------------
    var rasterVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform vec2 u_tl_parent;\n" +
        "uniform float u_scale_parent;\n" +
        "uniform float u_buffer_scale;\n" +
        "\n" +
        "attribute vec2 a_pos;\n" +
        "attribute vec2 a_texture_pos;\n" +
        "\n" +
        "varying vec2 v_pos0;\n" +
        "varying vec2 v_pos1;\n" +
        "\n" +
        "void main() {\n" +
        "    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n" +
        "    v_pos0 = (((a_texture_pos / 8192.0) - 0.5) / u_buffer_scale ) + 0.5;\n" +
        "    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n" +
        "}";

    var rasterFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform float u_fade_t;\n" +
        "uniform float u_opacity;\n" +
        "uniform sampler2D u_image0;\n" +
        "uniform sampler2D u_image1;\n" +
        "varying vec2 v_pos0;\n" +
        "varying vec2 v_pos1;\n" +
        "\n" +
        "uniform float u_brightness_low;\n" +
        "uniform float u_brightness_high;\n" +
        "\n" +
        "uniform float u_saturation_factor;\n" +
        "uniform float u_contrast_factor;\n" +
        "uniform vec3 u_spin_weights;\n" +
        "\n" +
        "void main() {\n" +
        "    vec4 color0 = texture2D(u_image0, v_pos0);\n" +
        "    vec4 color1 = texture2D(u_image1, v_pos1);\n" +
        "    if (color0.a > 0.0) {\n" +
        "        color0.rgb = color0.rgb / color0.a;\n" +
        "    }\n" +
        "    if (color1.a > 0.0) {\n" +
        "        color1.rgb = color1.rgb / color1.a;\n" +
        "    }\n" +
        "    vec4 color = mix(color0, color1, u_fade_t);\n" +
        "    color.a *= u_opacity;\n" +
        "    vec3 rgb = color.rgb;\n" +
        "\n" +
        "    // spin\n" +
        "    rgb = vec3(\n" +
        "    dot(rgb, u_spin_weights.xyz),\n" +
        "    dot(rgb, u_spin_weights.zxy),\n" +
        "    dot(rgb, u_spin_weights.yzx));\n" +
        "\n" +
        "    // saturation\n" +
        "    float average = (color.r + color.g + color.b) / 3.0;\n" +
        "    rgb += (average - rgb) * u_saturation_factor;\n" +
        "\n" +
        "    // contrast\n" +
        "    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n" +
        "\n" +
        "    // brightness\n" +
        "    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n" +
        "    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n" +
        "\n" +
        "    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb) * color.a, color.a);\n" +
        "}";

    var rasterUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_tl_parent': new uniform.Uniform2f(context, locations.u_tl_parent),
            'u_scale_parent': new uniform.Uniform1f(context, locations.u_scale_parent),
            'u_buffer_scale': new uniform.Uniform1f(context, locations.u_buffer_scale),
            'u_fade_t': new uniform.Uniform1f(context, locations.u_fade_t),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_image0': new uniform.Uniform1i(context, locations.u_image0),
            'u_image1': new uniform.Uniform1i(context, locations.u_image1),
            'u_brightness_low': new uniform.Uniform1f(context, locations.u_brightness_low),
            'u_brightness_high': new uniform.Uniform1f(context, locations.u_brightness_high),
            'u_saturation_factor': new uniform.Uniform1f(context, locations.u_saturation_factor),
            'u_contrast_factor': new uniform.Uniform1f(context, locations.u_contrast_factor),
            'u_spin_weights': new uniform.Uniform3f(context, locations.u_spin_weights)
        });
    };

    //------------------------------------------------------------------------------------------------------------------image-texture
    var imageTextureVertex = "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "attribute vec2 a_pos;\n" +
        "attribute vec2 a_texture_pos;\n" +
        "varying vec2 v_pos;\n" +
        "\n" +
        "void main() {\n" +
        "    // gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n" +
        "    gl_Position = u_matrix * vec4(a_pos, 0.1, 1.0);\n" +
        "    v_pos = a_texture_pos/8192.0;\n" +
        "}";

    var imageTextureFrag = "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "uniform sampler2D u_image;\n" +
        "uniform float u_opacity;\n" +
        "varying vec2 v_pos;\n" +
        "\n" +
        "void main() {\n" +
        "    vec4 color = texture2D(u_image, v_pos);\n" +
        "    gl_FragColor = color * u_opacity;\n" +
        "}";

    var imageTextureUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_image': new uniform.Uniform1i(context, locations.u_image),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity)
        };
    };

    //------------------------------------------------------------------------------------------------------------------Circle
    var circleVertex = "uniform mat4 u_matrix;\n" +
        "  uniform bool u_scale_with_map;\n" +
        "  uniform bool u_pitch_with_map;\n" +
        "  uniform vec2 u_extrude_scale;\n" +
        "  uniform lowp float u_device_pixel_ratio;\n" +
        "  uniform highp float u_camera_to_center_distance;\n" +
        "  attribute vec2 a_pos;\n" +
        "  attribute vec2 a_data;\n" +
        "  varying vec3 v_data;\n" +
        "  varying vec4 v_color;\n" +
        "  uniform mediump float radius;\n" +
        "  uniform mediump float stroke_width;\n" +
        "  void main(void) {\n" +
        "    vec2 extrude = a_data;\n" +
        "    vec2 circle_center = a_pos;\n" +
        "    if (u_pitch_with_map) {\n" +
        "      vec2 corner_position = circle_center;\n" +
        "      if (u_scale_with_map) {\n" +
        "        corner_position += extrude * (radius + stroke_width) * u_extrude_scale;\n" +
        "      } else {\n" +
        "        vec4 projected_center = u_matrix * vec4(circle_center, 0, 1);\n" +
        "        corner_position += extrude * (radius + stroke_width) * u_extrude_scale * (projected_center.w / u_camera_to_center_distance);\n" +
        "      }\n" +
        "\n" +
        "      gl_Position = u_matrix * vec4(corner_position, 0, 1);\n" +
        "    } else {\n" +
        "      gl_Position = u_matrix * vec4(circle_center, 0, 1);\n" +
        "\n" +
        "      if (u_scale_with_map) {\n" +
        "        gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * u_camera_to_center_distance;\n" +
        "      } else {\n" +
        "        gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * gl_Position.w;\n" +
        "      }\n" +
        "    }\n" +
        "    lowp float antialiasblur = 1.0 / u_device_pixel_ratio / (radius + stroke_width);\n" +
        "\n" +
        "    v_data = vec3(extrude.x, extrude.y, antialiasblur);\n" +
        "  }";

    var circleFragment = "precision mediump float;\n" +
        "  varying vec3 v_data;\n" +
        "  uniform highp vec4 color;\n" +
        "  uniform mediump float radius;\n" +
        "  uniform lowp float blur;\n" +
        "  uniform lowp float opacity;\n" +
        "  uniform highp vec4 stroke_color;\n" +
        "  uniform mediump float stroke_width;\n" +
        "  uniform lowp float stroke_opacity;\n" +
        "\n" +
        "  void main() {\n" +
        "\n" +
        "    vec2 extrude = v_data.xy;\n" +
        "    float extrude_length = length(extrude);\n" +
        "\n" +
        "    lowp float antialiasblur = v_data.z;\n" +
        "    float antialiased_blur = -max(blur, antialiasblur);\n" +
        "\n" +
        "    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n" +
        "\n" +
        "    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n" +
        "    antialiased_blur,\n" +
        "    0.0,\n" +
        "    extrude_length - radius / (radius + stroke_width)\n" +
        "    );\n" +
        "\n" +
        "    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t);\n" +
        "  }";

    var roundUniforms = function (context, locations) {
        return ({
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_scale_with_map': new uniform.Uniform1i(context, locations.u_scale_with_map),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_extrude_scale': new uniform.Uniform2f(context, locations.u_extrude_scale),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'radius': new uniform.Uniform1f(context, locations.radius),
            'stroke_width': new uniform.Uniform1f(context, locations.stroke_width),
            'color': new uniform.Uniform4f(context, locations.color),
            'stroke_color': new uniform.Uniform4f(context, locations.stroke_color),
            'blur': new uniform.Uniform1f(context, locations.blue),
            'opacity': new uniform.Uniform1f(context, locations.opacity),
            'stroke_opacity': new uniform.Uniform1f(context, locations.stroke_opacity)
        });
    };


    var multiCircleVertex = "uniform mat4 u_matrix;\n" +
        "  uniform bool u_scale_with_map;\n" +
        "  uniform bool u_pitch_with_map;\n" +
        "  uniform vec2 u_extrude_scale;\n" +
        "  uniform lowp float u_device_pixel_ratio;\n" +
        "  uniform highp float u_camera_to_center_distance;\n" +
        "  attribute vec2 a_pos;\n" +
        "  attribute vec4 a_color;\n" +
        "  varying vec3 v_data;\n" +
        "  varying vec4 v_color;\n" +
        "  uniform mediump float radius;\n" +
        "  uniform mediump float stroke_width;\n" +
        "  void main(void) {\n" +
        "    vec2 extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n" +
        "    vec2 circle_center = floor(a_pos * 0.5);\n" +
        "    if (u_pitch_with_map) {\n" +
        "      vec2 corner_position = circle_center;\n" +
        "      if (u_scale_with_map) {\n" +
        "        corner_position += extrude * (radius + stroke_width) * u_extrude_scale;\n" +
        "      } else {\n" +
        "        vec4 projected_center = u_matrix * vec4(circle_center, 0, 1);\n" +
        "        corner_position += extrude * (radius + stroke_width) * u_extrude_scale * (projected_center.w / u_camera_to_center_distance);\n" +
        "      }\n" +
        "\n" +
        "      gl_Position = u_matrix * vec4(corner_position, 0, 1);\n" +
        "    } else {\n" +
        "      gl_Position = u_matrix * vec4(circle_center, 0, 1);\n" +
        "\n" +
        "      if (u_scale_with_map) {\n" +
        "        gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * u_camera_to_center_distance;\n" +
        "      } else {\n" +
        "        gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * gl_Position.w;\n" +
        "      }\n" +
        "    }\n" +
        "    lowp float antialiasblur = 1.0 / u_device_pixel_ratio / (radius + stroke_width);\n" +
        "\n" +
        "    v_data = vec3(extrude.x, extrude.y, antialiasblur);\n" +
        "    v_color = a_color;\n" +
        "  }";

    var multiCircleFragment = "precision mediump float;\n" +
        "  varying vec3 v_data;\n" +
        "  varying vec4 v_color;\n" +
        "  uniform mediump float radius;\n" +
        "  uniform lowp float blur;\n" +
        "  uniform lowp float opacity;\n" +
        "  uniform highp vec4 stroke_color;\n" +
        "  uniform mediump float stroke_width;\n" +
        "  uniform lowp float stroke_opacity;\n" +
        "\n" +
        "  void main() {\n" +
        "\n" +
        "    vec2 extrude = v_data.xy;\n" +
        "    float extrude_length = length(extrude);\n" +
        "\n" +
        "    lowp float antialiasblur = v_data.z;\n" +
        "    float antialiased_blur = -max(blur, antialiasblur);\n" +
        "\n" +
        "    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n" +
        "\n" +
        "    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n" +
        "    antialiased_blur,\n" +
        "    0.0,\n" +
        "    extrude_length - radius / (radius + stroke_width)\n" +
        "    );\n" +
        "\n" +
        "    gl_FragColor = opacity_t * mix(v_color * opacity, stroke_color * stroke_opacity, color_t);\n" +
        "  }";

    var multiRoundUniforms = function (context, locations) {
        return ({
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_scale_with_map': new uniform.Uniform1i(context, locations.u_scale_with_map),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_extrude_scale': new uniform.Uniform2f(context, locations.u_extrude_scale),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'radius': new uniform.Uniform1f(context, locations.radius),
            'stroke_width': new uniform.Uniform1f(context, locations.stroke_width),
            'stroke_color': new uniform.Uniform4f(context, locations.stroke_color),
            'blur': new uniform.Uniform1f(context, locations.blue),
            'opacity': new uniform.Uniform1f(context, locations.opacity),
            'stroke_opacity': new uniform.Uniform1f(context, locations.stroke_opacity)
        });
    };

    var fanVertex = "uniform mat4 u_matrix;\n" +
        "  uniform bool u_scale_with_map;\n" +
        "  uniform bool u_pitch_with_map;\n" +
        "  uniform vec2 u_extrude_scale;\n" +
        "  uniform lowp float u_device_pixel_ratio;\n" +
        "  uniform highp float u_camera_to_center_distance;\n" +
        "  attribute vec2 a_pos;\n" +
        "  varying vec3 v_data;\n" +
        "  uniform mediump float radius;\n" +
        "  uniform mediump float stroke_width;\n" +
        "  void main(void) {\n" +
        "    vec2 extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n" +
        "    vec2 circle_center = floor(a_pos * 0.5);\n" +
        "    if (u_pitch_with_map) {\n" +
        "      vec2 corner_position = circle_center;\n" +
        "      if (u_scale_with_map) {\n" +
        "        corner_position += extrude * (radius + stroke_width) * u_extrude_scale;\n" +
        "      } else {\n" +
        "        vec4 projected_center = u_matrix * vec4(circle_center, 0, 1);\n" +
        "        corner_position += extrude * (radius + stroke_width) * u_extrude_scale * (projected_center.w / u_camera_to_center_distance);\n" +
        "      }\n" +
        "\n" +
        "      gl_Position = u_matrix * vec4(corner_position, 0, 1);\n" +
        "    } else {\n" +
        "      gl_Position = u_matrix * vec4(circle_center, 0, 1);\n" +
        "\n" +
        "      if (u_scale_with_map) {\n" +
        "        gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * u_camera_to_center_distance;\n" +
        "      } else {\n" +
        "        gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * gl_Position.w;\n" +
        "      }\n" +
        "    }\n" +
        "    lowp float antialiasblur = 1.0 / u_device_pixel_ratio / (radius + stroke_width);\n" +
        "\n" +
        "    v_data = vec3(extrude.x, extrude.y, antialiasblur);\n" +
        "  }";

    var fanFrag = "precision mediump float;\n" +
        "  varying vec3 v_data;\n" +
        "  uniform highp vec4 color;\n" +
        "  uniform mediump float radius;\n" +
        "  uniform lowp float blur;\n" +
        "  uniform lowp float opacity;\n" +
        "  uniform highp vec4 stroke_color;\n" +
        "  uniform mediump float stroke_width;\n" +
        "  uniform lowp float stroke_opacity;\n" +
        "  uniform int quadrant;\n" +
        "  uniform bool border;\n" +
        "  uniform float start;\n" +
        "  uniform float end;\n" +
        "  uniform float gap;\n" +
        "  void main() {\n" +
        "    vec2 extrude = v_data.xy;\n" +
        "    float extrude_length = length(extrude);\n" +
        "\n" +
        "    lowp float antialiasblur = v_data.z;\n" +
        "    float antialiased_blur = -max(blur, antialiasblur);\n" +
        "\n" +
        "    // \n" +
        "    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n" +
        "    // \n" +
        "    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n" +
        "    antialiased_blur,\n" +
        "    0.0,\n" +
        "    extrude_length - radius / (radius + stroke_width)\n" +
        "    );\n" +
        "\n" +
        "    float tana = v_data.y/v_data.x;\n" +
        "    float opacity_fan = 0.0;\n" +
        "    if (quadrant == 1) {\n" +
        "      opacity_fan =  step(0.0, -tana) * step(0.0, v_data.x);\n" +
        "      if (border) {\n" +
        "        if ((v_data.y > -gap && v_data.x > start) || (v_data.x < gap && v_data.y < -end)) {\n" +
        "          color_t = 1.0;\n" +
        "        }\n" +
        "      }\n" +
        "    } else if (quadrant == 2) {\n" +
        "      opacity_fan =  step(0.0, tana) * step(0.0, -v_data.x);\n" +
        "      if (border) {\n" +
        "        if ((v_data.x > -gap && v_data.y < -start) || (v_data.y > -gap && v_data.x < -end)) {\n" +
        "          color_t = 1.0;\n" +
        "        }\n" +
        "      }\n" +
        "    } else if (quadrant == 3) {\n" +
        "      opacity_fan =  step(0.0, -tana) * step(0.0, -v_data.x);\n" +
        "      if (border) {\n" +
        "        if ((v_data.y < gap && v_data.x < -start) || (v_data.x > -gap && v_data.y > end)) {\n" +
        "          color_t = 1.0;\n" +
        "        }\n" +
        "      }\n" +
        "    } else {\n" +
        "      opacity_fan = step(0.0, tana) * step(0.0, v_data.x);\n" +
        "      if (border) {\n" +
        "        if ((v_data.x < gap && v_data.y > start) || (v_data.y < gap && v_data.x>end)) {\n" +
        "          color_t = 1.0;\n" +
        "        }\n" +
        "      }\n" +
        "    }\n" +
        "    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t) * opacity_fan;\n" +
        "  }";
    var fanUniforms = function (context, locations) {
        return ({
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_scale_with_map': new uniform.Uniform1i(context, locations.u_scale_with_map),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_extrude_scale': new uniform.Uniform2f(context, locations.u_extrude_scale),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'radius': new uniform.Uniform1f(context, locations.radius),
            'stroke_width': new uniform.Uniform1f(context, locations.stroke_width),
            'stroke_color': new uniform.Uniform4f(context, locations.stroke_color),
            'blur': new uniform.Uniform1f(context, locations.blue),
            'opacity': new uniform.Uniform1f(context, locations.opacity),
            'stroke_opacity': new uniform.Uniform1f(context, locations.stroke_opacity),
            'color': new uniform.Uniform4f(context, locations.color),
            'quadrant': new uniform.Uniform1i(context, locations.quadrant),
            'border': new uniform.Uniform1i(context, locations.border),
            'start': new uniform.Uniform1f(context, locations.start),
            'end': new uniform.Uniform1f(context, locations.end),
            'gap': new uniform.Uniform1f(context, locations.gap)
        });
    };

    var circlesVertex = "#define HAS_UNIFORM_u_stroke_color\n" +
        "#define HAS_UNIFORM_u_stroke_width\n" +
        "#define HAS_UNIFORM_u_opacity\n" +
        "#define HAS_UNIFORM_u_blur\n" +
        "#define HAS_UNIFORM_u_stroke_opacity\n" +
        "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "vec2 unpack_float(const float packedValue) {\n" +
        "    int packedIntValue = int(packedValue);\n" +
        "    int v0 = packedIntValue / 256;\n" +
        "    return vec2(v0, packedIntValue - v0 * 256);\n" +
        "}\n" +
        "\n" +
        "vec4 decode_color(const vec2 encodedColor) {\n" +
        "    return vec4(\n" +
        "    unpack_float(encodedColor[0]) / 255.0,\n" +
        "    unpack_float(encodedColor[1]) / 255.0\n" +
        "    );\n" +
        "}\n" +
        "\n" +
        "float unpack_mix_vec2(const vec2 packedValue, const float t) {\n" +
        "    return mix(packedValue[0], packedValue[1], t);\n" +
        "}\n" +
        "\n" +
        "vec4 unpack_mix_color(const vec4 packedColors, const float t) {\n" +
        "    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n" +
        "    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n" +
        "    return mix(minColor, maxColor, t);\n" +
        "}\n" +
        "\n" +
        "uniform mat4 u_matrix;\n" +
        "uniform bool u_scale_with_map;\n" +
        "uniform bool u_pitch_with_map;\n" +
        "uniform vec2 u_extrude_scale;\n" +
        "uniform lowp float u_device_pixel_ratio;\n" +
        "uniform highp float u_camera_to_center_distance;\n" +
        "\n" +
        "attribute vec2 a_pos;\n" +
        "\n" +
        "varying vec3 v_data;\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "uniform lowp float u_color_t;\n" +
        "attribute highp vec4 a_color;\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_radius\n" +
        "uniform lowp float u_radius_t;\n" +
        "attribute mediump vec2 a_radius;\n" +
        "varying mediump float radius;\n" +
        "#else\n" +
        "uniform mediump float u_radius;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_blur\n" +
        "uniform lowp float u_blur_t;\n" +
        "attribute lowp vec2 a_blur;\n" +
        "varying lowp float blur;\n" +
        "#else\n" +
        "uniform lowp float u_blur;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "uniform lowp float u_opacity_t;\n" +
        "attribute lowp vec2 a_opacity;\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_stroke_color\n" +
        "uniform lowp float u_stroke_color_t;\n" +
        "attribute highp vec4 a_stroke_color;\n" +
        "varying highp vec4 stroke_color;\n" +
        "#else\n" +
        "uniform highp vec4 u_stroke_color;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_stroke_width\n" +
        "uniform lowp float u_stroke_width_t;\n" +
        "attribute mediump vec2 a_stroke_width;\n" +
        "varying mediump float stroke_width;\n" +
        "#else\n" +
        "uniform mediump float u_stroke_width;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_stroke_opacity\n" +
        "uniform lowp float u_stroke_opacity_t;\n" +
        "attribute lowp vec2 a_stroke_opacity;\n" +
        "varying lowp float stroke_opacity;\n" +
        "#else\n" +
        "uniform lowp float u_stroke_opacity;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "void main(void) {\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_color\n" +
        "    color = unpack_mix_color(a_color, u_color_t);\n" +
        "    #else\n" +
        "    highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_radius\n" +
        "    radius = unpack_mix_vec2(a_radius, u_radius_t);\n" +
        "    #else\n" +
        "    mediump float radius = u_radius;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_blur\n" +
        "    blur = unpack_mix_vec2(a_blur, u_blur_t);\n" +
        "    #else\n" +
        "    lowp float blur = u_blur;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_opacity\n" +
        "    opacity = unpack_mix_vec2(a_opacity, u_opacity_t);\n" +
        "    #else\n" +
        "    lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_stroke_color\n" +
        "    stroke_color = unpack_mix_color(a_stroke_color, u_stroke_color_t);\n" +
        "    #else\n" +
        "    highp vec4 stroke_color = u_stroke_color;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_stroke_width\n" +
        "    stroke_width = unpack_mix_vec2(a_stroke_width, u_stroke_width_t);\n" +
        "    #else\n" +
        "    mediump float stroke_width = u_stroke_width;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifndef HAS_UNIFORM_u_stroke_opacity\n" +
        "    stroke_opacity = unpack_mix_vec2(a_stroke_opacity, u_stroke_opacity_t);\n" +
        "    #else\n" +
        "    lowp float stroke_opacity = u_stroke_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    // unencode the extrusion vector that we snuck into the a_pos vector\n" +
        "    vec2 extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n" +
        "\n" +
        "    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n" +
        "    // in extrusion data\n" +
        "    vec2 circle_center = floor(a_pos * 0.5);\n" +
        "    if (u_pitch_with_map) {\n" +
        "        vec2 corner_position = circle_center;\n" +
        "        if (u_scale_with_map) {\n" +
        "            corner_position += extrude * (radius + stroke_width) * u_extrude_scale;\n" +
        "        } else {\n" +
        "            // Pitching the circle with the map effectively scales it with the map\n" +
        "            // To counteract the effect for pitch-scale: viewport, we rescale the\n" +
        "            // whole circle based on the pitch scaling effect at its central point\n" +
        "            vec4 projected_center = u_matrix * vec4(circle_center, 0, 1);\n" +
        "            corner_position += extrude * (radius + stroke_width) * u_extrude_scale * (projected_center.w / u_camera_to_center_distance);\n" +
        "        }\n" +
        "\n" +
        "        gl_Position = u_matrix * vec4(corner_position, 2, 1);\n" +
        "    } else {\n" +
        "        gl_Position = u_matrix * vec4(circle_center, 2, 1);\n" +
        "\n" +
        "        if (u_scale_with_map) {\n" +
        "            gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * u_camera_to_center_distance;\n" +
        "        } else {\n" +
        "            gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * gl_Position.w;\n" +
        "        }\n" +
        "    }\n" +
        "\n" +
        "        // This is a minimum blur distance that serves as a faux-antialiasing for\n" +
        "        // the circle. since blur is a ratio of the circle's size and the intent is\n" +
        "        // to keep the blur at roughly 1px, the two are inversely related.\n" +
        "        lowp float antialiasblur = 1.0 / u_device_pixel_ratio / (radius + stroke_width);\n" +
        "\n" +
        "    v_data = vec3(extrude.x, extrude.y, antialiasblur);\n" +
        "}";

    var circlesFrag = "#define HAS_UNIFORM_u_stroke_color\n" +
        "#define HAS_UNIFORM_u_stroke_width\n" +
        "#define HAS_UNIFORM_u_opacity\n" +
        "#define HAS_UNIFORM_u_blur\n" +
        "#define HAS_UNIFORM_u_stroke_opacity\n" +
        "#ifdef GL_ES\n" +
        "precision mediump float;\n" +
        "#else\n" +
        "\n" +
        "#if !defined(lowp)\n" +
        "#define lowp\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(mediump)\n" +
        "#define mediump\n" +
        "#endif\n" +
        "\n" +
        "#if !defined(highp)\n" +
        "#define highp\n" +
        "#endif\n" +
        "\n" +
        "#endif\n" +
        "\n" +
        "varying vec3 v_data;\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_color\n" +
        "varying highp vec4 color;\n" +
        "#else\n" +
        "uniform highp vec4 u_color;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_radius\n" +
        "varying mediump float radius;\n" +
        "#else\n" +
        "uniform mediump float u_radius;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_blur\n" +
        "varying lowp float blur;\n" +
        "#else\n" +
        "uniform lowp float u_blur;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_opacity\n" +
        "varying lowp float opacity;\n" +
        "#else\n" +
        "uniform lowp float u_opacity;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_stroke_color\n" +
        "varying highp vec4 stroke_color;\n" +
        "#else\n" +
        "uniform highp vec4 u_stroke_color;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_stroke_width\n" +
        "varying mediump float stroke_width;\n" +
        "#else\n" +
        "uniform mediump float u_stroke_width;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "#ifndef HAS_UNIFORM_u_stroke_opacity\n" +
        "#ifndef HAS_UNIFORM_u_stroke_opacity\n" +
        "varying lowp float stroke_opacity;\n" +
        "#else\n" +
        "uniform lowp float u_stroke_opacity;\n" +
        "#endif\n" +
        "\n" +
        "\n" +
        "void main() {\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_color\n" +
        "    highp vec4 color = u_color;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_radius\n" +
        "    mediump float radius = u_radius;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_blur\n" +
        "    lowp float blur = u_blur;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_opacity\n" +
        "    lowp float opacity = u_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_stroke_color\n" +
        "    highp vec4 stroke_color = u_stroke_color;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_stroke_width\n" +
        "    mediump float stroke_width = u_stroke_width;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    #ifdef HAS_UNIFORM_u_stroke_opacity\n" +
        "    lowp float stroke_opacity = u_stroke_opacity;\n" +
        "    #endif\n" +
        "\n" +
        "\n" +
        "    vec2 extrude = v_data.xy;\n" +
        "    float extrude_length = length(extrude);\n" +
        "\n" +
        "    lowp float antialiasblur = v_data.z;\n" +
        "    float antialiased_blur = -max(blur, antialiasblur);\n" +
        "\n" +
        "    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n" +
        "\n" +
        "    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n" +
        "    antialiased_blur,\n" +
        "    0.0,\n" +
        "    extrude_length - radius / (radius + stroke_width)\n" +
        "    );\n" +
        "\n" +
        "    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t);\n" +
        "\n" +
        "}";

    var circleUniforms = function (context, locations) {
        return ({
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_scale_with_map': new uniform.Uniform1i(context, locations.u_scale_with_map),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_extrude_scale': new uniform.Uniform2f(context, locations.u_extrude_scale),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)
        });
    };
    var basicFillV = "attribute vec2 a_pos;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    void main() {\n" +
        "        gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n" +
        "    }";

    var basicFillF = "precision mediump float;\n" +
        "    uniform highp vec4 u_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    void main() {\n" +
        "        gl_FragColor = u_color * u_opacity;\n" +
        "    }";

    var basicFillUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_color': new uniform.Uniform4f(context, locations.u_color),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity)
        });
    };

    var basicFillImageV = "attribute vec4 a_pos;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    varying vec2 v_tex;\n" +
        "    void main() {\n" +
        "        v_tex = a_pos.zw;\n" +
        "        gl_Position = u_matrix * vec4(a_pos.xy, 0.0, 1.0);\n" +
        "    }";

    var basicFillImageF = "precision mediump float;\n" +
        "    uniform sampler2D u_texture;\n" +
        "    varying vec2 v_tex;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    void main() {\n" +
        "        gl_FragColor = texture2D(u_texture, v_tex) * u_opacity;\n" +
        "    }";

    var basicFillImageUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity)
        });
    };

    //------------------------------------------------------------------------------------------------------------------, 
    // todo
    var lineVertex2 = "precision highp float;\n" +
        "\n" +
        "    #define scale 0.01587301\n" +
        "    // #define scale 0.007936508\n" +
        "\n" +
        "    attribute vec2 a_pos;\n" +
        "    attribute vec4 a_data;\n" +
        "    attribute vec2 a_normal;\n" +
        "\n" +
        "    uniform mat4 u_matrix;\n" +
        "    uniform mediump float u_ratio;\n" +
        "    uniform vec2 u_units_to_pixels;\n" +
        "\n" +
        "    varying vec2 v_normal;\n" +
        "    varying vec2 v_width2;\n" +
        "    varying float v_gamma_scale;\n" +
        "    varying highp float v_linesofar;\n" +
        "\n" +
        "    uniform highp vec4 u_color;\n" +
        "    uniform lowp float u_blur;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform mediump float u_gapwidth;\n" +
        "    uniform lowp float u_offset;\n" +
        "    uniform mediump float u_width;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 color = u_color;\n" +
        "        lowp float blur = u_blur;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        mediump float gapwidth = u_gapwidth;\n" +
        "        lowp float offset = u_offset;\n" +
        "        mediump float width = u_width;\n" +
        "\n" +
        "        // the distance over which the line edge fades out.\n" +
        "        // Retina devices need a smaller distance to avoid aliasing.\n" +
        "        float ANTIALIASING = 0.5;\n" +
        "\n" +
        "        vec2 a_extrude = a_data.xy - 128.0;\n" +
        "        float a_direction = mod(a_data.z, 4.0) - 1.0;\n" +
        "\n" +
        "        v_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0;\n" +
        "\n" +
        "        vec2 pos = a_pos;\n" +
        "\n" +
        "        mediump vec2 normal = a_normal;\n" +
        "        normal.y = normal.y * 2.0 - 1.0;\n" +
        "        v_normal = normal;\n" +
        "\n" +
        "        // these transformations used to be applied in the JS and native code bases.\n" +
        "        // moved them into the shader for clarity and simplicity.\n" +
        "        gapwidth = gapwidth / 2.0;\n" +
        "        float halfwidth = width / 2.0;\n" +
        "        offset = -1.0 * offset;\n" +
        "\n" +
        "        float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n" +
        "        float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n" +
        "\n" +
        "        // Scale the extrusion vector down to a normal and then up by the line width\n" +
        "        // of this vertex.\n" +
        "        mediump vec2 dist = outset * a_extrude * scale;\n" +
        "\n" +
        "        // Calculate the offset when drawing a line that is to the side of the actual line.\n" +
        "        // We do this by creating a vector that points towards the extrude, but rotate\n" +
        "        // it when we're drawing round end points (a_direction = -1 or 1) since their\n" +
        "        // extrude vector points in another direction.\n" +
        "        mediump float u = 0.5 * a_direction;\n" +
        "        mediump float t = 1.0 - abs(u);\n" +
        "        mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n" +
        "\n" +
        "        vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n" +
        "        gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n" +
        "\n" +
        "        // calculate how much the perspective view squishes or stretches the extrude\n" +
        "        float extrude_length_without_perspective = length(dist);\n" +
        "        float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);\n" +
        "        v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n" +
        "\n" +
        "        v_width2 = vec2(outset, inset);\n" +
        "    }";
    var lineFragment2 = "precision mediump float;\n" +
        "\n" +
        "    varying vec2 v_width2;\n" +
        "    varying vec2 v_normal;\n" +
        "    varying float v_gamma_scale;\n" +
        "    uniform highp vec4 u_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "\n" +
        "    void main() {\n" +
        "\n" +
        "\n" +
        "        highp vec4 color = u_color;\n" +
        "        lowp float blur = 0.0;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        lowp float u_device_pixel_ratio = 1.0;\n" +
        "\n" +
        "        float dist = length(v_normal) * v_width2.s;\n" +
        "\n" +
        "        float blur2 = (blur + 1.0 / u_device_pixel_ratio) * v_gamma_scale;\n" +
        "        float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n" +
        "        gl_FragColor = color * (alpha * opacity);\n" +
        "        // gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n" +
        "    }";

    var basicLineUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_ratio': new uniform.Uniform1f(context, locations.u_ratio),
            'u_units_to_pixels': new uniform.Uniform2f(context, locations.u_units_to_pixels),
            'u_color': new uniform.Uniform4f(context, locations.u_color),
            'u_blur': new uniform.Uniform1f(context, locations.u_blur),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_gapwidth': new uniform.Uniform1f(context, locations.u_gapwidth),
            'u_offset': new uniform.Uniform1f(context, locations.u_offset),
            'u_width': new uniform.Uniform1f(context, locations.u_width)
        });
    };

    var lineDashVertexSimplify = "#define scale 0.015873016\n" +
        "  #define LINE_DISTANCE_SCALE 2.0\n" +
        "  attribute vec2 a_pos;\n" +
        "  attribute vec4 a_data;\n" +
        "  attribute vec2 a_normal;\n" +
        "\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform mediump float u_ratio;\n" +
        "  uniform vec2 u_patternscale_a;\n" +
        "  uniform float u_tex_y_a;\n" +
        "  uniform vec2 u_patternscale_b;\n" +
        "  uniform float u_tex_y_b;\n" +
        "  uniform vec2 u_units_to_pixels;\n" +
        "\n" +
        "  varying vec2 v_normal;\n" +
        "  varying vec2 v_width2;\n" +
        "  varying vec2 v_tex_a;\n" +
        "  varying vec2 v_tex_b;\n" +
        "  varying float v_gamma_scale;\n" +
        "\n" +
        "  uniform highp vec4 u_color;\n" +
        "  uniform lowp float u_blur;\n" +
        "  uniform lowp float u_opacity;\n" +
        "  uniform mediump float u_gapwidth;\n" +
        "  uniform lowp float u_offset;\n" +
        "  uniform mediump float u_width;\n" +
        "  uniform lowp float u_floorwidth;\n" +
        "\n" +
        "  void main() {\n" +
        "    highp vec4 color = u_color;\n" +
        "    lowp float blur = u_blur;\n" +
        "    lowp float opacity = u_opacity;\n" +
        "    mediump float gapwidth = u_gapwidth;\n" +
        "    lowp float offset = u_offset;\n" +
        "    mediump float width = u_width;\n" +
        "    lowp float floorwidth = u_floorwidth;\n" +
        "\n" +
        "    float ANTIALIASING = 1.0 / 1.0 / 2.0;\n" +
        "\n" +
        "    vec2 a_extrude = a_data.xy - 128.0;\n" +
        "    float a_direction = mod(a_data.z, 4.0) - 1.0;\n" +
        "    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n" +
        "\n" +
        "    vec2 pos = a_pos;\n" +
        "\n" +
        "    // x is 1 if it's a round cap, 0 otherwise\n" +
        "    // y is 1 if the normal points up, and -1 if it points down\n" +
        "    // We store these in the least significant bit of position\n" +
        "    mediump vec2 normal = a_normal;\n" +
        "    normal.y = normal.y * 2.0 - 1.0;\n" +
        "    v_normal = normal;\n" +
        "\n" +
        "    // these transformations used to be applied in the JS and native code bases.\n" +
        "    // moved them into the shader for clarity and simplicity.\n" +
        "    gapwidth = gapwidth / 2.0;\n" +
        "    float halfwidth = width / 2.0;\n" +
        "    offset = -1.0 * offset;\n" +
        "\n" +
        "    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n" +
        "    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n" +
        "\n" +
        "    // Scale the extrusion vector down to a normal and then up by the line width\n" +
        "    // of this vertex.\n" +
        "    mediump vec2 dist =outset * a_extrude * scale;\n" +
        "\n" +
        "    // Calculate the offset when drawing a line that is to the side of the actual line.\n" +
        "    // We do this by creating a vector that points towards the extrude, but rotate\n" +
        "    // it when we're drawing round end points (a_direction = -1 or 1) since their\n" +
        "    // extrude vector points in another direction.\n" +
        "    mediump float u = 0.5 * a_direction;\n" +
        "    mediump float t = 1.0 - abs(u);\n" +
        "    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n" +
        "\n" +
        "    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n" +
        "    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n" +
        "\n" +
        "    // calculate how much the perspective view squishes or stretches the extrude\n" +
        "    float extrude_length_without_perspective = length(dist);\n" +
        "    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);\n" +
        "    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n" +
        "\n" +
        "    v_tex_a = vec2(a_linesofar * u_patternscale_a.x / floorwidth, normal.y * u_patternscale_a.y + u_tex_y_a);\n" +
        "    v_tex_b = vec2(a_linesofar * u_patternscale_b.x / floorwidth, normal.y * u_patternscale_b.y + u_tex_y_b);\n" +
        "\n" +
        "    v_width2 = vec2(outset, inset);\n" +
        "  }";
    var lineDashFragSimplify = "precision mediump float;\n" +
        "\n" +
        "  uniform sampler2D u_image;\n" +
        "  uniform float u_sdfgamma;\n" +
        "  uniform float u_mix;\n" +
        "\n" +
        "  varying vec2 v_normal;\n" +
        "  varying vec2 v_width2;\n" +
        "  varying vec2 v_tex_a;\n" +
        "  varying vec2 v_tex_b;\n" +
        "  varying float v_gamma_scale;\n" +
        "\n" +
        "  uniform highp vec4 u_color;\n" +
        "  uniform lowp float u_blur;\n" +
        "  uniform lowp float u_opacity;\n" +
        "  uniform mediump float u_width;\n" +
        "  uniform lowp float u_floorwidth;\n" +
        "\n" +
        "  void main() {\n" +
        "\n" +
        "    highp vec4 color = u_color;\n" +
        "    lowp float blur = u_blur;\n" +
        "    lowp float opacity = u_opacity;\n" +
        "    mediump float width = u_width;\n" +
        "    lowp float floorwidth = u_floorwidth;\n" +
        "\n" +
        "    // Calculate the distance of the pixel from the line in pixels.\n" +
        "    float dist = length(v_normal) * v_width2.s;\n" +
        "\n" +
        "    // Calculate the antialiasing fade factor. This is either when fading in\n" +
        "    // the line in case of an offset line (v_width2.t) or when fading out\n" +
        "    // (v_width2.s)\n" +
        "    float blur2 = (blur + 1.0 / 1.0) * v_gamma_scale;\n" +
        "    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n" +
        "\n" +
        "    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n" +
        "    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n" +
        "    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n" +
        "    alpha *= smoothstep(0.5 - u_sdfgamma / floorwidth, 0.5 + u_sdfgamma / floorwidth, sdfdist);\n" +
        "\n" +
        "    gl_FragColor = color * (alpha * opacity);\n" +
        "\n" +
        "    #ifdef OVERDRAW_INSPECTOR\n" +
        "    gl_FragColor = vec4(1.0);\n" +
        "    #endif\n" +
        "  }";

    var basicLineDashUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_ratio': new uniform.Uniform1f(context, locations.u_ratio),
            'u_units_to_pixels': new uniform.Uniform2f(context, locations.u_units_to_pixels),
            'u_patternscale_a': new uniform.Uniform2f(context, locations.u_patternscale_a),
            'u_patternscale_b': new uniform.Uniform2f(context, locations.u_patternscale_b),
            'u_tex_y_a': new uniform.Uniform1f(context, locations.u_tex_y_a),
            'u_tex_y_b': new uniform.Uniform1f(context, locations.u_tex_y_b),
            'u_color': new uniform.Uniform4f(context, locations.u_color),
            'u_blur': new uniform.Uniform1f(context, locations.u_blur),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_gapwidth': new uniform.Uniform1f(context, locations.u_gapwidth),
            'u_offset': new uniform.Uniform1f(context, locations.u_offset),
            'u_width': new uniform.Uniform1f(context, locations.u_width),
            'u_floorwidth': new uniform.Uniform1f(context, locations.u_floorwidth),
            'u_image': new uniform.Uniform1i(context, locations.u_image),
            'u_sdfgamma': new uniform.Uniform1f(context, locations.u_sdfgamma),
            'u_mix': new uniform.Uniform1f(context, locations.u_mix)

        });
    };

    /**
     * uniform
     * @param context
     * @param locations
     */
    var fillExtrusionUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_lightpos': new uniform.Uniform3f(context, locations.u_lightpos),
            'u_lightintensity': new uniform.Uniform1f(context, locations.u_lightintensity),
            'u_lightcolor': new uniform.Uniform3f(context, locations.u_lightcolor),
            'u_vertical_gradient': new uniform.Uniform1f(context, locations.u_vertical_gradient),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_height_image': new uniform.Uniform1i(context, locations.u_height_image),
            'u_min_height': new uniform.Uniform1f(context, locations.u_min_height),
            'u_delta_height': new uniform.Uniform1f(context, locations.u_delta_height)
        });
    };

    var multiPointsVertex = " attribute vec2 a_pos;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    void main() {\n" +
        "        gl_Position = u_matrix * vec4(a_pos.xy,0.0, 1.0);\n" +
        "        gl_PointSize = 30.0;\n" +
        "    }";

    var multiPointsFrag = "precision mediump float;\n" +
        "    void main() {\n" +
        "        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" +
        "    }";

    var multiPointsUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)
        });
    };

    var imageVertex = "attribute vec2 a_pos;\n" +
        "    attribute vec4 a_data;\n" +
        "\n" +
        "    uniform highp float u_size;\n" +
        "    uniform highp float u_camera_to_center_distance;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    uniform mat4 u_label_plane_matrix;\n" +
        "    uniform mat4 u_coord_matrix;\n" +
        "    uniform bool u_pitch_with_map;\n" +
        "    uniform vec2 u_texsize;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform bool u_rotate_symbol;\n" +
        "    uniform float u_radian;\n" +
        "    uniform mat4 u_modelMatrix;\n" +
        "\n" +
        "    varying vec2 v_tex;\n" +
        "    void main() {\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        vec2 a_offset = a_data.xy;\n" +
        "        vec2 a_tex = a_data.zw;\n" +
        "        float size = u_size;\n" +
        "        vec4 projectedPoint = u_matrix * vec4(a_pos, 10.0, 1);\n" +
        "        highp float camera_to_anchor_distance = projectedPoint.w;\n" +
        "\n" +
        "        highp float distance_ratio = u_pitch_with_map ?\n" +
        "        camera_to_anchor_distance / u_camera_to_center_distance\n" +
        "        :u_camera_to_center_distance / camera_to_anchor_distance;\n" +
        "        highp float perspective_ratio = clamp(0.5 + 0.5 * distance_ratio, 0.0, 4.0);\n" +
        "        size *= perspective_ratio;\n" +
        "        float fontScale = size;\n" +
        "        highp float symbol_rotation = 0.0;\n" +
        "        if (u_rotate_symbol) {\n" +
        "            symbol_rotation = u_radian;\n" +
        "        }\n" +
        "    highp float angle_sin = sin(symbol_rotation);\n" +
        "    highp float angle_cos = cos(symbol_rotation);\n" +
        "    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n" +
        "        vec4 projected_pos = u_label_plane_matrix * vec4(a_pos, 0.0, 1.0);\n" +
        "        vec4 glP = u_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n" +
        "        gl_Position = u_modelMatrix * glP;\n" +
        "        v_tex = a_tex / u_texsize;\n" +
        "    }";

    var imageFrag = "precision mediump float;\n" +
        "    uniform sampler2D u_texture;\n" +
        "    varying vec2 v_tex;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    void main() {\n" +
        "        gl_FragColor = texture2D(u_texture, v_tex) * u_opacity;\n" +
        "    }";

    var imageUniforms = function (context, locations) {
        return ({
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_label_plane_matrix': new uniform.UniformMatrix4f(context, locations.u_label_plane_matrix),
            'u_coord_matrix': new uniform.UniformMatrix4f(context, locations.u_coord_matrix),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_rotate_symbol': new uniform.Uniform1i(context, locations.u_rotate_symbol),
            'u_radian': new uniform.Uniform1f(context, locations.u_radian),
            'u_modelMatrix': new uniform.UniformMatrix4f(context, locations.u_modelMatrix)
        });
    };

    var textVertex = "attribute vec2 a_pos;\n" +
        "    attribute vec4 a_data;\n" +
        "\n" +
        "    uniform highp float u_size;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    uniform mat4 u_label_plane_matrix;\n" +
        "    uniform mat4 u_coord_matrix;\n" +
        "    uniform bool u_pitch_with_map;\n" +
        "    uniform highp float u_camera_to_center_distance;\n" +
        "    uniform vec2 u_texsize;\n" +
        "    varying vec2 v_data0;\n" +
        "\n" +
        "    uniform highp vec4 u_fill_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform bool u_rotate_symbol;\n" +
        "    uniform float u_radian;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        vec2 a_offset = a_data.xy;\n" +
        "        vec2 a_tex = a_data.zw;\n" +
        "        float size = u_size;\n" +
        "\n" +
        "        vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n" +
        "        highp float camera_to_anchor_distance = projectedPoint.w;\n" +
        "        highp float distance_ratio = u_pitch_with_map ?\n" +
        "        camera_to_anchor_distance / u_camera_to_center_distance :\n" +
        "        u_camera_to_center_distance / camera_to_anchor_distance;\n" +
        "        highp float perspective_ratio = clamp(\n" +
        "        0.5 + 0.5 * distance_ratio,\n" +
        "        0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n" +
        "        4.0);\n" +
        "        size *= perspective_ratio;\n" +
        "        float fontScale = size / 24.0;\n" +
        "        highp float symbol_rotation = 0.0;\n" +
        "        if (u_rotate_symbol) {\n" +
        "            symbol_rotation = u_radian;\n" +
        "        }\n" +
        "    highp float angle_sin = sin(symbol_rotation);\n" +
        "    highp float angle_cos = cos(symbol_rotation);\n" +
        "    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n" +
        "\n" +
        "        vec4 projected_pos = u_label_plane_matrix * vec4(a_pos, 0.0, 1.0);\n" +
        "        gl_Position = u_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n" +
        "        float gamma_scale = gl_Position.w;\n" +
        "\n" +
        "        vec2 tex = a_tex / u_texsize;\n" +
        "        float interpolated_fade_opacity = 1.0;\n" +
        "\n" +
        "        v_data0 = vec2(tex.x, tex.y);\n" +
        "    }";

    var textFrag = "precision mediump float;\n" +
        "    #define SDF_PX 8.0\n" +
        "    uniform sampler2D u_texture;\n" +
        "    uniform highp float u_gamma_scale;\n" +
        "\n" +
        "    varying vec2 v_data0;\n" +
        "\n" +
        "    uniform highp vec4 u_fill_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform highp float u_size;\n" +
        "    uniform highp vec4 u_halo_color;\n" +
        "    uniform lowp float u_halo_width;\n" +
        "    uniform lowp float u_halo_blur;\n" +
        "    uniform bool u_is_halo;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "\n" +
        "        float EDGE_GAMMA = 0.105;\n" +
        "\n" +
        "        vec2 tex = v_data0.xy;\n" +
        "        float gamma_scale = 1.0;\n" +
        "        float size = u_size;\n" +
        "        float fade_opacity = 1.0;\n" +
        "        float fontScale = size / 24.0;\n" +
        "\n" +
        "        lowp vec4 color = fill_color;\n" +
        "        highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);\n" +
        "        lowp float buff = (256.0 - 64.0) / 256.0;\n" +
        "        if (u_is_halo) {\n" +
        "            color = u_halo_color;\n" +
        "            gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);\n" +
        "            buff = (6.0 - u_halo_width / fontScale) / SDF_PX;\n" +
        "        }\n" +
        "        lowp float dist = texture2D(u_texture, tex).a;\n" +
        "        highp float gamma_scaled = gamma * gamma_scale;\n" +
        "        highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n" +
        "\n" +
        "        gl_FragColor = color * (alpha * opacity * fade_opacity);\n" +
        "    }";

    var ztTextVertex = "attribute vec2 a_pos;\n" +
        "    attribute vec4 a_data;\n" +
        "\n" +
        "    uniform highp float u_size;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    uniform mat4 u_label_plane_matrix;\n" +
        "    uniform mat4 u_coord_matrix;\n" +
        "    uniform bool u_pitch_with_map;\n" +
        "    uniform highp float u_camera_to_center_distance;\n" +
        "    uniform vec2 u_texsize;\n" +
        "    varying vec2 v_data0;\n" +
        "\n" +
        "    uniform highp vec4 u_fill_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform bool u_rotate_symbol;\n" +
        "    uniform float u_radian;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        vec2 a_offset = a_data.xy;\n" +
        "        vec2 a_tex = a_data.zw;\n" +
        "        float size = u_size;\n" +
        "\n" +
        "        vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n" +
        "        highp float camera_to_anchor_distance = projectedPoint.w;\n" +
        "        highp float distance_ratio = u_pitch_with_map ?\n" +
        "        camera_to_anchor_distance / u_camera_to_center_distance :\n" +
        "        u_camera_to_center_distance / camera_to_anchor_distance;\n" +
        "        highp float perspective_ratio = clamp(\n" +
        "        0.5 + 0.5 * distance_ratio,\n" +
        "        0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n" +
        "        4.0);\n" +
        "        size *= perspective_ratio;\n" +
        "        float fontScale = size / 96.0;\n" +
        "        highp float symbol_rotation = 0.0;\n" +
        "        if (u_rotate_symbol) {\n" +
        "            symbol_rotation = u_radian;\n" +
        "        }\n" +
        "    highp float angle_sin = sin(symbol_rotation);\n" +
        "    highp float angle_cos = cos(symbol_rotation);\n" +
        "    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n" +
        "\n" +
        "        vec4 projected_pos = u_label_plane_matrix * vec4(a_pos, 0.0, 1.0);\n" +
        "        gl_Position = u_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n" +
        "        float gamma_scale = gl_Position.w;\n" +
        "\n" +
        "        vec2 tex = a_tex / u_texsize;\n" +
        "        float interpolated_fade_opacity = 1.0;\n" +
        "\n" +
        "        v_data0 = vec2(tex.x, tex.y);\n" +
        "    }";

    var ztTextFrag = "precision mediump float;\n" +
        "    #define SDF_PX 8.0\n" +
        "    uniform sampler2D u_texture;\n" +
        "    uniform highp float u_gamma_scale;\n" +
        "\n" +
        "    varying vec2 v_data0;\n" +
        "\n" +
        "    uniform highp vec4 u_fill_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    uniform highp float u_size;\n" +
        "    uniform highp vec4 u_halo_color;\n" +
        "    uniform lowp float u_halo_width;\n" +
        "    uniform lowp float u_halo_blur;\n" +
        "    uniform bool u_is_halo;\n" +
        "    uniform lowp float u_buff;\n" +
        "\n" +
        "    void main() {\n" +
        "        highp vec4 fill_color = u_fill_color;\n" +
        "        lowp float opacity = u_opacity;\n" +
        "        lowp float buff = u_buff;\n" +
        "\n" +
        "        float EDGE_GAMMA = 0.105;\n" +
        "\n" +
        "        vec2 tex = v_data0.xy;\n" +
        "        float gamma_scale = 1.0;\n" +
        "        float size = u_size;\n" +
        "        float fade_opacity = 1.0;\n" +
        "        float fontScale = size / 96.0;\n" +
        "\n" +
        "        lowp vec4 color = fill_color;\n" +
        "        highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);\n" +
        "        // lowp float buff = 0.45; //(256.0 - 64.0) / 256.0;\n" +
        "        lowp float dist = texture2D(u_texture, tex).a;\n" +
        "        highp float gamma_scaled = gamma * gamma_scale;\n" +
        "        highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n" +
        "\n" +
        "        gl_FragColor = color * (alpha * opacity * fade_opacity);\n" +
        "        // gl_FragColor = vec4(dist/255.0, dist/255.0, dist/255.0, 1.0);\n" +
        "    }";

    var textUniforms = function (context, locations) {
        return ({
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_label_plane_matrix': new uniform.UniformMatrix4f(context, locations.u_label_plane_matrix),
            'u_coord_matrix': new uniform.UniformMatrix4f(context, locations.u_coord_matrix),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_fill_color': new uniform.Uniform4f(context, locations.u_fill_color),
            'u_gamma_scale': new uniform.Uniform1f(context, locations.u_gamma_scale),
            'u_rotate_symbol': new uniform.Uniform1i(context, locations.u_rotate_symbol),
            'u_radian': new uniform.Uniform1f(context, locations.u_radian),
            'u_halo_color': new uniform.Uniform4f(context, locations.u_halo_color),
            'u_halo_width': new uniform.Uniform1f(context, locations.u_halo_width),
            'u_halo_blur': new uniform.Uniform1f(context, locations.u_halo_blur),
            'u_is_halo': new uniform.Uniform1i(context, locations.u_is_halo)
        });
    };

    var ztTextUniforms = function (context, locations) {
        return ({
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_label_plane_matrix': new uniform.UniformMatrix4f(context, locations.u_label_plane_matrix),
            'u_coord_matrix': new uniform.UniformMatrix4f(context, locations.u_coord_matrix),
            'u_pitch_with_map': new uniform.Uniform1i(context, locations.u_pitch_with_map),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_fill_color': new uniform.Uniform4f(context, locations.u_fill_color),
            'u_gamma_scale': new uniform.Uniform1f(context, locations.u_gamma_scale),
            'u_rotate_symbol': new uniform.Uniform1i(context, locations.u_rotate_symbol),
            'u_radian': new uniform.Uniform1f(context, locations.u_radian),
            'u_halo_color': new uniform.Uniform4f(context, locations.u_halo_color),
            'u_halo_width': new uniform.Uniform1f(context, locations.u_halo_width),
            'u_halo_blur': new uniform.Uniform1f(context, locations.u_halo_blur),
            'u_is_halo': new uniform.Uniform1i(context, locations.u_is_halo),
            'u_buff': new uniform.Uniform1f(context, locations.u_buff)
        });
    };

    var arcVertex = "attribute vec3 a_pos;\n" +
        "  attribute vec3 source;\n" +
        "  attribute vec3 target;\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform vec2 u_units_to_pixels;\n" +
        "  uniform float u_device_pixel_ratio;\n" +
        "\n" +
        "  uniform float width;\n" +
        "  uniform float height;\n" +
        "  uniform float tilts;\n" +
        "  uniform float numSegments;\n" +
        "\n" +
        "  float paraboloid(vec3 source, vec3 target, float ratio) {\n" +
        "    vec3 delta = target - source;\n" +
        "    float dh = length(delta.xy) * height;\n" +
        "    float unitZ = delta.z / dh;\n" +
        "    float p2 = unitZ * unitZ + 1.0;\n" +
        "    float dir = step(delta.z, 0.0);\n" +
        "    float z0 = mix(source.z, target.z, dir);\n" +
        "    float r = mix(ratio, 1.0 - ratio, dir);\n" +
        "    return sqrt(r * (p2 - r)) * dh + z0;\n" +
        "  }\n" +
        "  vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n" +
        "    vec2 dir_screenspace = normalize(line_clipspace);\n" +
        "    dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n" +
        "    return dir_screenspace * offset_direction * width;\n" +
        "  }\n" +
        "\n" +
        "  float getSegmentRatio(float index) {\n" +
        "    return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n" +
        "  }\n" +
        "\n" +
        "  vec3 getPos(vec3 source, vec3 target, float segmentRatio) {\n" +
        "    float z = paraboloid(source, target, segmentRatio);\n" +
        "    float tiltAngle = radians(tilts);\n" +
        "    vec2 tiltDirection = normalize(target.xy - source.xy);\n" +
        "    vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n" +
        "    return vec3(mix(source.xy, target.xy, segmentRatio) + tilt,z * cos(tiltAngle));\n" +
        "  }\n" +
        "\n" +
        "  vec2 project_pixel_size_to_clipspace(vec2 pixels) {\n" +
        "    vec2 offset = pixels / u_units_to_pixels * u_device_pixel_ratio * 2.0;\n" +
        "    return offset;\n" +
        "  }\n" +
        "\n" +
        "  void main(void) {\n" +
        "    float segmentIndex = a_pos.x;\n" +
        "    float segmentRatio = getSegmentRatio(segmentIndex);\n" +
        "    float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n" +
        "    float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n" +
        "\n" +
        "    vec3 currPos = getPos(source, target, segmentRatio);\n" +
        "    vec3 nextPos = getPos(source, target, nextSegmentRatio);\n" +
        "    vec4 curr = u_matrix * vec4(currPos, 1.0);\n" +
        "    vec4 next = u_matrix * vec4(nextPos, 1.0);\n" +
        "\n" +
        "    float widthPixels = width;\n" +
        "\n" +
        "    vec3 offset = vec3(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_pos.y, widthPixels), 0.0);\n" +
        "    gl_Position = curr + vec4(offset.xy, 0.0, 0.0);\n" +
        "  }";

    var arcFrag = "precision highp float;\n" +
        "  uniform vec4 color;\n" +
        "  uniform float opacity;\n" +
        "  void main(void) {\n" +
        "    gl_FragColor = vec4(color.xyz, opacity);\n" +
        "  }";

    var arcUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'height': new uniform.Uniform1f(context, locations.height),
            'tilts': new uniform.Uniform1f(context, locations.tilts),
            'numSegments': new uniform.Uniform1f(context, locations.numSegments),
            'width': new uniform.Uniform1f(context, locations.width),
            'u_units_to_pixels': new uniform.Uniform2f(context, locations.u_units_to_pixels),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'color': new uniform.Uniform4f(context, locations.color),
            'opacity': new uniform.Uniform1f(context, locations.opacity)
        });
    };

    var multiFillV = "attribute vec2 a_pos;\n" +
        "    attribute vec4 a_color;\n" +
        "    uniform mat4 u_matrix;\n" +
        "    varying vec4 v_color;\n" +
        "    void main() {\n" +
        "        gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n" +
        "        v_color = a_color;\n" +
        "    }";

    var multiFillF = "precision mediump float;\n" +
        "    varying vec4 v_color;\n" +
        "    uniform lowp float u_opacity;\n" +
        "    void main() {\n" +
        "        gl_FragColor = v_color * u_opacity;\n" +
        "    }";

    var multiFillUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity)
        });
    };

    // , 
    exports.clippingMask = {
        vertexSource: clippingMaskVert,
        fragmentSource: clippingMaskFrag
    };

    exports.background = {
        vertexSource: backgroundVert,
        fragmentSource: backgroundFrag
    };

    exports.fill = {
        vertexSource: fillVertex,
        fragmentSource: fillFrag
    };
    exports.fillExtrusion = {
        vertexSource: fillExtrusionVert,
        fragmentSource: fillExtrusionFrag
    };

    exports.lineSDF = {
        vertexSource: lineDashVertex,
        fragmentSource: lineDashFrag
    };

    exports.symbolSDF = {
        vertexSource: symbolVertex,
        fragmentSource: symbolFrag
    };

    exports.symbolIcon = {
        vertexSource: symbolIconVertex,
        fragmentSource: symbolIconFrag
    };

    exports.heatmap = {
        vertexSource: heatmapVertex,
        fragmentSource: heatmapFrag
    };

    exports.heatmapTexture = {
        vertexSource: heatmapTextureVertex,
        fragmentSource: heatmapTextureFrag
    };

    exports.raster = {
        vertexSource: rasterVertex,
        fragmentSource: rasterFrag
    };

    exports.image = {
        vertexSource: imageTextureVertex,
        fragmentSource: imageTextureFrag
    };

    exports.circle = {
        vertexSource: circleVertex,
        fragmentSource: circleFragment
    };

    exports.circles = {
        vertexSource: circlesVertex,
        fragmentSource: circlesFrag
    };

    exports.basicLine = {
        vertexSource: lineVertex2,
        fragmentSource: lineFragment2
    };

    exports.basicFill = {
        vertexSource: basicFillV,
        fragmentSource: basicFillF
    };

    exports.basicLineSDF = {
        vertexSource: lineDashVertexSimplify,
        fragmentSource: lineDashFragSimplify
    };

    exports.basicSymbol = {
        vertexSource: basicSymbolV,
        fragmentSource: basicSymbolF
    };

    exports.multiPoints = {
        vertexSource: multiPointsVertex,
        fragmentSource: multiPointsFrag
    };

    exports.images = {
        vertexSource: imageVertex,
        fragmentSource: imageFrag
    };

    exports.text = {
        vertexSource: textVertex,
        fragmentSource: textFrag
    };

    exports.arc = {
        vertexSource: arcVertex,
        fragmentSource: arcFrag
    };

    exports.multiCircles = {
        vertexSource: multiCircleVertex,
        fragmentSource: multiCircleFragment
    };

    exports.multiPolygon = {
        vertexSource: multiFillV,
        fragmentSource: multiFillF
    };

    exports.fan = {
        vertexSource: fanVertex,
        fragmentSource: fanFrag
    };

    var arcParticleVertex = "attribute float a_ratio;\n" +
        "  attribute vec3 source;\n" +
        "  attribute vec3 target;\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform float height;\n" +
        "  uniform float tilts;\n" +
        "  uniform float offset;\n" +
        "\n" +
        "  float paraboloid(vec3 source, vec3 target, float ratio) {\n" +
        "    vec3 delta = target - source;\n" +
        "    float dh = length(delta.xy) * height;\n" +
        "    float unitZ = delta.z / dh;\n" +
        "    float p2 = unitZ * unitZ + 1.0;\n" +
        "    float dir = step(delta.z, 0.0);\n" +
        "    float z0 = mix(source.z, target.z, dir);\n" +
        "    float r = mix(ratio, 1.0 - ratio, dir);\n" +
        "    return sqrt(r * (p2 - r)) * dh + z0;\n" +
        "  }\n" +
        "\n" +
        "  vec3 getPos(vec3 source, vec3 target, float segmentRatio) {\n" +
        "    float z = paraboloid(source, target, segmentRatio);\n" +
        "    float tiltAngle = radians(tilts);\n" +
        "    vec2 tiltDirection = normalize(target.xy - source.xy);\n" +
        "    vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n" +
        "    return vec3(mix(source.xy, target.xy, segmentRatio) + tilt,z * cos(tiltAngle));\n" +
        "  }\n" +
        "\n" +
        "  void main(void) {\n" +
        "    float segmentRatio = a_ratio + offset;\n" +
        "    segmentRatio = segmentRatio > 1.0?segmentRatio-1.0:segmentRatio;\n" +
        "    vec3 currPos = getPos(source, target, segmentRatio);\n" +
        "    gl_Position = u_matrix * vec4(currPos, 1.0);\n" +
        "    gl_PointSize = 20.0;\n" +
        "  }";

    var arcParticleFrag = "precision highp float;\n" +
        "  uniform vec4 color;\n" +
        "  void main(void) {\n" +
        "    float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n" +
        /*"    float opacity = 1.0 - d * 2.0;\n" +
    "    if(opacity > 0.0){\n" +
    "      gl_FragColor = vec4(1.0, 1.0, 0.0, opacity);\n" +
    "    } else {\n" +
    "      discard;\n" +
    "    }\n" +*/
        "if (d < 0.1) {\n" +
        "    gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n" +
        "  } else if (d < 0.5) {\n" +
        "    gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5 - d);\n" +
        "  } else {\n" +
        "    discard;\n" +
        "  }\n" +
        "  }";

    var arcParticleUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'height': new uniform.Uniform1f(context, locations.height),
            'tilts': new uniform.Uniform1f(context, locations.tilts),
            'color': new uniform.Uniform4f(context, locations.color),
            'offset': new uniform.Uniform1f(context, locations.offset)
        });
    };
    exports.arcParticle = {
        vertexSource: arcParticleVertex,
        fragmentSource: arcParticleFrag
    };


    var lineParticleVertex = "attribute float a_ratio;\n" +
        "  uniform vec3 u_source_position;\n" +
        "  uniform vec3 u_target_position;\n" +
        "  uniform mat4 u_matrix;\n" +
        "  vec3 getPos(vec3 source, vec3 target, float segmentRatio) {\n" +
        "    return source * (1.0 - segmentRatio) + target * segmentRatio;\n" +
        "  }\n" +
        "\n" +
        "  void main(void) {\n" +
        "    vec3 source = u_source_position;\n" +
        "    vec3 target = u_target_position;\n" +
        "    vec3 currPos = getPos(source, target, a_ratio);\n" +
        "    gl_Position = u_matrix * vec4(currPos, 1.0);\n" +
        "    gl_PointSize = 20.0;\n" +
        "  }";

    var lineParticleFrag = "precision highp float;\n" +
        "  uniform vec4 color;\n" +
        "  void main(void) {\n" +
        "    float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n" +
        "if (d < 0.1) {\n" +
        "    gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n" +
        "  } else if (d < 0.5) {\n" +
        "    gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5 - d);\n" +
        "  } else {\n" +
        "    discard;\n" +
        "  }\n" +
        "  }";

    var lineParticleUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_source_position': new uniform.Uniform3f(context, locations.u_source_position),
            'u_target_position': new uniform.Uniform3f(context, locations.u_target_position),
            'color': new uniform.Uniform4f(context, locations.color)
        });
    };
    exports.lineParticle = {
        vertexSource: lineParticleVertex,
        fragmentSource: lineParticleFrag
    };

    var spriteVertex = "attribute vec2 position;\n" +
        "  attribute vec2 uv;\n" +
        "\n" +
        "  uniform vec2 scale;\n" +
        "  uniform mat4 modelViewMatrix;\n" +
        "  uniform mat4 projectionMatrix;\n" +
        "  uniform float rotation;\n" +
        "  uniform vec2 center;\n" +
        "\n" +
        "  varying vec2 vUv;\n" +
        "\n" +
        "  void main() {\n" +
        "    vUv = uv;\n" +
        "    position = position/2.0;\n" +
        "    vec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n" +
        "\n" +
        "    bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n" +
        "    if ( isPerspective ) scale *= - mvPosition.z;\n" +
        "\n" +
        "    vec2 alignedPosition = (position - (center - vec2(0.5))) * scale;\n" +
        "    vec2 rotatedPosition;\n" +
        "    rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\n" +
        "    rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\n" +
        "    mvPosition.xy += rotatedPosition;\n" +
        "    gl_Position = projectionMatrix * mvPosition;\n" +
        "  }";

    var spriteFrag = "precision highp float;\n" +
        "\n" +
        "  varying vec2 vUv;\n" +
        "  uniform sampler2D map;\n" +
        "\n" +
        "  void main() {\n" +
        "    gl_FragColor = texture2D(map, vUv);\n" +
        "  }";

    var spriteUniforms = function (context, locations) {
        return ({
            'modelViewMatrix': new uniform.UniformMatrix4f(context, locations.modelViewMatrix),
            'projectionMatrix': new uniform.UniformMatrix4f(context, locations.projectionMatrix),
            'scale': new uniform.Uniform2f(context, locations.scale),
            'center': new uniform.Uniform2f(context, locations.center),
            'rotation': new uniform.Uniform1f(context, locations.rotation),
            'map': new uniform.Uniform1i(context, locations.map)
        });
    };

    exports.sprite = {
        vertexSource: spriteVertex,
        fragmentSource: spriteFrag
    };

    var lineExtrusionVertex = "attribute vec3 a_pos;\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform float u_fill_extrusion_base;\n" +
        "  uniform float u_fill_extrusion_height;\n" +
        "\n" +
        "  void main() {\n" +
        "    highp float base = u_fill_extrusion_base;\n" +
        "    highp float height = u_fill_extrusion_height;\n" +
        "    base = max(0.0, base);\n" +
        "    height = max(0.0, height);\n" +
        "    gl_Position = u_matrix * vec4(a_pos.xy, a_pos.z>0.0 ? height : base, 1.0);\n" +
        "  }";
    var lineExtrusionFrag = "precision mediump float;\n" +
        "  uniform vec4 u_fill_extrusion_color;\n" +
        "  void main() {\n" +
        "    gl_FragColor = u_fill_extrusion_color;\n" +
        "  }";

    var lineExtrusionUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)
        });
    };

    exports.lineExtrusion = {
        vertexSource: lineExtrusionVertex,
        fragmentSource: lineExtrusionFrag
    };

    var moveLineVertex = "attribute vec3 a_data;\n" +
        "  attribute vec2 source;\n" +
        "  attribute vec2 middle;\n" +
        "  attribute vec2 target;\n" +
        "  uniform float ratio;\n" +
        "  uniform float u_len;\n" +
        "  uniform float segment;\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform float u_width;\n" +
        "  varying float v_opacity;\n" +
        "\n" +
        "  vec2 getPos(float t) {\n" +
        "    float left = 1.0 - t;\n" +
        "    return left * left * source + 2.0 * t * left * middle + t * t * target;\n" +
        "  }\n" +
        "\n" +
        "  vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n" +
        "    vec2 dir_screenspace = normalize(line_clipspace);\n" +
        "    dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n" +
        "    return dir_screenspace * offset_direction * width / 2.0;\n" +
        "  }\n" +
        "\n" +
        "  void main() {\n" +
        "    vec2 currPos = getPos(ratio);\n" +
        "    vec2 nextPos = getPos(max(ratio - 1.0/segment, 0.0));\n" +
        "    vec2 normal = normalize(nextPos - currPos)* u_len * a_data.x;\n" +
        "    vec4 curr = u_matrix * vec4(currPos - normal, 0.0, 1.0);\n" +
        "    vec4 next = u_matrix * vec4(nextPos, 0.0, 1.0);\n" +
        "\n" +
        "    vec2 offsetPos = getExtrusionOffset(next.xy - curr.xy, a_data.y, u_width);\n" +
        "    gl_Position = curr + vec4(offsetPos, 0.0, 1.0);\n" +
        "    v_opacity = a_data.z;\n" +
        "//    gl_Position = u_matrix * vec4(source, 0.0, 1.0);\n" +
        "  }";
    var moveLineFrag = "precision mediump float;\n" +
        "  varying float v_opacity;\n" +
        "  uniform vec4 u_color;\n" +
        "  void main() {\n" +
        "    gl_FragColor = vec4(u_color.xyz, mix(0.0, 1.0, v_opacity));\n" +
        "  }";

    var moveLineUniforms = function (context, locations) {
        return ({
            'ratio': new uniform.Uniform1f(context, locations.ratio),
            'u_len': new uniform.Uniform1f(context, locations.u_len),
            'segment': new uniform.Uniform1f(context, locations.segment),
            'u_width': new uniform.Uniform1f(context, locations.u_width),
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_color': new uniform.Uniform4f(context, locations.u_color)
        });
    };

    exports.moveLine = {
        vertexSource: moveLineVertex,
        fragmentSource: moveLineFrag
    };

    var moveArcVertex = "attribute vec3 a_pos;\n" +
        "  attribute vec3 source;\n" +
        "  attribute vec3 target;\n" +
        "  uniform float u_ratio;\n" +
        "  uniform float u_len;\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform float u_device_pixel_ratio;\n" +
        "\n" +
        "  uniform float width;\n" +
        "  uniform float height;\n" +
        "  uniform float tilts;\n" +
        "  uniform float numSegments;\n" +
        "  varying float v_opacity;\n" +
        "\n" +
        "  float paraboloid(vec3 source, vec3 target, float ratio) {\n" +
        "    vec3 delta = target - source;\n" +
        "    float dh = length(delta.xy) * height;\n" +
        "    float unitZ = delta.z / dh;\n" +
        "    float p2 = unitZ * unitZ + 1.0;\n" +
        "    float dir = step(delta.z, 0.0);\n" +
        "    float z0 = mix(source.z, target.z, dir);\n" +
        "    float r = mix(ratio, 1.0 - ratio, dir);\n" +
        "    return sqrt(r * (p2 - r)) * dh + z0;\n" +
        "  }\n" +
        "  vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n" +
        "    vec2 dir_screenspace = normalize(line_clipspace);\n" +
        "    dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n" +
        "    return dir_screenspace * offset_direction * width;\n" +
        "  }\n" +
        "\n" +
        "  vec3 getPos(vec3 source, vec3 target, float segmentRatio) {\n" +
        "    float z = paraboloid(source, target, segmentRatio);\n" +
        "    float tiltAngle = radians(tilts);\n" +
        "    vec2 tiltDirection = normalize(target.xy - source.xy);\n" +
        "    vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n" +
        "    return vec3(mix(source.xy, target.xy, segmentRatio) + tilt,z * cos(tiltAngle));\n" +
        "  }\n" +
        "\n" +
        "  void main(void) {\n" +
        "    vec3 currPos = getPos(source, target, u_ratio);\n" +
        "    vec3 nextPos = getPos(source, target, max(u_ratio - 0.5/numSegments, 0.0));\n" +
        "    vec3 normal = normalize(nextPos - currPos)* u_len * a_pos.x;\n" +
        "    vec4 curr = u_matrix * vec4(currPos - normal , 1.0);\n" +
        "    vec4 next = u_matrix * vec4(nextPos, 1.0);\n" +

        "\n" +
        "    float widthPixels = width;\n" +
        "\n" +
        "    vec3 offsetPos = vec3(getExtrusionOffset(next.xy - curr.xy, a_pos.y, widthPixels), 0.0);\n" +
        "    gl_Position = curr + vec4(offsetPos.xy, 0.0, 0.0);\n" +
        "    v_opacity = a_pos.z;\n" +
        "  }";

    var moveArcFrag = "precision highp float;\n" +
        "  uniform vec4 color;\n" +
        "  varying float v_opacity;\n" +
        "  void main(void) {\n" +
        "    gl_FragColor = vec4(color.xyz, v_opacity*0.8);\n" +
        "  }";

    var moveArcUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'height': new uniform.Uniform1f(context, locations.height),
            'tilts': new uniform.Uniform1f(context, locations.tilts),
            'numSegments': new uniform.Uniform1f(context, locations.numSegments),
            'width': new uniform.Uniform1f(context, locations.width),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'color': new uniform.Uniform4f(context, locations.color),
            'u_ratio': new uniform.Uniform1f(context, locations.u_ratio),
            'u_len': new uniform.Uniform1f(context, locations.u_len)
        });
    };

    exports.moveArc = {
        vertexSource: moveArcVertex,
        fragmentSource: moveArcFrag
    };

    var blurVertex = "attribute vec4 aPos;\n" +
        "  varying vec2 vUv;\n" +
        "  void main() {\n" +
        "    vUv = aPos.zw;\n" +
        "    gl_Position = vec4(aPos.xy, 0.0, 1.0);\n" +
        "  }";

    var blurFrag = "precision mediump float;\n" +
        "  varying vec2 vUv;\n" +
        "  uniform sampler2D colorTexture;\n" +
        "  uniform vec2 texSize;\n" +
        "  uniform vec2 direction;\n" +
        "\n" +
        "  uniform float SIGMA;\n" +
        "\n" +
        "  float gaussianPdf(in float x, in float sigma) {\n" +
        "    return 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n" +
        "  }\n" +
        "  void main() {\n" +
        "    vec2 invSize = 1.0 / texSize;\n" +
        "    float fSigma = float(SIGMA);\n" +
        "    float weightSum = gaussianPdf(0.0, fSigma);\n" +
        "    vec4 diffuseSum = texture2D(colorTexture, vUv) * weightSum;\n" +
        "    for (int i = 1; i < 8; i ++) {\n" +
        "      float x = float(i);\n" +
        "      float w = gaussianPdf(x, fSigma);\n" +
        "      vec2 uvOffset = direction * invSize * x;\n" +
        "      vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\n" +
        "      vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n" +
        "      diffuseSum += (sample1 + sample2) * w;\n" +
        "      weightSum += 2.0 * w;\n" +
        "    }\n" +
        "    //    gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n" +
        "    // gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n" +
        "    gl_FragColor = diffuseSum/weightSum;\n" +
        "  }";

    var blurUniforms = function (context, locations) {
        return ({
            "colorTexture": new uniform.Uniform1i(context, locations.colorTexture),
            "texSize": new uniform.Uniform2f(context, locations.texSize),
            "direction": new uniform.Uniform2f(context, locations.direction),
            "SIGMA": new uniform.Uniform1f(context, locations.SIGMA)
        });
    };

    exports.blur = {
        vertexSource: blurVertex,
        fragmentSource: blurFrag
    };

    var bloomVertex = "attribute vec4 aPos;\n" +
        "  varying vec2 vUv;\n" +
        "  void main() {\n" +
        "    vUv = aPos.zw;\n" +
        "    gl_Position = vec4(aPos.xy, 0.0, 1.0);\n" +
        "  }";
    var bloomFrag = "precision mediump float;\n" +
        "  varying vec2 vUv;\n" +
        "  uniform sampler2D blurTexture1;\n" +
        "  uniform float bloomStrength;\n" +
        "  uniform float bloomRadius;\n" +

        /*   "  uniform sampler2D blurTexture2;\n" +
      "  uniform sampler2D blurTexture3;\n" +
      "  uniform sampler2D blurTexture4;\n" +
      "  uniform sampler2D blurTexture5;\n" +

      "  uniform float bloomFactors[5];\n" +
      "  uniform vec3 bloomTintColors[5];\n" +
      "\n" +*/
        "  float lerpBloomFactor(const in float factor) {\n" +
        "    float mirrorFactor = 1.2 - factor;\n" +
        "    return mix(factor, mirrorFactor, bloomRadius);\n" +
        "  }\n" +
        "\n" +
        "  void main() {\n" +
        "    gl_FragColor = bloomStrength * (lerpBloomFactor(1.0) * vec4(1.0, 1.0, 1.0, 1.0) * texture2D(blurTexture1, vUv));// +\n" +
        /* "    lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n" +
    "    lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n" +
    "    lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n" +
    "    lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv));\n" +*/
        // "    gl_FragColor = texture2D(blurTexture1, vUv);\n" +
        "  }";

    var bloomUniforms = function (context, locations) {
        return ({
            "blurTexture1": new uniform.Uniform1i(context, locations.blurTexture1),
            "bloomStrength": new uniform.Uniform1f(context, locations.bloomStrength),
            "bloomRadius": new uniform.Uniform1f(context, locations.bloomRadius)
        });
    };

    exports.bloom = {
        vertexSource: bloomVertex,
        fragmentSource: bloomFrag
    };

    var imageFillVertex = "vec2 get_pattern_pos(const vec2 pixel_coord_upper, const vec2 pixel_coord_lower,\n" +
        "  const vec2 pattern_size, const float tile_units_to_pixels, const vec2 pos) {\n" +
        "\n" +
        "    vec2 offset = mod(mod(mod(pixel_coord_upper, pattern_size) * 256.0, pattern_size) * 256.0 + pixel_coord_lower, pattern_size);\n" +
        "    return (tile_units_to_pixels * pos + offset) / pattern_size;\n" +
        "  }\n" +
        "\n" +
        "  uniform mat4 u_matrix;\n" +
        "  uniform vec2 u_pixel_coord_upper;\n" +
        "  uniform vec2 u_pixel_coord_lower;\n" +
        "  uniform vec4 u_scale;\n" +
        "\n" +
        "  attribute vec2 a_pos;\n" +
        "\n" +
        "  varying vec2 v_pos_a;\n" +
        "  varying vec2 v_pos_b;\n" +
        "\n" +
        "\n" +
        "  uniform lowp float u_opacity;\n" +
        "  uniform lowp vec4 u_pattern_from;\n" +
        "  uniform lowp vec4 u_pattern_to;\n" +
        "\n" +
        "  void main() {\n" +
        "    lowp float opacity = u_opacity;\n" +
        "    mediump vec4 pattern_from = u_pattern_from;\n" +
        "    mediump vec4 pattern_to = u_pattern_to;\n" +
        "\n" +
        "    vec2 pattern_tl_a = pattern_from.xy;\n" +
        "    vec2 pattern_br_a = pattern_from.zw;\n" +
        "    vec2 pattern_tl_b = pattern_to.xy;\n" +
        "    vec2 pattern_br_b = pattern_to.zw;\n" +
        "\n" +
        "    float pixelRatio = u_scale.x;\n" +
        "    float tileZoomRatio = u_scale.y;\n" +
        "    float fromScale = u_scale.z;\n" +
        "    float toScale = u_scale.w;\n" +
        "\n" +
        "    vec2 display_size_a = vec2((pattern_br_a.x - pattern_tl_a.x) / pixelRatio, (pattern_br_a.y - pattern_tl_a.y) / pixelRatio);\n" +
        "    vec2 display_size_b = vec2((pattern_br_b.x - pattern_tl_b.x) / pixelRatio, (pattern_br_b.y - pattern_tl_b.y) / pixelRatio);\n" +
        "    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n" +
        "\n" +
        "    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, fromScale * display_size_a, tileZoomRatio, a_pos);\n" +
        "    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, toScale * display_size_b, tileZoomRatio, a_pos);\n" +
        "  }";

    var imageFillFrag = "precision mediump float;\n" +
        "\n" +
        "  uniform vec2 u_texsize;\n" +
        "  uniform float u_fade;\n" +
        "  uniform sampler2D u_image;\n" +
        "\n" +
        "  varying vec2 v_pos_a;\n" +
        "  varying vec2 v_pos_b;\n" +
        "\n" +
        "  uniform lowp float u_opacity;\n" +
        "  uniform lowp vec4 u_pattern_from;\n" +
        "  uniform lowp vec4 u_pattern_to;\n" +
        "\n" +
        "  void main() {\n" +
        "    lowp float opacity = u_opacity;\n" +
        "    mediump vec4 pattern_from = u_pattern_from;\n" +
        "    mediump vec4 pattern_to = u_pattern_to;\n" +
        "\n" +
        "\n" +
        "    vec2 pattern_tl_a = pattern_from.xy;\n" +
        "    vec2 pattern_br_a = pattern_from.zw;\n" +
        "    vec2 pattern_tl_b = pattern_to.xy;\n" +
        "    vec2 pattern_br_b = pattern_to.zw;\n" +
        "\n" +
        "    vec2 imagecoord = mod(v_pos_a, 1.0);\n" +
        "    vec2 pos = mix(pattern_tl_a / u_texsize, pattern_br_a / u_texsize, imagecoord);\n" +
        "    vec4 color1 = texture2D(u_image, pos);\n" +
        "\n" +
        "    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n" +
        "    vec2 pos2 = mix(pattern_tl_b / u_texsize, pattern_br_b / u_texsize, imagecoord_b);\n" +
        "    vec4 color2 = texture2D(u_image, pos2);\n" +
        "\n" +
        "    gl_FragColor = mix(color1, color2, u_fade) * opacity;\n" +
        "  }";

    var imageFillUniforms = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_pixel_coord_upper': new uniform.Uniform2f(context, locations.u_pixel_coord_upper),
            'u_pixel_coord_lower': new uniform.Uniform2f(context, locations.u_pixel_coord_lower),
            'u_texsize': new uniform.Uniform2f(context, locations.u_texsize),
            'u_scale': new uniform.Uniform4f(context, locations.u_scale),
            'u_pattern_from': new uniform.Uniform4f(context, locations.u_pattern_from),
            'u_pattern_to': new uniform.Uniform4f(context, locations.u_pattern_to),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_fade': new uniform.Uniform1f(context, locations.u_fade),
            'u_image': new uniform.Uniform1i(context, locations.u_image)
        });
    };

    exports.imageFill = {
        vertexSource: imageFillVertex,
        fragmentSource: imageFillFrag
    };

    var gaussianBlurVertex = "attribute vec4 aPos;\n" +
        "  varying vec2 vUV;\n" +
        "  void main() {\n" +
        "    gl_Position = vec4(aPos.xy, 0.0, 1.0);\n" +
        "    vUV = aPos.zw;\n" +
        "  }";

    var gaussianBlurFrag = "precision mediump float;\n" +
        "  uniform sampler2D uTexture;\n" +
        "  uniform bool uHorizontal;\n" +
        "  // uniform float uSampleStep;\n" +
        "  uniform vec2 uSize;\n" +
        "  varying vec2 vUV;\n" +
        "\n" +
        "  uniform float u_kernel[5];\n" +
        "  void main() {\n" +
        "    vec2 onePixel = vec2(1.0) / uSize;\n" +
        "    vec2 offset = (uHorizontal? vec2(1, 0):vec2(0, 1));\n" +
        "    vec4 colorSum =\n" +
        "    texture2D(uTexture, vUV) * u_kernel[0] +\n" +
        "    texture2D(uTexture, vUV + onePixel * offset) * u_kernel[1] +\n" +
        "    texture2D(uTexture, vUV - onePixel * offset) * u_kernel[1] +\n" +
        "    texture2D(uTexture, vUV + onePixel * 2.0*offset) * u_kernel[2] +\n" +
        "    texture2D(uTexture, vUV - onePixel * 2.0*offset) * u_kernel[2] +\n" +
        "    texture2D(uTexture, vUV + onePixel * 3.0*offset) * u_kernel[3] +\n" +
        "    texture2D(uTexture, vUV - onePixel * 3.0*offset) * u_kernel[3] +\n" +
        "    texture2D(uTexture, vUV + onePixel * 4.0*offset) * u_kernel[4] +\n" +
        "    texture2D(uTexture, vUV - onePixel * 4.0*offset) * u_kernel[4];\n" +
        "    gl_FragColor = vec4(colorSum.rgb / 0.7, colorSum.a);\n" +
        // "    gl_FragColor = vec4(u_kernel[0], u_kernel[0], u_kernel[0], 1.0);\n" +
        "\n" +
        "  }";

    var gaussianBlurUniforms = function (context, locations) {
        return ({
            'uSize': new uniform.Uniform2f(context, locations.uSize),
            'uTexture': new uniform.Uniform1i(context, locations.uTexture),
            'uHorizontal': new uniform.Uniform1i(context, locations.uHorizontal),
            'u_kernel': new uniform.Uniform1fv(context, locations['u_kernel[0]'])
        });
    };

    exports.gaussianBlur = {
        vertexSource: gaussianBlurVertex,
        fragmentSource: gaussianBlurFrag
    };

    var screenFrag = "precision highp float;\n" +
        "  uniform sampler2D uTexture;\n" +
        "  varying vec2 vUV;\n" +
        "\n" +
        "  void main() {\n" +
        "    gl_FragColor = texture2D(uTexture, vUV);\n" +
        "  }";

    exports.screen = {
        vertexSource: gaussianBlurVertex,
        fragmentSource: screenFrag
    };

    var screenUniforms = function (context, locations) {
        return ({
            'uTexture': new uniform.Uniform1i(context, locations.uTexture)
        });
    };

    exports.basicFillImage = {
        vertexSource: basicFillImageV,
        fragmentSource: basicFillImageF
    };

    exports.ztText = {
        vertexSource: ztTextVertex,
        fragmentSource: ztTextFrag
    }


    /**
     * 
     * @type {{fragmentSource: *, vertexSource: *}}
     */
    exports.rect = {
        vertexSource: rectVertex,
        fragmentSource: reactFragment
    }
    /**
     * Uniform
     * @param context
     * @param locations
     * @returns {{u_extrude_scale, u_color, u_device_pixel_ratio, u_camera_to_center_distance, u_matrix, u_size}}
     */
    var rectUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_device_pixel_ratio': new uniform.Uniform1f(context, locations.u_device_pixel_ratio),
            'u_camera_to_center_distance': new uniform.Uniform1f(context, locations.u_camera_to_center_distance),
            'u_extrude_scale': new uniform.Uniform2f(context, locations.u_extrude_scale),
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_radian': new uniform.Uniform1f(context, locations.u_radian),
            'u_is_stroke': new uniform.Uniform1i(context, locations.u_is_stroke),
            'u_color': new uniform.Uniform4f(context, locations.u_color)/*,
      'u_stroke_width': new uniform.Uniform1f(context, locations['u_stroke_width']),
      'u_stroke_color': new uniform.Uniform4f(context, locations['u_stroke_color'])*/
        };
    };

    exports.terrain = {
        vertexSource: terrainVertex,
        fragmentSource: terrainFragment
    };

    var terrainUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_color': new uniform.Uniform4f(context, locations.u_color),
            'u_tileRectangle': new uniform.Uniform4f(context, locations.u_tileRectangle),
            'u_image': new uniform.Uniform1i(context, locations.u_image)
        };
    };

    exports.tifTerrain = {
        vertexSource: tiffTerrainVertex,
        fragmentSource: tiffTerrainFragment
    };

    var tifTerrainUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_image': new uniform.Uniform1i(context, locations.u_image),

        };
    };

    exports.heightMap = {
        vertexSource: heightMapVertex,
        fragmentSource: heightMapFragment
    }

    var heightMapUniforms = function (context, locations) {
        return {
            'u_min_height': new uniform.Uniform1f(context, locations.u_min_height),
            'u_delta_height': new uniform.Uniform1f(context, locations.u_delta_height)
        };
    };

    exports.water = {
        vertexSource: waterVertex,
        fragmentSource: waterFragment
    };

    var waterUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_water_depth': new uniform.Uniform1f(context, locations.u_water_depth)
        };
    };

    exports.bg = {
        vertexSource: bgVertex,
        fragmentSource: bgFragment
    }

    var bgUniforms = function (context, locations) {
        return {};
    }

    exports.mesh = {
        vertexSource: meshVertex,
        fragmentSource: meshFragment
    }

    var meshUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_model': new uniform.UniformMatrix4f(context, locations.u_model),
            'u_color': new uniform.Uniform3f(context, locations.u_color)
        }
    }

    exports.cylinder = {
        vertexSource: cylinderVertex,
        fragmentSource: cylinderFragment
    };

    var cylinderUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_texture': new uniform.Uniform1i(context, locations.u_texture),
            'u_size': new uniform.Uniform1f(context, locations.u_size),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_color': new uniform.Uniform4f(context, locations.u_color)
        }
    }

    exports.cone = {
        vertexSource: coneVertex,
        fragmentSource: coneFragment
    };

    var coneUniforms = function (context, locations) {
        return {
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix)
        }
    }

    exports.myline = {
        vertexSource: mylineVertex,
        fragmentSource: mylineFragment
    }

    var fillExtrusionUniforms2 = function (context, locations) {
        return ({
            'u_matrix': new uniform.UniformMatrix4f(context, locations.u_matrix),
            'u_lightpos': new uniform.Uniform3f(context, locations.u_lightpos),
            'u_lightintensity': new uniform.Uniform1f(context, locations.u_lightintensity),
            'u_lightcolor': new uniform.Uniform3f(context, locations.u_lightcolor),
            'u_vertical_gradient': new uniform.Uniform1f(context, locations.u_vertical_gradient),
            'u_opacity': new uniform.Uniform1f(context, locations.u_opacity),
            'u_color': new uniform.Uniform4f(context, locations.u_color),
            'u_height': new uniform.Uniform1f(context, locations.u_height),
            'u_base': new uniform.Uniform1f(context, locations.u_base)
        });
    };

    exports.fillExtrusion2 = {
        vertexSource: fillExtrusionVert,
        fragmentSource: fillExtrusionFrag
    };

    exports.programUniforms = {
        fill: fillUniforms,
        line: lineUniforms,
        symbolIcon: symbolIconUniforms,
        symbolSDF: symbolSDFUniforms,
        lineSDF: lineSDFUniforms,
        fillExtrusion: fillExtrusionUniforms,
        fillExtrusion2: fillExtrusionUniforms2,
        lineExtrusion: lineExtrusionUniforms,
        clippingMask: clippingMaskUniforms,
        background: backgroundUniforms,
        heatmap: heatmapUniforms,
        heatmapTexture: heatmapTextureUniforms,
        raster: rasterUniforms,
        image: imageTextureUniforms,
        circles: circleUniforms,
        circle: roundUniforms,
        basicFill: basicFillUniforms,
        basicLine: basicLineUniforms,
        basicSymbol: basicSymbolUniform,
        multiPoints: multiPointsUniforms,
        basicLineSDF: basicLineDashUniforms,
        images: imageUniforms,
        text: textUniforms,
        ztText: ztTextUniforms,
        arc: arcUniforms,
        multiCircles: multiRoundUniforms,
        multiPolygon: multiFillUniforms,
        fan: fanUniforms,
        arcParticle: arcParticleUniforms,
        lineParticle: lineParticleUniforms,
        sprite: spriteUniforms,
        moveLine: moveLineUniforms,
        moveArc: moveArcUniforms,
        blur: blurUniforms,
        bloom: bloomUniforms,
        imageFill: imageFillUniforms,
        gaussianBlur: gaussianBlurUniforms,
        screen: screenUniforms,
        basicFillImage: basicFillImageUniforms,

        rect: rectUniforms,
        terrain: terrainUniforms,
        heightMap: heightMapUniforms,
        tifTerrain: tifTerrainUniforms,

        water: waterUniforms,
        bg: bgUniforms,
        mesh: meshUniforms,
        cylinder: cylinderUniforms,
        cone: coneUniforms,
        myline: basicLineUniforms
    };
});
},
'com/huayun/webgis/symbols/support/CustomGlyphAtlas':function(){
define([
    "../../gl/potpack",
    "../../utils/image"
], function (potpack, images) {
    var padding = 1;
    return function (stacks) {
        var positions = {};
        var totalW = 0,
            totalH = -Infinity;
        var textWidth = 0;
        for (var stack in stacks) {
            var glyphs = stacks[stack];
            var stackPositions = positions[stack] = {};
            for (var id in glyphs) {
                var src = glyphs[+id];
                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) {
                    continue;
                }
                var bin = {
                    x: totalW,
                    y: 0,
                    w: src.bitmap.width + 2 * padding,
                    h: src.bitmap.height + 2 * padding
                };
                totalW += bin.w;
                textWidth += src.metrics.advance;
                if (bin.h > totalH) {
                    totalH = bin.h;
                }
                stackPositions[id] = {rect: bin, metrics: src.metrics};
            }
        }

        /*var ref = potpack(bins);
        var w = ref.w;
        var h = ref.h;*/
        var w = totalW,
            h = totalH;
        var image = new images.AlphaImage({width: w || 1, height: h || 1});

        for (var stack$1 in stacks) {
            var glyphs$1 = stacks[stack$1];
            for (var id$1 in glyphs$1) {
                var src$1 = glyphs$1[+id$1];
                if (!src$1 || src$1.bitmap.width === 0 || src$1.bitmap.height === 0) {
                    continue;
                }
                var bin$1 = positions[stack$1][id$1].rect;
                images.AlphaImage.copy(src$1.bitmap, image, {x: 0, y: 0}, {
                    x: bin$1.x + padding,
                    y: bin$1.y + padding
                }, src$1.bitmap);
            }
        }
        this.image = image;
        this.positions = positions;
        this.textWidth = textWidth;
    };
});
},
'com/huayun/webgis/gl/glUtils':function(){
define(["exports"], function (exports) {

    exports.generateFBO = function (context, width, height) {
        var gl = context.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        var fbo = context.createFramebuffer(width, height);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA,
            context.extTextureHalfFloat ? context.extTextureHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE, null);
        fbo.colorAttachment.set(texture);
        return fbo;
    }
})
},
'com/huayun/webgis/utils/earcut':function(){
define([
    "exports"
], function (exports) {
    function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];

        if (!outerNode || outerNode.next === outerNode.prev) {
            return triangles;
        }

        var minX, minY, maxX, maxY, x, y, invSize;

        if (hasHoles) {
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        }

        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];

            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }

            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

        return triangles;
    }

    function linkedList(data, start, end, dim, clockwise) {
        var i, last;

        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) {
                last = insertNode(i, data[i], data[i + 1], last);
            }
        } else {
            for (i = end - dim; i >= start; i -= dim) {
                last = insertNode(i, data[i], data[i + 1], last);
            }
        }

        if (last && equals$a(last, last.next)) {
            removeNode(last);
            last = last.next;
        }

        return last;
    }

    function filterPoints(start, end) {
        if (!start) {
            return start;
        }
        if (!end) {
            end = start;
        }

        var p = start,
            again;
        do {
            again = false;

            if (!p.steiner && (equals$a(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) {
                    break;
                }
                again = true;

            } else {
                p = p.next;
            }
        } while (again || p !== end);

        return end;
    }

    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) {
            return;
        }

        if (!pass && invSize) {
            indexCurve(ear, minX, minY, invSize);
        }

        var stop = ear,
            prev, next;

        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;

            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            if (ear === stop) {
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }

    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
        if (area(a, b, c) >= 0) {
            return false;
        }
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }

    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
        if (area(a, b, c) >= 0) {
            return false;
        }
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        var minZ = zOrder(minTX, minTY, minX, minY, invSize),
            maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ,
            n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;

            if (n !== ear.prev && n !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }

        return true;
    }

    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;

            if (!equals$a(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);

        return p;
    }

    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) {
                list.steiner = true;
            }
            queue.push(getLeftmost(list));
        }

        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
    }

    function compareX(a, b) {
        return a.x - b.x;
    }

    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }

    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;

        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) {
                            return p;
                        }
                        if (hy === p.next.y) {
                            return p.next;
                        }
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);

        if (!m) {
            return null;
        }

        if (hx === qx) {
            return m.prev;
        } // hole touches outer segment; pick lower endpoint

        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m.next;

        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }

            p = p.next;
        }

        return m;
    }

    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) {
                p.z = zOrder(p.x, p.y, minX, minY, invSize);
            }
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked(p);
    }

    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) {
                        break;
                    }
                }
                qSize = inSize;

                while (pSize > 0 || (qSize > 0 && q)) {

                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }

                    if (tail) {
                        tail.nextZ = e;
                    } else {
                        list = e;
                    }

                    e.prevZ = tail;
                    tail = e;
                }

                p = q;
            }

            tail.nextZ = null;
            inSize *= 2;

        } while (numMerges > 1);

        return list;
    }

    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {
                leftmost = p;
            }
            p = p.next;
        } while (p !== start);

        return leftmost;
    }

    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }

    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
            locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }

    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    function equals$a(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    function intersects(p1, q1, p2, q2) {
        if ((equals$a(p1, q1) && equals$a(p2, q2)) ||
            (equals$a(p1, q2) && equals$a(p2, q1))) {
            return true;
        }
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
            area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }

    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);

        return false;
    }

    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }

    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);

        return inside;
    }

    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
    }

    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);

        if (!last) {
            p.prev = p;
            p.next = p;

        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) {
            p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
            p.nextZ.prevZ = p.prevZ;
        }
    }

    function Node(i, x, y) {
        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = null;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
    }

    earcut.deviation = function (data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
        }

        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs(
                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }

        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    };

    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }

    earcut.flatten = function (data) {
        var dim = data[0][0].length,
            result = {vertices: [], holes: [], dimensions: dim},
            holeIndex = 0;

        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) {
                    result.vertices.push(data[i][j][d]);
                }
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    };
    exports.earcut = earcut;
});
},
'com/huayun/webgis/layers/Layer':function(){
/**
 * 
 * @see com.huayun.webgis.layers.Layer
 */
define([], function () {
    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.layers.Layer
     * @param {Object} params
     * @property {string} id  - id
     * @property {number} opacity  - 
     * @property {boolean} selectEnabled  - 
     * @property {boolean} controlEnabled  - 
     * @property {boolean} visible  - 
     */
    function Layer(params) {
        params = params === undefined ? {}: params;
        this.id = params.id || "layer";
        this.opacity = params.opacity === undefined ? 1 : params.opacity;
        this.visible = params.visible === undefined ? true : params.visible;
        this.selectEnabled = params.selectEnabled === undefined ? true : params.selectEnabled;
        this.controlEnabled = params.controlEnabled === undefined ? true : params.controlEnabled;
    }

    Layer.prototype.createLayerView = function (view, option) {
        throw new Error("createLayerView");
    };

    Layer.prototype.refresh = function () {

    };
    Layer.prototype.setVisible = function () {

    }

    return Layer;
});
},
'com/huayun/webgis/geometry/Polygon':function(){
/**
 * 
 * @module com/huayun/webgis/geometry
 * @see com.huayun.webgis.geometry.Polygon
 */
define([
    "./Geometry",
    "./Extent"
], function (Geometry, Extent) {
    function findExtremum(path) {
        var xmin, ymin, xmax, ymax;
        xmin = xmax = path[0][0].x;
        ymin = ymax = path[0][0].y;
        var len = path.length;
        for (var i = 0; i < len; i++) {
            var line = path[i];
            var ll = line.length;
            for (var j = 0; j < ll; j++) {
                var p = line[j];
                xmin = Math.min(xmin, p.x);
                ymin = Math.min(ymin, p.y);
                xmax = Math.max(xmax, p.x);
                ymax = Math.max(ymax, p.y);
            }
        }
        return {
            xmin: xmin,
            ymin: ymin,
            xmax: xmax,
            ymax: ymax
        };
    }

    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.geometry.Polygon
     * @extends {Geometry}
     * @param {Array} path  - , 
     * @property {Array} path , 
     * @property {Extent} extent 
     * @example
     * var innerPolygon = new Polygon([[
     *  new Point(514581, 3349546),
     *  new Point(514981, 3349546),
     *  new Point(514981, 3349246),
     *  new Point(514581, 3349246),
     *  new Point(514581, 3349546)
     * ],[
     *  new Point(514581, 3349546),
     *  new Point(514981, 3349546),
     *  new Point(514981, 3349246),
     *  new Point(514581, 3349246),
     *  new Point(514581, 3349546)
     * ]]);
     */
    var Polygon = function (path, spatialReference) {
        Geometry.call(this);
        this.type = "polygon";
        this.path = path;
        this.spatialReference = spatialReference;
        this._extent = null;
        this._area = null;
    };

    if (Geometry) Polygon.__proto__ = Geometry;
    Polygon.prototype = Object.create(Geometry && Geometry.prototype);
    Polygon.prototype.constructor = Polygon;

    var prototypeAccessors = {
        length: {configurable: false},
        extent: {configurable: false},
        area: {configurable: false}
    };

    prototypeAccessors.length.get = function () {
        return this.path.length;
    };

    prototypeAccessors.extent.get = function () {
        if (!this._extent) {
            var extremum = findExtremum(this.path);
            this._extent = new Extent(extremum.xmin, extremum.ymin, extremum.xmax, extremum.ymax);
        }
        return this._extent;
    };

    prototypeAccessors.area.get = function() {
        if (!this._area) {
            this._area = this.calculateArea();
        }
        return this._area;
    }

    Polygon.prototype = {
        setPath: function (path) {
            this.path = path;
            this._extent = null;
        },
        addRing: function (ring) {
            this.path.push(ring);
            this._extent = null;
        },
        update: function (dx, dy) {
            this.path.forEach(function (ring) {
                ring.forEach(function (point) {
                    point.update(dx, dy);
                });
            });
            this._extent = null;
        },
        calculateArea: function () {
            var smallArea = 0,
                allarea = 0;
            var ringList = this.path;
            for (var i = 0; i < ringList.length; i++) {
                var pointList = ringList[i];
                for (var j = 0; j < pointList.length - 1; j++) {
                    smallArea = 0.5 * (pointList[j+1].x - pointList[j].x) * (pointList[j+1].y + pointList[j].y);
                    allarea += smallArea;
                }
                smallArea = 0.5 * (pointList[0].x - pointList[pointList.length-1].x) * (pointList[0].y + pointList[pointList.length-1].y);
                allarea += smallArea;
            }
            return Math.abs(allarea);
        }
    };

    Object.defineProperties(Polygon.prototype, prototypeAccessors);
    return Polygon;
});
},
'com/huayun/webgis/layers/support/funcUtils':function(){
define([
    "exports",
    "com/huayun/webgis/geometry/Point2D",
    "./expression/Interpolate",
    "custom/gl-matrix-min"
], function (exports, pointGeometry, Interpolate, glMatrix) {

    exports.pick = function (src, properties) {
        var result = {};
        for (var i = 0; i < properties.length; i++) {
            var k = properties[i];
            if (k in src) {
                result[k] = src[k];
            }
        }
        return result;
    };

    exports.bindAll = function (fns, context) {
        fns.forEach(function (fn) {
            if (!context[fn]) {
                return;
            }
            context[fn] = context[fn].bind(context);
        });
    };

    exports.asyncAll = function (array, fn, callback) {
        if (!array.length) {
            return callback(null, []);
        }
        var remaining = array.length;
        var results = new Array(array.length);
        var error = null;
        array.forEach(function (item, i) {
            fn(item, function (err, result) {
                if (err) {
                    error = err;
                }
                results[i] = ((result));
                if (--remaining === 0) {
                    callback(error, results);
                }
            });
        });
    };

    exports.calculateKey = function (wrap, z, x, y) {
        /*wrap *= 2;
        if (wrap < 0) {
            wrap = wrap * -1 - 1;
        }
        var dim = 1 << z;
        return ((dim * dim * wrap + dim * y + x) * 32) + z;*/
        return z+"/"+x+"/"+y;
    };

    exports.now = self.performance && self.performance.now ?
        self.performance.now.bind(self.performance) :
        Date.now.bind(Date);

    var unicodeBlockLookup = {
        // 'Basic Latin': (ch) => ch >= 0x0000 && ch <= 0x007F,
        'Latin-1 Supplement': function (ch) {
            return ch >= 0x0080 && ch <= 0x00FF;
        },
        // 'Latin Extended-A': (ch) => ch >= 0x0100 && ch <= 0x017F,
        // 'Latin Extended-B': (ch) => ch >= 0x0180 && ch <= 0x024F,
        // 'IPA Extensions': (ch) => ch >= 0x0250 && ch <= 0x02AF,
        // 'Spacing Modifier Letters': (ch) => ch >= 0x02B0 && ch <= 0x02FF,
        // 'Combining Diacritical Marks': (ch) => ch >= 0x0300 && ch <= 0x036F,
        // 'Greek and Coptic': (ch) => ch >= 0x0370 && ch <= 0x03FF,
        // 'Cyrillic': (ch) => ch >= 0x0400 && ch <= 0x04FF,
        // 'Cyrillic Supplement': (ch) => ch >= 0x0500 && ch <= 0x052F,
        // 'Armenian': (ch) => ch >= 0x0530 && ch <= 0x058F,
        //'Hebrew': (ch) => ch >= 0x0590 && ch <= 0x05FF,
        'Arabic': function (ch) {
            return ch >= 0x0600 && ch <= 0x06FF;
        },
        //'Syriac': (ch) => ch >= 0x0700 && ch <= 0x074F,
        'Arabic Supplement': function (ch) {
            return ch >= 0x0750 && ch <= 0x077F;
        },
        // 'Thaana': (ch) => ch >= 0x0780 && ch <= 0x07BF,
        // 'NKo': (ch) => ch >= 0x07C0 && ch <= 0x07FF,
        // 'Samaritan': (ch) => ch >= 0x0800 && ch <= 0x083F,
        // 'Mandaic': (ch) => ch >= 0x0840 && ch <= 0x085F,
        // 'Syriac Supplement': (ch) => ch >= 0x0860 && ch <= 0x086F,
        'Arabic Extended-A': function (ch) {
            return ch >= 0x08A0 && ch <= 0x08FF;
        },
        // 'Devanagari': (ch) => ch >= 0x0900 && ch <= 0x097F,
        // 'Bengali': (ch) => ch >= 0x0980 && ch <= 0x09FF,
        // 'Gurmukhi': (ch) => ch >= 0x0A00 && ch <= 0x0A7F,
        // 'Gujarati': (ch) => ch >= 0x0A80 && ch <= 0x0AFF,
        // 'Oriya': (ch) => ch >= 0x0B00 && ch <= 0x0B7F,
        // 'Tamil': (ch) => ch >= 0x0B80 && ch <= 0x0BFF,
        // 'Telugu': (ch) => ch >= 0x0C00 && ch <= 0x0C7F,
        // 'Kannada': (ch) => ch >= 0x0C80 && ch <= 0x0CFF,
        // 'Malayalam': (ch) => ch >= 0x0D00 && ch <= 0x0D7F,
        // 'Sinhala': (ch) => ch >= 0x0D80 && ch <= 0x0DFF,
        // 'Thai': (ch) => ch >= 0x0E00 && ch <= 0x0E7F,
        // 'Lao': (ch) => ch >= 0x0E80 && ch <= 0x0EFF,
        // 'Tibetan': (ch) => ch >= 0x0F00 && ch <= 0x0FFF,
        // 'Myanmar': (ch) => ch >= 0x1000 && ch <= 0x109F,
        // 'Georgian': (ch) => ch >= 0x10A0 && ch <= 0x10FF,
        'Hangul Jamo': function (ch) {
            return ch >= 0x1100 && ch <= 0x11FF;
        },
        // 'Ethiopic': (ch) => ch >= 0x1200 && ch <= 0x137F,
        // 'Ethiopic Supplement': (ch) => ch >= 0x1380 && ch <= 0x139F,
        // 'Cherokee': (ch) => ch >= 0x13A0 && ch <= 0x13FF,
        'Unified Canadian Aboriginal Syllabics': function (ch) {
            return ch >= 0x1400 && ch <= 0x167F;
        },
        // 'Ogham': (ch) => ch >= 0x1680 && ch <= 0x169F,
        // 'Runic': (ch) => ch >= 0x16A0 && ch <= 0x16FF,
        // 'Tagalog': (ch) => ch >= 0x1700 && ch <= 0x171F,
        // 'Hanunoo': (ch) => ch >= 0x1720 && ch <= 0x173F,
        // 'Buhid': (ch) => ch >= 0x1740 && ch <= 0x175F,
        // 'Tagbanwa': (ch) => ch >= 0x1760 && ch <= 0x177F,
        'Khmer': function (ch) {
            return ch >= 0x1780 && ch <= 0x17FF;
        },
        // 'Mongolian': (ch) => ch >= 0x1800 && ch <= 0x18AF,
        'Unified Canadian Aboriginal Syllabics Extended': function (ch) {
            return ch >= 0x18B0 && ch <= 0x18FF;
        },
        // 'Limbu': (ch) => ch >= 0x1900 && ch <= 0x194F,
        // 'Tai Le': (ch) => ch >= 0x1950 && ch <= 0x197F,
        // 'New Tai Lue': (ch) => ch >= 0x1980 && ch <= 0x19DF,
        // 'Khmer Symbols': (ch) => ch >= 0x19E0 && ch <= 0x19FF,
        // 'Buginese': (ch) => ch >= 0x1A00 && ch <= 0x1A1F,
        // 'Tai Tham': (ch) => ch >= 0x1A20 && ch <= 0x1AAF,
        // 'Combining Diacritical Marks Extended': (ch) => ch >= 0x1AB0 && ch <= 0x1AFF,
        // 'Balinese': (ch) => ch >= 0x1B00 && ch <= 0x1B7F,
        // 'Sundanese': (ch) => ch >= 0x1B80 && ch <= 0x1BBF,
        // 'Batak': (ch) => ch >= 0x1BC0 && ch <= 0x1BFF,
        // 'Lepcha': (ch) => ch >= 0x1C00 && ch <= 0x1C4F,
        // 'Ol Chiki': (ch) => ch >= 0x1C50 && ch <= 0x1C7F,
        // 'Cyrillic Extended-C': (ch) => ch >= 0x1C80 && ch <= 0x1C8F,
        // 'Georgian Extended': (ch) => ch >= 0x1C90 && ch <= 0x1CBF,
        // 'Sundanese Supplement': (ch) => ch >= 0x1CC0 && ch <= 0x1CCF,
        // 'Vedic Extensions': (ch) => ch >= 0x1CD0 && ch <= 0x1CFF,
        // 'Phonetic Extensions': (ch) => ch >= 0x1D00 && ch <= 0x1D7F,
        // 'Phonetic Extensions Supplement': (ch) => ch >= 0x1D80 && ch <= 0x1DBF,
        // 'Combining Diacritical Marks Supplement': (ch) => ch >= 0x1DC0 && ch <= 0x1DFF,
        // 'Latin Extended Additional': (ch) => ch >= 0x1E00 && ch <= 0x1EFF,
        // 'Greek Extended': (ch) => ch >= 0x1F00 && ch <= 0x1FFF,
        'General Punctuation': function (ch) {
            return ch >= 0x2000 && ch <= 0x206F;
        },
        // 'Superscripts and Subscripts': (ch) => ch >= 0x2070 && ch <= 0x209F,
        // 'Currency Symbols': (ch) => ch >= 0x20A0 && ch <= 0x20CF,
        // 'Combining Diacritical Marks for Symbols': (ch) => ch >= 0x20D0 && ch <= 0x20FF,
        'Letterlike Symbols': function (ch) {
            return ch >= 0x2100 && ch <= 0x214F;
        },
        'Number Forms': function (ch) {
            return ch >= 0x2150 && ch <= 0x218F;
        },
        // 'Arrows': (ch) => ch >= 0x2190 && ch <= 0x21FF,
        // 'Mathematical Operators': (ch) => ch >= 0x2200 && ch <= 0x22FF,
        'Miscellaneous Technical': function (ch) {
            return ch >= 0x2300 && ch <= 0x23FF;
        },
        'Control Pictures': function (ch) {
            return ch >= 0x2400 && ch <= 0x243F;
        },
        'Optical Character Recognition': function (ch) {
            return ch >= 0x2440 && ch <= 0x245F;
        },
        'Enclosed Alphanumerics': function (ch) {
            return ch >= 0x2460 && ch <= 0x24FF;
        },
        // 'Box Drawing': (ch) => ch >= 0x2500 && ch <= 0x257F,
        // 'Block Elements': (ch) => ch >= 0x2580 && ch <= 0x259F,
        'Geometric Shapes': function (ch) {
            return ch >= 0x25A0 && ch <= 0x25FF;
        },
        'Miscellaneous Symbols': function (ch) {
            return ch >= 0x2600 && ch <= 0x26FF;
        },
        // 'Dingbats': (ch) => ch >= 0x2700 && ch <= 0x27BF,
        // 'Miscellaneous Mathematical Symbols-A': (ch) => ch >= 0x27C0 && ch <= 0x27EF,
        // 'Supplemental Arrows-A': (ch) => ch >= 0x27F0 && ch <= 0x27FF,
        // 'Braille Patterns': (ch) => ch >= 0x2800 && ch <= 0x28FF,
        // 'Supplemental Arrows-B': (ch) => ch >= 0x2900 && ch <= 0x297F,
        // 'Miscellaneous Mathematical Symbols-B': (ch) => ch >= 0x2980 && ch <= 0x29FF,
        // 'Supplemental Mathematical Operators': (ch) => ch >= 0x2A00 && ch <= 0x2AFF,
        'Miscellaneous Symbols and Arrows': function (ch) {
            return ch >= 0x2B00 && ch <= 0x2BFF;
        },
        // 'Glagolitic': (ch) => ch >= 0x2C00 && ch <= 0x2C5F,
        // 'Latin Extended-C': (ch) => ch >= 0x2C60 && ch <= 0x2C7F,
        // 'Coptic': (ch) => ch >= 0x2C80 && ch <= 0x2CFF,
        // 'Georgian Supplement': (ch) => ch >= 0x2D00 && ch <= 0x2D2F,
        // 'Tifinagh': (ch) => ch >= 0x2D30 && ch <= 0x2D7F,
        // 'Ethiopic Extended': (ch) => ch >= 0x2D80 && ch <= 0x2DDF,
        // 'Cyrillic Extended-A': (ch) => ch >= 0x2DE0 && ch <= 0x2DFF,
        // 'Supplemental Punctuation': (ch) => ch >= 0x2E00 && ch <= 0x2E7F,
        'CJK Radicals Supplement': function (ch) {
            return ch >= 0x2E80 && ch <= 0x2EFF;
        },
        'Kangxi Radicals': function (ch) {
            return ch >= 0x2F00 && ch <= 0x2FDF;
        },
        'Ideographic Description Characters': function (ch) {
            return ch >= 0x2FF0 && ch <= 0x2FFF;
        },
        'CJK Symbols and Punctuation': function (ch) {
            return ch >= 0x3000 && ch <= 0x303F;
        },
        'Hiragana': function (ch) {
            return ch >= 0x3040 && ch <= 0x309F;
        },
        'Katakana': function (ch) {
            return ch >= 0x30A0 && ch <= 0x30FF;
        },
        'Bopomofo': function (ch) {
            return ch >= 0x3100 && ch <= 0x312F;
        },
        'Hangul Compatibility Jamo': function (ch) {
            return ch >= 0x3130 && ch <= 0x318F;
        },
        'Kanbun': function (ch) {
            return ch >= 0x3190 && ch <= 0x319F;
        },
        'Bopomofo Extended': function (ch) {
            return ch >= 0x31A0 && ch <= 0x31BF;
        },
        'CJK Strokes': function (ch) {
            return ch >= 0x31C0 && ch <= 0x31EF;
        },
        'Katakana Phonetic Extensions': function (ch) {
            return ch >= 0x31F0 && ch <= 0x31FF;
        },
        'Enclosed CJK Letters and Months': function (ch) {
            return ch >= 0x3200 && ch <= 0x32FF;
        },
        'CJK Compatibility': function (ch) {
            return ch >= 0x3300 && ch <= 0x33FF;
        },
        'CJK Unified Ideographs Extension A': function (ch) {
            return ch >= 0x3400 && ch <= 0x4DBF;
        },
        'Yijing Hexagram Symbols': function (ch) {
            return ch >= 0x4DC0 && ch <= 0x4DFF;
        },
        'CJK Unified Ideographs': function (ch) {
            return ch >= 0x4E00 && ch <= 0x9FFF;
        },
        'Yi Syllables': function (ch) {
            return ch >= 0xA000 && ch <= 0xA48F;
        },
        'Yi Radicals': function (ch) {
            return ch >= 0xA490 && ch <= 0xA4CF;
        },
        // 'Lisu': (ch) => ch >= 0xA4D0 && ch <= 0xA4FF,
        // 'Vai': (ch) => ch >= 0xA500 && ch <= 0xA63F,
        // 'Cyrillic Extended-B': (ch) => ch >= 0xA640 && ch <= 0xA69F,
        // 'Bamum': (ch) => ch >= 0xA6A0 && ch <= 0xA6FF,
        // 'Modifier Tone Letters': (ch) => ch >= 0xA700 && ch <= 0xA71F,
        // 'Latin Extended-D': (ch) => ch >= 0xA720 && ch <= 0xA7FF,
        // 'Syloti Nagri': (ch) => ch >= 0xA800 && ch <= 0xA82F,
        // 'Common Indic Number Forms': (ch) => ch >= 0xA830 && ch <= 0xA83F,
        // 'Phags-pa': (ch) => ch >= 0xA840 && ch <= 0xA87F,
        // 'Saurashtra': (ch) => ch >= 0xA880 && ch <= 0xA8DF,
        // 'Devanagari Extended': (ch) => ch >= 0xA8E0 && ch <= 0xA8FF,
        // 'Kayah Li': (ch) => ch >= 0xA900 && ch <= 0xA92F,
        // 'Rejang': (ch) => ch >= 0xA930 && ch <= 0xA95F,
        'Hangul Jamo Extended-A': function (ch) {
            return ch >= 0xA960 && ch <= 0xA97F;
        },
        // 'Javanese': (ch) => ch >= 0xA980 && ch <= 0xA9DF,
        // 'Myanmar Extended-B': (ch) => ch >= 0xA9E0 && ch <= 0xA9FF,
        // 'Cham': (ch) => ch >= 0xAA00 && ch <= 0xAA5F,
        // 'Myanmar Extended-A': (ch) => ch >= 0xAA60 && ch <= 0xAA7F,
        // 'Tai Viet': (ch) => ch >= 0xAA80 && ch <= 0xAADF,
        // 'Meetei Mayek Extensions': (ch) => ch >= 0xAAE0 && ch <= 0xAAFF,
        // 'Ethiopic Extended-A': (ch) => ch >= 0xAB00 && ch <= 0xAB2F,
        // 'Latin Extended-E': (ch) => ch >= 0xAB30 && ch <= 0xAB6F,
        // 'Cherokee Supplement': (ch) => ch >= 0xAB70 && ch <= 0xABBF,
        // 'Meetei Mayek': (ch) => ch >= 0xABC0 && ch <= 0xABFF,
        'Hangul Syllables': function (ch) {
            return ch >= 0xAC00 && ch <= 0xD7AF;
        },
        'Hangul Jamo Extended-B': function (ch) {
            return ch >= 0xD7B0 && ch <= 0xD7FF;
        },
        // 'High Surrogates': (ch) => ch >= 0xD800 && ch <= 0xDB7F,
        // 'High Private Use Surrogates': (ch) => ch >= 0xDB80 && ch <= 0xDBFF,
        // 'Low Surrogates': (ch) => ch >= 0xDC00 && ch <= 0xDFFF,
        'Private Use Area': function (ch) {
            return ch >= 0xE000 && ch <= 0xF8FF;
        },
        'CJK Compatibility Ideographs': function (ch) {
            return ch >= 0xF900 && ch <= 0xFAFF;
        },
        // 'Alphabetic Presentation Forms': (ch) => ch >= 0xFB00 && ch <= 0xFB4F,
        'Arabic Presentation Forms-A': function (ch) {
            return ch >= 0xFB50 && ch <= 0xFDFF;
        },
        // 'Variation Selectors': (ch) => ch >= 0xFE00 && ch <= 0xFE0F,
        'Vertical Forms': function (ch) {
            return ch >= 0xFE10 && ch <= 0xFE1F;
        },
        // 'Combining Half Marks': (ch) => ch >= 0xFE20 && ch <= 0xFE2F,
        'CJK Compatibility Forms': function (ch) {
            return ch >= 0xFE30 && ch <= 0xFE4F;
        },
        'Small Form Variants': function (ch) {
            return ch >= 0xFE50 && ch <= 0xFE6F;
        },
        'Arabic Presentation Forms-B': function (ch) {
            return ch >= 0xFE70 && ch <= 0xFEFF;
        },
        'Halfwidth and Fullwidth Forms': function (ch) {
            return ch >= 0xFF00 && ch <= 0xFFEF;
        }
        // 'Specials': (ch) => ch >= 0xFFF0 && ch <= 0xFFFF,
        // 'Linear B Syllabary': (ch) => ch >= 0x10000 && ch <= 0x1007F,
        // 'Linear B Ideograms': (ch) => ch >= 0x10080 && ch <= 0x100FF,
        // 'Aegean Numbers': (ch) => ch >= 0x10100 && ch <= 0x1013F,
        // 'Ancient Greek Numbers': (ch) => ch >= 0x10140 && ch <= 0x1018F,
        // 'Ancient Symbols': (ch) => ch >= 0x10190 && ch <= 0x101CF,
        // 'Phaistos Disc': (ch) => ch >= 0x101D0 && ch <= 0x101FF,
        // 'Lycian': (ch) => ch >= 0x10280 && ch <= 0x1029F,
        // 'Carian': (ch) => ch >= 0x102A0 && ch <= 0x102DF,
        // 'Coptic Epact Numbers': (ch) => ch >= 0x102E0 && ch <= 0x102FF,
        // 'Old Italic': (ch) => ch >= 0x10300 && ch <= 0x1032F,
        // 'Gothic': (ch) => ch >= 0x10330 && ch <= 0x1034F,
        // 'Old Permic': (ch) => ch >= 0x10350 && ch <= 0x1037F,
        // 'Ugaritic': (ch) => ch >= 0x10380 && ch <= 0x1039F,
        // 'Old Persian': (ch) => ch >= 0x103A0 && ch <= 0x103DF,
        // 'Deseret': (ch) => ch >= 0x10400 && ch <= 0x1044F,
        // 'Shavian': (ch) => ch >= 0x10450 && ch <= 0x1047F,
        // 'Osmanya': (ch) => ch >= 0x10480 && ch <= 0x104AF,
        // 'Osage': (ch) => ch >= 0x104B0 && ch <= 0x104FF,
        // 'Elbasan': (ch) => ch >= 0x10500 && ch <= 0x1052F,
        // 'Caucasian Albanian': (ch) => ch >= 0x10530 && ch <= 0x1056F,
        // 'Linear A': (ch) => ch >= 0x10600 && ch <= 0x1077F,
        // 'Cypriot Syllabary': (ch) => ch >= 0x10800 && ch <= 0x1083F,
        // 'Imperial Aramaic': (ch) => ch >= 0x10840 && ch <= 0x1085F,
        // 'Palmyrene': (ch) => ch >= 0x10860 && ch <= 0x1087F,
        // 'Nabataean': (ch) => ch >= 0x10880 && ch <= 0x108AF,
        // 'Hatran': (ch) => ch >= 0x108E0 && ch <= 0x108FF,
        // 'Phoenician': (ch) => ch >= 0x10900 && ch <= 0x1091F,
        // 'Lydian': (ch) => ch >= 0x10920 && ch <= 0x1093F,
        // 'Meroitic Hieroglyphs': (ch) => ch >= 0x10980 && ch <= 0x1099F,
        // 'Meroitic Cursive': (ch) => ch >= 0x109A0 && ch <= 0x109FF,
        // 'Kharoshthi': (ch) => ch >= 0x10A00 && ch <= 0x10A5F,
        // 'Old South Arabian': (ch) => ch >= 0x10A60 && ch <= 0x10A7F,
        // 'Old North Arabian': (ch) => ch >= 0x10A80 && ch <= 0x10A9F,
        // 'Manichaean': (ch) => ch >= 0x10AC0 && ch <= 0x10AFF,
        // 'Avestan': (ch) => ch >= 0x10B00 && ch <= 0x10B3F,
        // 'Inscriptional Parthian': (ch) => ch >= 0x10B40 && ch <= 0x10B5F,
        // 'Inscriptional Pahlavi': (ch) => ch >= 0x10B60 && ch <= 0x10B7F,
        // 'Psalter Pahlavi': (ch) => ch >= 0x10B80 && ch <= 0x10BAF,
        // 'Old Turkic': (ch) => ch >= 0x10C00 && ch <= 0x10C4F,
        // 'Old Hungarian': (ch) => ch >= 0x10C80 && ch <= 0x10CFF,
        // 'Hanifi Rohingya': (ch) => ch >= 0x10D00 && ch <= 0x10D3F,
        // 'Rumi Numeral Symbols': (ch) => ch >= 0x10E60 && ch <= 0x10E7F,
        // 'Old Sogdian': (ch) => ch >= 0x10F00 && ch <= 0x10F2F,
        // 'Sogdian': (ch) => ch >= 0x10F30 && ch <= 0x10F6F,
        // 'Elymaic': (ch) => ch >= 0x10FE0 && ch <= 0x10FFF,
        // 'Brahmi': (ch) => ch >= 0x11000 && ch <= 0x1107F,
        // 'Kaithi': (ch) => ch >= 0x11080 && ch <= 0x110CF,
        // 'Sora Sompeng': (ch) => ch >= 0x110D0 && ch <= 0x110FF,
        // 'Chakma': (ch) => ch >= 0x11100 && ch <= 0x1114F,
        // 'Mahajani': (ch) => ch >= 0x11150 && ch <= 0x1117F,
        // 'Sharada': (ch) => ch >= 0x11180 && ch <= 0x111DF,
        // 'Sinhala Archaic Numbers': (ch) => ch >= 0x111E0 && ch <= 0x111FF,
        // 'Khojki': (ch) => ch >= 0x11200 && ch <= 0x1124F,
        // 'Multani': (ch) => ch >= 0x11280 && ch <= 0x112AF,
        // 'Khudawadi': (ch) => ch >= 0x112B0 && ch <= 0x112FF,
        // 'Grantha': (ch) => ch >= 0x11300 && ch <= 0x1137F,
        // 'Newa': (ch) => ch >= 0x11400 && ch <= 0x1147F,
        // 'Tirhuta': (ch) => ch >= 0x11480 && ch <= 0x114DF,
        // 'Siddham': (ch) => ch >= 0x11580 && ch <= 0x115FF,
        // 'Modi': (ch) => ch >= 0x11600 && ch <= 0x1165F,
        // 'Mongolian Supplement': (ch) => ch >= 0x11660 && ch <= 0x1167F,
        // 'Takri': (ch) => ch >= 0x11680 && ch <= 0x116CF,
        // 'Ahom': (ch) => ch >= 0x11700 && ch <= 0x1173F,
        // 'Dogra': (ch) => ch >= 0x11800 && ch <= 0x1184F,
        // 'Warang Citi': (ch) => ch >= 0x118A0 && ch <= 0x118FF,
        // 'Nandinagari': (ch) => ch >= 0x119A0 && ch <= 0x119FF,
        // 'Zanabazar Square': (ch) => ch >= 0x11A00 && ch <= 0x11A4F,
        // 'Soyombo': (ch) => ch >= 0x11A50 && ch <= 0x11AAF,
        // 'Pau Cin Hau': (ch) => ch >= 0x11AC0 && ch <= 0x11AFF,
        // 'Bhaiksuki': (ch) => ch >= 0x11C00 && ch <= 0x11C6F,
        // 'Marchen': (ch) => ch >= 0x11C70 && ch <= 0x11CBF,
        // 'Masaram Gondi': (ch) => ch >= 0x11D00 && ch <= 0x11D5F,
        // 'Gunjala Gondi': (ch) => ch >= 0x11D60 && ch <= 0x11DAF,
        // 'Makasar': (ch) => ch >= 0x11EE0 && ch <= 0x11EFF,
        // 'Tamil Supplement': (ch) => ch >= 0x11FC0 && ch <= 0x11FFF,
        // 'Cuneiform': (ch) => ch >= 0x12000 && ch <= 0x123FF,
        // 'Cuneiform Numbers and Punctuation': (ch) => ch >= 0x12400 && ch <= 0x1247F,
        // 'Early Dynastic Cuneiform': (ch) => ch >= 0x12480 && ch <= 0x1254F,
        // 'Egyptian Hieroglyphs': (ch) => ch >= 0x13000 && ch <= 0x1342F,
        // 'Egyptian Hieroglyph Format Controls': (ch) => ch >= 0x13430 && ch <= 0x1343F,
        // 'Anatolian Hieroglyphs': (ch) => ch >= 0x14400 && ch <= 0x1467F,
        // 'Bamum Supplement': (ch) => ch >= 0x16800 && ch <= 0x16A3F,
        // 'Mro': (ch) => ch >= 0x16A40 && ch <= 0x16A6F,
        // 'Bassa Vah': (ch) => ch >= 0x16AD0 && ch <= 0x16AFF,
        // 'Pahawh Hmong': (ch) => ch >= 0x16B00 && ch <= 0x16B8F,
        // 'Medefaidrin': (ch) => ch >= 0x16E40 && ch <= 0x16E9F,
        // 'Miao': (ch) => ch >= 0x16F00 && ch <= 0x16F9F,
        // 'Ideographic Symbols and Punctuation': (ch) => ch >= 0x16FE0 && ch <= 0x16FFF,
        // 'Tangut': (ch) => ch >= 0x17000 && ch <= 0x187FF,
        // 'Tangut Components': (ch) => ch >= 0x18800 && ch <= 0x18AFF,
        // 'Kana Supplement': (ch) => ch >= 0x1B000 && ch <= 0x1B0FF,
        // 'Kana Extended-A': (ch) => ch >= 0x1B100 && ch <= 0x1B12F,
        // 'Small Kana Extension': (ch) => ch >= 0x1B130 && ch <= 0x1B16F,
        // 'Nushu': (ch) => ch >= 0x1B170 && ch <= 0x1B2FF,
        // 'Duployan': (ch) => ch >= 0x1BC00 && ch <= 0x1BC9F,
        // 'Shorthand Format Controls': (ch) => ch >= 0x1BCA0 && ch <= 0x1BCAF,
        // 'Byzantine Musical Symbols': (ch) => ch >= 0x1D000 && ch <= 0x1D0FF,
        // 'Musical Symbols': (ch) => ch >= 0x1D100 && ch <= 0x1D1FF,
        // 'Ancient Greek Musical Notation': (ch) => ch >= 0x1D200 && ch <= 0x1D24F,
        // 'Mayan Numerals': (ch) => ch >= 0x1D2E0 && ch <= 0x1D2FF,
        // 'Tai Xuan Jing Symbols': (ch) => ch >= 0x1D300 && ch <= 0x1D35F,
        // 'Counting Rod Numerals': (ch) => ch >= 0x1D360 && ch <= 0x1D37F,
        // 'Mathematical Alphanumeric Symbols': (ch) => ch >= 0x1D400 && ch <= 0x1D7FF,
        // 'Sutton SignWriting': (ch) => ch >= 0x1D800 && ch <= 0x1DAAF,
        // 'Glagolitic Supplement': (ch) => ch >= 0x1E000 && ch <= 0x1E02F,
        // 'Nyiakeng Puachue Hmong': (ch) => ch >= 0x1E100 && ch <= 0x1E14F,
        // 'Wancho': (ch) => ch >= 0x1E2C0 && ch <= 0x1E2FF,
        // 'Mende Kikakui': (ch) => ch >= 0x1E800 && ch <= 0x1E8DF,
        // 'Adlam': (ch) => ch >= 0x1E900 && ch <= 0x1E95F,
        // 'Indic Siyaq Numbers': (ch) => ch >= 0x1EC70 && ch <= 0x1ECBF,
        // 'Ottoman Siyaq Numbers': (ch) => ch >= 0x1ED00 && ch <= 0x1ED4F,
        // 'Arabic Mathematical Alphabetic Symbols': (ch) => ch >= 0x1EE00 && ch <= 0x1EEFF,
        // 'Mahjong Tiles': (ch) => ch >= 0x1F000 && ch <= 0x1F02F,
        // 'Domino Tiles': (ch) => ch >= 0x1F030 && ch <= 0x1F09F,
        // 'Playing Cards': (ch) => ch >= 0x1F0A0 && ch <= 0x1F0FF,
        // 'Enclosed Alphanumeric Supplement': (ch) => ch >= 0x1F100 && ch <= 0x1F1FF,
        // 'Enclosed Ideographic Supplement': (ch) => ch >= 0x1F200 && ch <= 0x1F2FF,
        // 'Miscellaneous Symbols and Pictographs': (ch) => ch >= 0x1F300 && ch <= 0x1F5FF,
        // 'Emoticons': (ch) => ch >= 0x1F600 && ch <= 0x1F64F,
        // 'Ornamental Dingbats': (ch) => ch >= 0x1F650 && ch <= 0x1F67F,
        // 'Transport and Map Symbols': (ch) => ch >= 0x1F680 && ch <= 0x1F6FF,
        // 'Alchemical Symbols': (ch) => ch >= 0x1F700 && ch <= 0x1F77F,
        // 'Geometric Shapes Extended': (ch) => ch >= 0x1F780 && ch <= 0x1F7FF,
        // 'Supplemental Arrows-C': (ch) => ch >= 0x1F800 && ch <= 0x1F8FF,
        // 'Supplemental Symbols and Pictographs': (ch) => ch >= 0x1F900 && ch <= 0x1F9FF,
        // 'Chess Symbols': (ch) => ch >= 0x1FA00 && ch <= 0x1FA6F,
        // 'Symbols and Pictographs Extended-A': (ch) => ch >= 0x1FA70 && ch <= 0x1FAFF,
        // 'CJK Unified Ideographs Extension B': (ch) => ch >= 0x20000 && ch <= 0x2A6DF,
        // 'CJK Unified Ideographs Extension C': (ch) => ch >= 0x2A700 && ch <= 0x2B73F,
        // 'CJK Unified Ideographs Extension D': (ch) => ch >= 0x2B740 && ch <= 0x2B81F,
        // 'CJK Unified Ideographs Extension E': (ch) => ch >= 0x2B820 && ch <= 0x2CEAF,
        // 'CJK Unified Ideographs Extension F': (ch) => ch >= 0x2CEB0 && ch <= 0x2EBEF,
        // 'CJK Compatibility Ideographs Supplement': (ch) => ch >= 0x2F800 && ch <= 0x2FA1F,
        // 'Tags': (ch) => ch >= 0xE0000 && ch <= 0xE007F,
        // 'Variation Selectors Supplement': (ch) => ch >= 0xE0100 && ch <= 0xE01EF,
        // 'Supplementary Private Use Area-A': (ch) => ch >= 0xF0000 && ch <= 0xFFFFF,
        // 'Supplementary Private Use Area-B': (ch) => ch >= 0x100000 && ch <= 0x10FFFF,
    };

    exports.isChar = unicodeBlockLookup;

    function allowsLetterSpacing(chars) {
        for (var i = 0, list = chars; i < list.length; i += 1) {
            var ch = list[i];

            if (!charAllowsLetterSpacing(ch.charCodeAt(0))) {
                return false;
            }
        }
        return true;
    }

    function charAllowsLetterSpacing(ch) {
        if (unicodeBlockLookup['Arabic'](ch)) {
            return false;
        }
        if (unicodeBlockLookup['Arabic Supplement'](ch)) {
            return false;
        }
        if (unicodeBlockLookup['Arabic Extended-A'](ch)) {
            return false;
        }
        if (unicodeBlockLookup['Arabic Presentation Forms-A'](ch)) {
            return false;
        }
        if (unicodeBlockLookup['Arabic Presentation Forms-B'](ch)) {
            return false;
        }

        return true;
    }

    function charHasUprightVerticalOrientation(ch) {
        if (ch === 0x02EA /* modifier letter yin departing tone mark */ ||
            ch === 0x02EB /* modifier letter yang departing tone mark */) {
            return true;
        }

        // Return early for characters outside all ranges whose characters remain
        // upright in vertical writing mode.
        if (ch < 0x1100) {
            return false;
        }

        if (unicodeBlockLookup['Bopomofo Extended'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Bopomofo'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Compatibility Forms'](ch)) {
            if (!((ch >= 0xFE49 /* dashed overline */ && ch <= 0xFE4F) /* wavy low line */)) {
                return true;
            }
        }
        if (unicodeBlockLookup['CJK Compatibility Ideographs'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Compatibility'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Radicals Supplement'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Strokes'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Symbols and Punctuation'](ch)) {
            if (!((ch >= 0x3008 /* left angle bracket */ && ch <= 0x3011) /* right black lenticular bracket */) &&
                !((ch >= 0x3014 /* left tortoise shell bracket */ && ch <= 0x301F) /* low double prime quotation mark */) &&
                ch !== 0x3030 /* wavy dash */) {
                return true;
            }
        }
        if (unicodeBlockLookup['CJK Unified Ideographs Extension A'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Unified Ideographs'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Enclosed CJK Letters and Months'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Hangul Compatibility Jamo'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Hangul Jamo Extended-A'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Hangul Jamo Extended-B'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Hangul Jamo'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Hangul Syllables'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Hiragana'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Ideographic Description Characters'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Kanbun'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Kangxi Radicals'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Katakana Phonetic Extensions'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Katakana'](ch)) {
            if (ch !== 0x30FC /* katakana-hiragana prolonged sound mark */) {
                return true;
            }
        }
        if (unicodeBlockLookup['Halfwidth and Fullwidth Forms'](ch)) {
            if (ch !== 0xFF08 /* fullwidth left parenthesis */ &&
                ch !== 0xFF09 /* fullwidth right parenthesis */ &&
                ch !== 0xFF0D /* fullwidth hyphen-minus */ &&
                !((ch >= 0xFF1A /* fullwidth colon */ && ch <= 0xFF1E) /* fullwidth greater-than sign */) &&
                ch !== 0xFF3B /* fullwidth left square bracket */ &&
                ch !== 0xFF3D /* fullwidth right square bracket */ &&
                ch !== 0xFF3F /* fullwidth low line */ &&
                !(ch >= 0xFF5B /* fullwidth left curly bracket */ && ch <= 0xFFDF) &&
                ch !== 0xFFE3 /* fullwidth macron */ &&
                !(ch >= 0xFFE8 /* halfwidth forms light vertical */ && ch <= 0xFFEF)) {
                return true;
            }
        }
        if (unicodeBlockLookup['Small Form Variants'](ch)) {
            if (!((ch >= 0xFE58 /* small em dash */ && ch <= 0xFE5E) /* small right tortoise shell bracket */) &&
                !((ch >= 0xFE63 /* small hyphen-minus */ && ch <= 0xFE66) /* small equals sign */)) {
                return true;
            }
        }
        if (unicodeBlockLookup['Unified Canadian Aboriginal Syllabics'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Unified Canadian Aboriginal Syllabics Extended'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Vertical Forms'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Yijing Hexagram Symbols'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Yi Syllables'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Yi Radicals'](ch)) {
            return true;
        }

        return false;
    }



    exports.allowsLetterSpacing = allowsLetterSpacing;
    exports.charHasUprightVerticalOrientation = charHasUprightVerticalOrientation;

    function sort(ids, positions, left, right) {
        if (left >= right) {
            return;
        }

        var pivot = ids[(left + right) >> 1];
        var i = left - 1;
        var j = right + 1;

        while (true) {
            do {
                i++;
            } while (ids[i] < pivot);
            do {
                j--;
            } while (ids[j] > pivot);
            if (i >= j) {
                break;
            }
            swap(ids, i, j);
            swap(positions, 3 * i, 3 * j);
            swap(positions, 3 * i + 1, 3 * j + 1);
            swap(positions, 3 * i + 2, 3 * j + 2);
        }

        sort(ids, positions, left, j);
        sort(ids, positions, j + 1, right);
    }

    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    exports.sort = sort;
    exports.swap = swap;

    function supportsPropertyExpression(spec) {
        return spec['property-type'] === 'data-driven' || spec['property-type'] === 'cross-faded-data-driven';
    }

    exports.supportsPropertyExpression = supportsPropertyExpression;

    function paintAttributeNames(property, type) {
        var attributeNameExceptions = {
            'text-opacity': ['opacity'],
            'icon-opacity': ['opacity'],
            'text-color': ['fill_color'],
            'icon-color': ['fill_color'],
            'text-halo-color': ['halo_color'],
            'icon-halo-color': ['halo_color'],
            'text-halo-blur': ['halo_blur'],
            'icon-halo-blur': ['halo_blur'],
            'text-halo-width': ['halo_width'],
            'icon-halo-width': ['halo_width'],
            'line-gap-width': ['gapwidth'],
            'line-pattern': ['pattern_to', 'pattern_from'],
            'fill-pattern': ['pattern_to', 'pattern_from'],
            'fill-extrusion-pattern': ['pattern_to', 'pattern_from']
        };

        return attributeNameExceptions[property] ||
            [property.replace((type + "-"), '').replace(/-/g, '_')];
    }

    exports.paintAttributeNames = paintAttributeNames;


    function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
    }

    function quickselectStep(arr, k, left, right, compare) {

        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                quickselectStep(arr, k, newLeft, newRight, compare);
            }

            var t = arr[k];
            var i = left;
            var j = right;

            swap$1(arr, left, k);
            if (compare(arr[right], t) > 0) {
                swap$1(arr, left, right);
            }

            while (i < j) {
                swap$1(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) {
                    i++;
                }
                while (compare(arr[j], t) > 0) {
                    j--;
                }
            }

            if (compare(arr[left], t) === 0) {
                swap$1(arr, left, j);
            } else {
                j++;
                swap$1(arr, j, right);
            }

            if (j <= k) {
                left = j + 1;
            }
            if (k <= j) {
                right = j - 1;
            }
        }
    }

    function swap$1(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }














    function charHasNeutralVerticalOrientation(ch) {
        if (unicodeBlockLookup['Latin-1 Supplement'](ch)) {
            if (ch === 0x00A7 /* section sign */ ||
                ch === 0x00A9 /* copyright sign */ ||
                ch === 0x00AE /* registered sign */ ||
                ch === 0x00B1 /* plus-minus sign */ ||
                ch === 0x00BC /* vulgar fraction one quarter */ ||
                ch === 0x00BD /* vulgar fraction one half */ ||
                ch === 0x00BE /* vulgar fraction three quarters */ ||
                ch === 0x00D7 /* multiplication sign */ ||
                ch === 0x00F7 /* division sign */) {
                return true;
            }
        }
        if (unicodeBlockLookup['General Punctuation'](ch)) {
            if (ch === 0x2016 /* double vertical line */ ||
                ch === 0x2020 /* dagger */ ||
                ch === 0x2021 /* double dagger */ ||
                ch === 0x2030 /* per mille sign */ ||
                ch === 0x2031 /* per ten thousand sign */ ||
                ch === 0x203B /* reference mark */ ||
                ch === 0x203C /* double exclamation mark */ ||
                ch === 0x2042 /* asterism */ ||
                ch === 0x2047 /* double question mark */ ||
                ch === 0x2048 /* question exclamation mark */ ||
                ch === 0x2049 /* exclamation question mark */ ||
                ch === 0x2051 /* two asterisks aligned vertically */) {
                return true;
            }
        }
        if (unicodeBlockLookup['Letterlike Symbols'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Number Forms'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Miscellaneous Technical'](ch)) {
            if ((ch >= 0x2300 /* diameter sign */ && ch <= 0x2307 /* wavy line */) ||
                (ch >= 0x230C /* bottom right crop */ && ch <= 0x231F /* bottom right corner */) ||
                (ch >= 0x2324 /* up arrowhead between two horizontal bars */ && ch <= 0x2328 /* keyboard */) ||
                ch === 0x232B /* erase to the left */ ||
                (ch >= 0x237D /* shouldered open box */ && ch <= 0x239A /* clear screen symbol */) ||
                (ch >= 0x23BE /* dentistry symbol light vertical and top right */ && ch <= 0x23CD /* square foot */) ||
                ch === 0x23CF /* eject symbol */ ||
                (ch >= 0x23D1 /* metrical breve */ && ch <= 0x23DB /* fuse */) ||
                (ch >= 0x23E2 /* white trapezium */ && ch <= 0x23FF)) {
                return true;
            }
        }
        if (unicodeBlockLookup['Control Pictures'](ch) && ch !== 0x2423 /* open box */) {
            return true;
        }
        if (unicodeBlockLookup['Optical Character Recognition'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Enclosed Alphanumerics'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Geometric Shapes'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Miscellaneous Symbols'](ch)) {
            if (!((ch >= 0x261A /* black left pointing index */ && ch <= 0x261F) /* white down pointing index */)) {
                return true;
            }
        }
        if (unicodeBlockLookup['Miscellaneous Symbols and Arrows'](ch)) {
            if ((ch >= 0x2B12 /* square with top half black */ && ch <= 0x2B2F /* white vertical ellipse */) ||
                (ch >= 0x2B50 /* white medium star */ && ch <= 0x2B59 /* heavy circled saltire */) ||
                (ch >= 0x2BB8 /* upwards white arrow from bar with horizontal bar */ && ch <= 0x2BEB)) {
                return true;
            }
        }
        if (unicodeBlockLookup['CJK Symbols and Punctuation'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Katakana'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Private Use Area'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['CJK Compatibility Forms'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Small Form Variants'](ch)) {
            return true;
        }
        if (unicodeBlockLookup['Halfwidth and Fullwidth Forms'](ch)) {
            return true;
        }

        if (ch === 0x221E /* infinity */ ||
            ch === 0x2234 /* therefore */ ||
            ch === 0x2235 /* because */ ||
            (ch >= 0x2700 /* black safety scissors */ && ch <= 0x2767 /* rotated floral heart bullet */) ||
            (ch >= 0x2776 /* dingbat negative circled digit one */ && ch <= 0x2793 /* dingbat negative circled sans-serif number ten */) ||
            ch === 0xFFFC /* object replacement character */ ||
            ch === 0xFFFD /* replacement character */) {
            return true;
        }

        return false;
    }

    function charHasRotatedVerticalOrientation(ch) {
        return !(charHasUprightVerticalOrientation(ch) ||
            charHasNeutralVerticalOrientation(ch));
    }

    function getLabelPlaneMatrix(posMatrix, pitchWithMap, rotateWithMap, transform, pixelsToTileUnits) {
        var m = glMatrix.mat4.create();
        if (pitchWithMap) {
            glMatrix.mat4.scale(m, m, [1 / pixelsToTileUnits, 1 / pixelsToTileUnits, 1]);
            if (!rotateWithMap) {
                glMatrix.mat4.rotateZ(m, m, transform.angle);
            }
        } else {
            glMatrix.mat4.multiply(m, transform.labelPlaneMatrix, posMatrix);
        }
        return m;
    }

    exports.getLabelPlaneMatrix = getLabelPlaneMatrix;

    function getGlCoordMatrix(posMatrix, pitchWithMap, rotateWithMap, transform, pixelsToTileUnits) {
        if (pitchWithMap) {
            var m = glMatrix.mat4.clone(posMatrix);
            glMatrix.mat4.scale(m, m, [pixelsToTileUnits, pixelsToTileUnits, 1]);
            if (!rotateWithMap) {
                glMatrix.mat4.rotateZ(m, m, -transform.angle);
            }
            return m;
        } else {
            return transform.glCoordMatrix;
        }
    }

    exports.getGlCoordMatrix = getGlCoordMatrix;

    function translate$3(out, a, v) {
        var x = v[0],
            y = v[1],
            z = v[2];
        var a00, a01, a02, a03;
        var a10, a11, a12, a13;
        var a20, a21, a22, a23;

        if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            out[0] = a00;
            out[1] = a01;
            out[2] = a02;
            out[3] = a03;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a20;
            out[9] = a21;
            out[10] = a22;
            out[11] = a23;
            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }

        return out;
    }

    function translatePosMatrix(matrix, tile, translate, translateAnchor, inViewportPixelUnitsUnits, rotate, zoom) {
        if (!translate[0] && !translate[1]) {
            return matrix;
        }

        var angle = inViewportPixelUnitsUnits ?
            (translateAnchor === 'map' ? rotate : 0) :
            (translateAnchor === 'viewport' ? -rotate : 0);

        if (angle) {
            var sinA = Math.sin(angle);
            var cosA = Math.cos(angle);
            translate = [
                translate[0] * cosA - translate[1] * sinA,
                translate[0] * sinA + translate[1] * cosA
            ];
        }

        var translation = [
            inViewportPixelUnitsUnits ? translate[0] : pixelsToTileUnits(tile, translate[0], zoom),
            inViewportPixelUnitsUnits ? translate[1] : pixelsToTileUnits(tile, translate[1], zoom),
            0
        ];

        var translatedMatrix = new Float32Array(16);
        translate$3(translatedMatrix, matrix, translation);
        return translatedMatrix;
    }
    exports.translatePosMatrix = translatePosMatrix;

    function clamp(n, min, max) {
        return Math.min(max, Math.max(min, n));
    }

    function evaluateSizeForZoom(sizeData, zoom) {
        var uSizeT = 0;
        var uSize = 0;

        if (sizeData.kind === 'constant') {
            uSize = sizeData.layoutSize;

        } else if (sizeData.kind !== 'source') {
            var interpolationType = sizeData.interpolationType;
            var minZoom = sizeData.minZoom;
            var maxZoom = sizeData.maxZoom;

            // Even though we could get the exact value of the camera function
            // at z = tr.zoom, we intentionally do not: instead, we interpolate
            // between the camera function values at a pair of zoom stops covering
            // [tileZoom, tileZoom + 1] in order to be consistent with this
            // restriction on composite functions
            var t = !interpolationType ? 0 : clamp(
                Interpolate.interpolationFactor(interpolationType, zoom, minZoom, maxZoom), 0, 1);

            if (sizeData.kind === 'camera') {
                uSize = number(sizeData.minSize, sizeData.maxSize, t);
            } else {
                uSizeT = t;
            }
        }

        return {uSizeT: uSizeT, uSize: uSize};
    }

    exports.evaluateSizeForZoom = evaluateSizeForZoom;

    function xyTransformMat4(out, a, m) {
        var x = a[0], y = a[1];
        out[0] = m[0] * x + m[4] * y + m[12];
        out[1] = m[1] * x + m[5] * y + m[13];
        out[3] = m[3] * x + m[7] * y + m[15];
        return out;
    }

    exports.xyTransformMat4 = xyTransformMat4;

    var SIZE_PACK_FACTOR = 256;

    function number(a, b, t) {
        return (a * (1 - t)) + (b * t);
    }

    function evaluateSizeForFeature(sizeData,
                                    ref,
                                    ref$1) {
        var uSize = ref.uSize;
        var uSizeT = ref.uSizeT;
        var lowerSize = ref$1.lowerSize;
        var upperSize = ref$1.upperSize;

        if (sizeData.kind === 'source') {
            return lowerSize / SIZE_PACK_FACTOR;
        } else if (sizeData.kind === 'composite') {
            return number(lowerSize / SIZE_PACK_FACTOR, upperSize / SIZE_PACK_FACTOR, uSizeT);
        }
        return uSize;
    }

    exports.evaluateSizeForFeature = evaluateSizeForFeature;

    function transformMat4(out, a, m) {
        var x = a[0],
            y = a[1],
            z = a[2],
            w = a[3];
        out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
        return out;
    }

    exports.transformMat4 = transformMat4;

    var WritingMode = {
        horizontal: 1,
        vertical: 2,
        horizontalOnly: 3
    };

    function requiresOrientationChange(writingMode, firstPoint, lastPoint, aspectRatio) {
        if (writingMode === WritingMode.horizontal) {
            // On top of choosing whether to flip, choose whether to render this version of the glyphs or the alternate
            // vertical glyphs. We can't just filter out vertical glyphs in the horizontal range because the horizontal
            // and vertical versions can have slightly different projections which could lead to angles where both or
            // neither showed.
            var rise = Math.abs(lastPoint.y - firstPoint.y);
            var run = Math.abs(lastPoint.x - firstPoint.x) * aspectRatio;
            if (rise > run) {
                return {useVertical: true};
            }
        }

        if (writingMode === WritingMode.vertical ? firstPoint.y < lastPoint.y : firstPoint.x > lastPoint.x) {
            // Includes "horizontalOnly" case for labels without vertical glyphs
            return {needsFlipping: true};
        }

        return null;
    }

    function project(point, matrix) {
        var pos = [point.x, point.y, 0, 1];
        xyTransformMat4(pos, pos, matrix);
        var w = pos[3];
        return {
            point: new pointGeometry(pos[0] / w, pos[1] / w),
            signedDistanceFromCamera: w
        };
    }

    function placeGlyphAlongLine(offsetX,
                                 lineOffsetX,
                                 lineOffsetY,
                                 flip,
                                 anchorPoint,
                                 tileAnchorPoint,
                                 anchorSegment,
                                 lineStartIndex,
                                 lineEndIndex,
                                 lineVertexArray,
                                 labelPlaneMatrix,
                                 projectionCache,
                                 returnTileDistance) {

        var combinedOffsetX = flip ?
            offsetX - lineOffsetX :
            offsetX + lineOffsetX;

        var dir = combinedOffsetX > 0 ? 1 : -1;

        var angle = 0;
        if (flip) {
            // The label needs to be flipped to keep text upright.
            // Iterate in the reverse direction.
            dir *= -1;
            angle = Math.PI;
        }

        if (dir < 0) {
            angle += Math.PI;
        }

        var currentIndex = dir > 0 ?
            lineStartIndex + anchorSegment :
            lineStartIndex + anchorSegment + 1;

        var initialIndex = currentIndex;
        var current = anchorPoint;
        var prev = anchorPoint;
        var distanceToPrev = 0;
        var currentSegmentDistance = 0;
        var absOffsetX = Math.abs(combinedOffsetX);

        while (distanceToPrev + currentSegmentDistance <= absOffsetX) {
            currentIndex += dir;

            // offset does not fit on the projected line
            if (currentIndex < lineStartIndex || currentIndex >= lineEndIndex) {
                return null;
            }

            prev = current;

            current = projectionCache[currentIndex];
            if (current === undefined) {
                var currentVertex = new pointGeometry(lineVertexArray.getx(currentIndex), lineVertexArray.gety(currentIndex));
                var projection = project(currentVertex, labelPlaneMatrix);
                if (projection.signedDistanceFromCamera > 0) {
                    current = projectionCache[currentIndex] = projection.point;
                } else {
                    // The vertex is behind the plane of the camera, so we can't project it
                    // Instead, we'll create a vertex along the line that's far enough to include the glyph
                    var previousLineVertexIndex = currentIndex - dir;
                    var previousTilePoint = distanceToPrev === 0 ?
                        tileAnchorPoint :
                        new pointGeometry(lineVertexArray.getx(previousLineVertexIndex), lineVertexArray.gety(previousLineVertexIndex));
                    // Don't cache because the new vertex might not be far enough out for future glyphs on the same segment
                    current = projectTruncatedLineSegment(previousTilePoint, currentVertex, prev, absOffsetX - distanceToPrev + 1, labelPlaneMatrix);
                }
            }

            distanceToPrev += currentSegmentDistance;
            currentSegmentDistance = prev.dist(current);
        }

        // The point is on the current segment. Interpolate to find it.
        var segmentInterpolationT = (absOffsetX - distanceToPrev) / currentSegmentDistance;
        var prevToCurrent = current.sub(prev);
        var p = prevToCurrent.mult(segmentInterpolationT)._add(prev);

        // offset the point from the line to text-offset and icon-offset
        p._add(prevToCurrent._unit()._perp()._mult(lineOffsetY * dir));

        var segmentAngle = angle + Math.atan2(current.y - prev.y, current.x - prev.x);

        return {
            point: p,
            angle: segmentAngle,
            tileDistance: returnTileDistance ?
                {
                    prevTileDistance: (currentIndex - dir) === initialIndex ? 0 : lineVertexArray.gettileUnitDistanceFromAnchor(currentIndex - dir),
                    lastSegmentViewportDistance: absOffsetX - distanceToPrev
                } : null
        };
    }

    function projectTruncatedLineSegment(previousTilePoint, currentTilePoint, previousProjectedPoint, minimumLength, projectionMatrix) {
        // We are assuming "previousTilePoint" won't project to a point within one unit of the camera plane
        // If it did, that would mean our label extended all the way out from within the viewport to a (very distant)
        // point near the plane of the camera. We wouldn't be able to render the label anyway once it crossed the
        // plane of the camera.
        var projectedUnitVertex = project(previousTilePoint.add(previousTilePoint.sub(currentTilePoint)._unit()), projectionMatrix).point;
        var projectedUnitSegment = previousProjectedPoint.sub(projectedUnitVertex);

        return previousProjectedPoint.add(projectedUnitSegment._mult(minimumLength / projectedUnitSegment.mag()));
    }

    function addDynamicAttributes(dynamicLayoutVertexArray, p, angle) {
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
    }


    function placeFirstAndLastGlyph(fontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance) {
        var glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;
        var lineStartIndex = symbol.lineStartIndex;
        var lineEndIndex = symbol.lineStartIndex + symbol.lineLength;

        var firstGlyphOffset = glyphOffsetArray.getoffsetX(symbol.glyphStartIndex);
        var lastGlyphOffset = glyphOffsetArray.getoffsetX(glyphEndIndex - 1);

        var firstPlacedGlyph = placeGlyphAlongLine(fontScale * firstGlyphOffset, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,
            lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance);
        if (!firstPlacedGlyph) {
            return null;
        }

        var lastPlacedGlyph = placeGlyphAlongLine(fontScale * lastGlyphOffset, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,
            lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance);
        if (!lastPlacedGlyph) {
            return null;
        }

        return {first: firstPlacedGlyph, last: lastPlacedGlyph};
    }

    function placeGlyphsAlongLine(symbol, fontSize, flip, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix, glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio) {
        var fontScale = fontSize / 24;
        var lineOffsetX = symbol.lineOffsetX * fontScale;
        var lineOffsetY = symbol.lineOffsetY * fontScale;

        var placedGlyphs;
        if (symbol.numGlyphs > 1) {
            var glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;
            var lineStartIndex = symbol.lineStartIndex;
            var lineEndIndex = symbol.lineStartIndex + symbol.lineLength;

            // Place the first and the last glyph in the label first, so we can figure out
            // the overall orientation of the label and determine whether it needs to be flipped in keepUpright mode
            var firstAndLastGlyph = placeFirstAndLastGlyph(fontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache, false);
            if (!firstAndLastGlyph) {
                return {notEnoughRoom: true};
            }
            var firstPoint = project(firstAndLastGlyph.first.point, glCoordMatrix).point;
            var lastPoint = project(firstAndLastGlyph.last.point, glCoordMatrix).point;

            if (keepUpright && !flip) {
                var orientationChange = requiresOrientationChange(symbol.writingMode, firstPoint, lastPoint, aspectRatio);
                if (orientationChange) {
                    return orientationChange;
                }
            }

            placedGlyphs = [firstAndLastGlyph.first];
            for (var glyphIndex = symbol.glyphStartIndex + 1; glyphIndex < glyphEndIndex - 1; glyphIndex++) {
                // Since first and last glyph fit on the line, we're sure that the rest of the glyphs can be placed
                // $FlowFixMe
                placedGlyphs.push(placeGlyphAlongLine(fontScale * glyphOffsetArray.getoffsetX(glyphIndex), lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,
                    lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, false));
            }
            placedGlyphs.push(firstAndLastGlyph.last);
        } else {
            // Only a single glyph to place
            // So, determine whether to flip based on projected angle of the line segment it's on
            if (keepUpright && !flip) {
                var a = project(tileAnchorPoint, posMatrix).point;
                var tileVertexIndex = (symbol.lineStartIndex + symbol.segment + 1);
                // $FlowFixMe
                var tileSegmentEnd = new pointGeometry(lineVertexArray.getx(tileVertexIndex), lineVertexArray.gety(tileVertexIndex));
                var projectedVertex = project(tileSegmentEnd, posMatrix);
                // We know the anchor will be in the viewport, but the end of the line segment may be
                // behind the plane of the camera, in which case we can use a point at any arbitrary (closer)
                // point on the segment.
                var b = (projectedVertex.signedDistanceFromCamera > 0) ?
                    projectedVertex.point :
                    projectTruncatedLineSegment(tileAnchorPoint, tileSegmentEnd, a, 1, posMatrix);


                var orientationChange$1 = requiresOrientationChange(symbol.writingMode, a, b, aspectRatio);
                if (orientationChange$1) {
                    return orientationChange$1;
                }
            }
            // $FlowFixMe
            var singleGlyph = placeGlyphAlongLine(fontScale * glyphOffsetArray.getoffsetX(symbol.glyphStartIndex), lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,
                symbol.lineStartIndex, symbol.lineStartIndex + symbol.lineLength, lineVertexArray, labelPlaneMatrix, projectionCache, false);
            if (!singleGlyph) {
                return {notEnoughRoom: true};
            }

            placedGlyphs = [singleGlyph];
        }

        for (var i = 0, list = placedGlyphs; i < list.length; i += 1) {
            var glyph = list[i];

            addDynamicAttributes(dynamicLayoutVertexArray, glyph.point, glyph.angle);
        }
        return {};
    }

    exports.placeGlyphsAlongLine = placeGlyphsAlongLine;
});
},
'com/huayun/webgis/geometry/Point2D':function(){
define([], function () {
    function Point(x, y) {
        this.x = x;
        this.y = y;
        this.type = "point";
    }

    Point.prototype = {
        clone: function () {
            return new Point(this.x, this.y);
        },
        add: function (p) {
            return this.clone()._add(p);
        },

        sub: function (p) {
            return this.clone()._sub(p);
        },

        multByPoint: function (p) {
            return this.clone()._multByPoint(p);
        },
        /**
         * 
         * @param {Point} p  - 
         * @returns {Point}  - 
         */
        divByPoint: function (p) {
            return this.clone()._divByPoint(p);
        },

        mult: function (k) {
            return this.clone()._mult(k);
        },

        div: function (k) {
            return this.clone()._div(k);
        },

        rotate: function (a) {
            return this.clone()._rotate(a);
        },

        rotateAround: function (a, p) {
            return this.clone()._rotateAround(a, p);
        },
        
        matMult: function (m) {
            return this.clone()._matMult(m);
        },

        unit: function () {
            return this.clone()._unit();
        },

        perp: function () {
            return this.clone()._perp();
        },

        round: function () {
            return this.clone()._round();
        },

        mag: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },

        equals: function (other) {
            return this.x === other.x &&
                this.y === other.y;
        },

        dist: function (p) {
            return Math.sqrt(this.distSqr(p));
        },

        distSqr: function (p) {
            var dx = p.x - this.x,
                dy = p.y - this.y;
            return dx * dx + dy * dy;
        },

        angle: function () {
            return Math.atan2(this.y, this.x);
        },

        angleTo: function (b) {
            return Math.atan2(this.y - b.y, this.x - b.x);
        },

        angleWith: function (b) {
            return this.angleWithSep(b.x, b.y);
        },

        angleWithSep: function (x, y) {
            return Math.atan2(
                this.x * y - this.y * x,
                this.x * x + this.y * y);
        },
        
        _matMult: function (m) {
            var x = m[0] * this.x + m[1] * this.y,
                y = m[2] * this.x + m[3] * this.y;
            this.x = x;
            this.y = y;
            return this;
        },
        _add: function (p) {
            this.x += p.x;
            this.y += p.y;
            return this;
        },
        _sub: function (p) {
            this.x -= p.x;
            this.y -= p.y;
            return this;
        },

        _mult: function (k) {
            this.x *= k;
            this.y *= k;
            return this;
        },
        _div: function (k) {
            this.x /= k;
            this.y /= k;
            return this;
        },

        _multByPoint: function (p) {
            this.x *= p.x;
            this.y *= p.y;
            return this;
        },

        _divByPoint: function (p) {
            this.x /= p.x;
            this.y /= p.y;
            return this;
        },
        _unit: function () {
            this._div(this.mag());
            return this;
        },

        _perp: function () {
            var y = this.y;
            this.y = this.x;
            this.x = -y;
            return this;
        },

        _rotate: function (angle) {
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x = cos * this.x - sin * this.y,
                y = sin * this.x + cos * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _rotateAround: function (angle, p) {
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
                y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
            this.x = x;
            this.y = y;
            return this;
        },

        _round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        }
    };

    Point.convert = function (a) {
        if (a instanceof Point) {
            return a;
        }
        if (Array.isArray(a)) {
            return new Point(a[0], a[1]);
        }
        return a;
    };

    return Point;
});
},
'com/huayun/webgis/data/queryIntersectsEx':function(){
define(["exports"], function(exports) {

    /**
     * 
     * @param ring 
     * @param p 
     */
    function polygonContainsPointex(ring, p) {
        var c = false, points;
        var type = Array.isArray(ring) ? ring[0].type : ring.type;
        if(type === "point"){
            points = Array.isArray(ring) ? ring[0] : ring;
        }else {
            points = Array.isArray(ring) ? ring[0].path[0] : ring.path[0];
            for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
                var p1 = points[i];
                var p2 = points[j];
                p.y = Array.isArray(p) ? p[1] : p.y;
                p.x = Array.isArray(p) ? p[0] : p.x;
                if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                    c = !c;
                }
            }
        }
        return c;
    }
    
    function pointToPointsDis (p1, p2, radius) {
        var pArr, pPoi;
        Array.isArray(p1) ? pArr = p1 : pPoi = p1;
        Array.isArray(p2) ? pArr = p2 : pPoi = p2;
        if(!(Array.isArray(p1) || Array.isArray(p2))) {
            pointToArrDis(p1, p2, radius);
        }
        if(distSqr(pPoi,pArr[0]) < radius*radius){
            return true;
        }else {
            return false;
        }
    }

    function pointToArrDis (p1, p2, radius) {
        if(Array.isArray(p1) || Array.isArray(p2)) {
            pointToPointsDis(p1, p2, radius);
        }
        if (disSqr(p1,p2) < radius * radius) {
            return true;
        } else {
            return false;
        }
    }
    /**
     * 
     * @param a0  1
     * @param a1  1
     * @param b0  2
     * @param b1  2
     */
    function lineSegmentIntersectsLineSegmentex(a0, a1, b0, b1) {
        return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) &&
            isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
    }

    /**
     * 
     * @param lineA  1
     * @param lineB  2
     */
    function lineIntersectsLineex(lineA, lineB) {
        if (lineA.length === 0 || lineB.length === 0) {
            return false;
        }
        for (var i = 0; i < lineA.length - 1; i++) {
            var a0 = lineA[i];
            var a1 = lineA[i + 1];
            for (var j = 0; j < lineB.length - 1; j++) {
                var b0 = lineB[j];
                var b1 = lineB[j + 1];
                if (lineSegmentIntersectsLineSegmentex(a0, a1, b0, b1)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 
     * @param p  
     * @param v  
     * @param w  
     */
    function distToSegmentSquaredex(p, v, w) {
        var l2 = (v[0] - w[0]) * (v[0] - w[0]) + (v[1] - w[1]) * (v[1] - w[1]);
        if (l2 === 0) {
            return disSqr(p, v);
        }
        var t = ((p.x - v[0]) * (w[0] - v[0]) + (p.y - v[1]) * (w[1] - v[1])) / l2;
        if (t < 0) {
            return disSqr(p, v);
        }
        if (t > 1) {
            return disSqr(p, w);
        }
        return disSqr(p, mult(w, v, t));
    }
    /**
     * ()
     * @param p1 
     * @param p2 
     */
    function disSqr(p1,p2) {
        var dx = p1.x - p2[0],
            dy = p1.y - p2[1];
        return dx * dx + dy * dy;
    }
    /**
     * ()
     * @param p1 
     * @param p2 
     */
    function distSqr(p1,p2) {
        var dx = p1.x - p2.x,
            dy = p1.y - p2.y;
        return dx * dx + dy * dy;
    }
    /**
     * 
     * @param a  
     * @param b  
     * @param c  
     */
    function isCounterClockwise(a, b, c) {
        return (c[1] - a[1]) * (b[0] - a[0]) > (b[1] - a[1]) * (c[0] - a[0]);
    }
    /**
     * 
     * @param w  
     * @param v  
     * @param t  
     */
    function mult(w, v, t) {
        var m = [];
        m[0] = (w[0] - v[0]) * t + v[0];
        m[1] = (w[1] - v[1]) * t + v[1];
        return m;
    }

    /**
     * 
     * @param p  
     * @param line    
     * @param radius   
     */
    function pointIntersectsBufferedLineex(p, line, radius) {
        var radiusSquared = radius * radius;
        if (line.length === 1) {
            return distSqr(line[0],p) < radiusSquared;
        }
        for (var i = 1; i < line.length; i++) {
            var v = line[i - 1], w = line[i];
            if (distToSegmentSquaredex(p, v, w) < radiusSquared) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param polygon  
     * @param point    
     * @param radius   
     */
    function polygonIntersectsBufferedPointex(polygon, point, radius) {
        if(pointToPointsDis(polygon,point,radius)) {return true; };
        if (polygonContainsPointex(polygon, point)) { return true; };
        if (pointIntersectsBufferedLineex(point, polygon, radius)) { return true; };
        return false;
    }

    /**
     * 
     * @param lineA  1
     * @param lineB  2
     * @param radius  
     */
    function lineIntersectsBufferedLineex(lineA, lineB, radius) {
        if (lineA.length > 1) {
            if (lineIntersectsLineex(lineA, lineB)) {
                return true;
            }
            for (var j = 0; j < lineB.length; j++) {
                if (pointIntersectsBufferedLineex(lineB[j], lineA, radius)) {
                    return true;
                }
            }
        }
        for (var k = 0; k < lineA.length; k++) {
            if (pointIntersectsBufferedLineex(lineA[k], lineB, radius)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param rings  
     * @param p    
     */
    function multiPolygonContainsPointex(rings, p) {
        var c = false,
            ring, p1, p2;
        for (var k = 0; k < rings.length; k++) {
            ring = rings[k];
            for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
                p1 = ring[i];
                p2 = ring[j];
                if (((p1[1] > p.y) !== (p2[1] > p.y)) && (p.x < (p2[0] - p1[0]) * (p.y - p1[1]) / (p2[1] - p1[1]) + p1[0])) {
                    c = !c;
                }
            }
        }
        return c;
    }

    function polygonIntersectsMultiPointex(polygon, multiPoints, symbol, resolution, radius) {
        var points = multiPoints.points;
        var inPoint = polygon[0];
        for(var i = 0; i < points.length; i++) {
            var pointItem = points[i];
            if(pointToArrDis(inPoint, pointItem, radius)) {return true};
            if(polygonContainsPointex(inPoint, pointItem, radius)) {return true};
        }   
        return false;
    }

    /**
     * 
     * @param queryGeometry   
     * @param geometry  
     * @param symbol    
     * @param resolution   
     * @param radius    
     * @param viewpoint   
     */
    function polygonIntersectsPointex(queryGeometry, geometry, symbol, resolution, radius, viewpoint) {
        var transformedPolygon = queryGeometry;
        var transformedPoint = geometry;
        var transformedSize = radius * resolution;
        if(polygonIntersectsBufferedPointex(transformedPolygon, transformedPoint, transformedSize)) { return true; }
    }

    /**
     * 
     * @param polygon    
     * @param multiLine   
     * @param symbol       
     * @param resolution    
     */
    function polygonIntersectsBufferedMultiLineex(polygon, multiLine, symbol, resolution) {
        multiLine = multiLine.paths;
        var radius = symbol.width * resolution / 2;
        for (var i = 0; i < multiLine.length; i++) {
            var line = multiLine[i];

            for (var k = 0; k < line.length; k++) {
                if (polygonContainsPointex(polygon, line[k])) {
                    return true;
                }
            }

            if (lineIntersectsBufferedLineex(polygon, line, radius)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param polygon    
     * @param multiPolygon   
     */
    function polygonIntersectsMultiPolygonex(polygon, multiPolygon) {
        multiPolygon = multiPolygon.rings;
        if (polygon.length === 1) {
            return multiPolygonContainsPointex(multiPolygon, polygon[0]);
        }
        for (var m = 0; m < multiPolygon.length; m++) {
            var ring = multiPolygon[m];
            for (var n = 0; n < ring.length; n++) {
                if (polygonContainsPointex(polygon, ring[n])) {
                    return true;
                }
            }
        }
        for (var i = 0; i < polygon.length; i++) {
            if (multiPolygonContainsPointex(multiPolygon, polygon[i])) {
                return true;
            }
        }
        for (var k = 0; k < multiPolygon.length; k++) {
            if (lineIntersectsLineex(polygon, multiPolygon[k])) {
                return true;
            }
        }
        return false;
    }

   
    exports.lineex = polygonIntersectsBufferedMultiLineex;
    exports.polygonex = polygonIntersectsMultiPolygonex;
    exports.pointex = polygonIntersectsPointex;
    exports.multipointex = polygonIntersectsMultiPointex;
})
},
'com/huayun/webgis/core/base':function(){
define([
    "custom/crypto-js.min"
], function (CryptoJS) {
    if (!dojoConfig) return;
    var app = dojoConfig.app;
    if (!app) return;
    var accessKey = dojoConfig.app.accessKey,
        secretKey = dojoConfig.app.secretKey;
    if (!accessKey || !secretKey) return;

    const key = CryptoJS.enc.Utf8.parse("123456yrxo@kc6x3");
    function addZero(num) {
        return num < 10 ? "0" + num : num;
    }
    const date = new Date();
    const timeStamp = date.getFullYear() + addZero(date.getMonth() + 1) + addZero(date.getDate());
    function checkAccessKey(accessKey, secretKey) {
        let strs = CryptoJS.enc.Utf8.parse(`${accessKey}+${secretKey}+${timeStamp}`);
        let accessKeyStr = CryptoJS.AES.encrypt(strs, key, {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
        });
        return accessKeyStr.toString();
    }
    dojoConfig.token = checkAccessKey(accessKey, secretKey);
});
},
'com/huayun/webgis/layers/TileLayer':function(){
/**
 * 
 * @see com.huayun.webgis.layers.TileLayer
 */
define([
    "./Layer",
    "../geometry/Extent",
    "../views/3d/layers/TileLayerView3D",
    "../geometry/Point",
    "./support/TileSourceCache",
    "./support/LOD",
    "./support/TileInfo",
    "../facade/TileFacade"
], function (Layer, Extent, TileLayerView3D, Point, TileSourceCache, LOD, TileInfo, TileFacade) {
    // 
    var reg = /(\/tile\/.+)/;
    // token
    // var tokenReg = /access_token=([\d+|\w+]-?)+/;

    /**
     * 
     * @constructor
     * @alias com.huayun.webgis..layers.TileLayer
     * @extends {layer}
     * @param {Object} params 
     * @param {string}  params.id  id
     * @param {String} params.url 
     * @property {string}  type  
     * @property {string}  id  id
     * @property {string}  url 
     * @example
     * var layer = new TileLayer({
     *  id: "tile",
     *  visible: true,
     *  url: "xxx"
     * });
     */
    var TileLayer = function (params) {
        Layer.call(this, params);
        this.id = params.id || "tileLayer";
        this.type = "Tile";
        this.name = params.name || "";
        this.url = params.url;
        this.visible = params.visible === undefined ? true : params.visible;
        this.selectEnabled = false;
        this.loaded = false;
        this.tileInfo = null;
        this.layerView = null;
        this.sourceCache = null;
        this.maxLevel = params.maxLevel;
    };
    if (Layer) TileLayer.__proto__ = Layer;
    TileLayer.prototype = Object.create(Layer && Layer.prototype);
    TileLayer.prototype.constructor = TileLayer;

    /**
     * LayerView
     * @private
     * @param view
     * @param option
     * @return {exports}
     */
    TileLayer.prototype.createLayerView = function (view, option) {
        var layerView = new TileLayerView3D({
            width: view.width,
            height: view.height,
            opacity: this.opacity,
            visible: this.visible,
            view: view,
            id: this.id,
            layer: this
        });
        this._load(view);
        this.layerView = layerView;
        layerView.transform = view.viewpoint;
        return layerView;
    };

    /**
     * TileInfo
     * @ignore
     * @param view
     * @private
     */
    TileLayer.prototype._load = function (view) {
        var serverUrl = this.url.replace(reg, "");
        var index = this.url.indexOf("?");
        if (index > -1) { // 
            var args = this.url.substring(index);
            serverUrl = serverUrl + args + "&f=json";
        } else { // 
            serverUrl = serverUrl + "?f=json";
        }
        var self = this;
        TileFacade.getTileInfoData(serverUrl, function (err, resp) {
            if (err) {
                TileFacade.getTileInfoData(require.toUrl("com/huayun/webgis/layers/support/tileInfoData2385.json"), function (e, response) {
                    if (e) throw new Error(e.message);
                    self._resolve(view, response);
                });
            } else {
                self._resolve(view, resp);
            }

        });
    };

    TileLayer.prototype._resolve = function (view, resp) {
        var tileInfo = resp.tileInfo;
        var theOrigin = tileInfo.origin;
        theOrigin = new Point(theOrigin.x, theOrigin.y);
        var lodList = [];
        resp.lods.forEach(function (item) {
            lodList.push(new LOD({
                level: item.level,
                scale: item.scale,
                resolution: item.resolution
            }));
        });
        // this.maxLevel = lodList[];
        var extent = resp.fullExtent;
        var fullExtent = new Extent(Number(extent.xmin), Number(extent.ymin), Number(extent.xmax), Number(extent.ymax));
        this.tileInfo = new TileInfo({
            lods: lodList,
            origin: theOrigin,
            size: tileInfo.cols,
            fullExtent: fullExtent
        });
        var options = {
            tileSize: this.tileInfo.size,
            type: "raster",
            minzoom: this.tileInfo.lods[0].level,
            maxzoom: this.tileInfo.lods[lodList.length - 1].level
        };
        this.sourceCache = new TileSourceCache(this.id, options, view.width, view.height, this.url, this);
        view.setTileInfo(this.tileInfo);
    }


    TileLayer.prototype.refresh = function () {
        this.layerView.view.threeRender();
    };

    TileLayer.prototype.setVisible = function (visible) {
        this.visible = visible;
        this.layerView.setVisible(visible);
    };

    TileLayer.prototype.setUrl = function (url) {
        this.url = url;
        this.sourceCache.updateTileUrl(url);
        var ids = this.sourceCache.getIds();
        var sourceCache = this.sourceCache;
        sourceCache.clearOtherLevel(this.layerView.view.viewpoint.level);
        for (var i = 0, list = ids; i < list.length; i += 1) {
            var tileID = list[i];
            sourceCache._reAddTile(tileID);
        }
    };

    return TileLayer;
});
},
'com/huayun/webgis/layers/support/SourceFeatureState':function(){
define([
    "../../utils/utils"
], function (utils) {
    var SourceFeatureState = function SourceFeatureState() {
        this.state = {};
        this.stateChanges = {};
        this.deletedStates = {};
    };

    SourceFeatureState.prototype.updateState = function updateState(sourceLayer, featureIds, newState) {
        for (var i = 0; i < featureIds.length; i++) {
            var featureId = featureIds[i];
            var feature = String(featureId);
            this.stateChanges[sourceLayer] = this.stateChanges[sourceLayer] || {};
            this.stateChanges[sourceLayer][feature] = this.stateChanges[sourceLayer][feature] || {};
            utils.extend(this.stateChanges[sourceLayer][feature], newState);

            if (this.deletedStates[sourceLayer] === null) {
                this.deletedStates[sourceLayer] = {};
                for (var ft in this.state[sourceLayer]) {
                    if (ft !== feature) {
                        this.deletedStates[sourceLayer][ft] = null;
                    }
                }
            } else {
                var featureDeletionQueued = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] === null;
                if (featureDeletionQueued) {
                    this.deletedStates[sourceLayer][feature] = {};
                    for (var prop in this.state[sourceLayer][feature]) {
                        if (!newState[prop]) {
                            this.deletedStates[sourceLayer][feature][prop] = null;
                        }
                    }
                } else {
                    for (var key in newState) {
                        var deletionInQueue = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] && this.deletedStates[sourceLayer][feature][key] === null;
                        if (deletionInQueue) {
                            delete this.deletedStates[sourceLayer][feature][key];
                        }
                    }
                }
            }
        }
    };

    SourceFeatureState.prototype.removeFeatureState = function removeFeatureState(sourceLayer, featureId, key) {
        var sourceLayerDeleted = this.deletedStates[sourceLayer] === null;
        if (sourceLayerDeleted) {
            return;
        }

        var feature = String(featureId);

        this.deletedStates[sourceLayer] = this.deletedStates[sourceLayer] || {};

        if (key && featureId !== undefined && featureId >= 0) {
            if (this.deletedStates[sourceLayer][feature] !== null) {
                this.deletedStates[sourceLayer][feature] = this.deletedStates[sourceLayer][feature] || {};
                this.deletedStates[sourceLayer][feature][key] = null;
            }
        } else if (featureId !== undefined && featureId >= 0) {
            var updateInQueue = this.stateChanges[sourceLayer] && this.stateChanges[sourceLayer][feature];
            if (updateInQueue) {
                this.deletedStates[sourceLayer][feature] = {};
                for (key in this.stateChanges[sourceLayer][feature]) {
                    this.deletedStates[sourceLayer][feature][key] = null;
                }

            } else {
                this.deletedStates[sourceLayer][feature] = null;
            }
        } else {
            this.deletedStates[sourceLayer] = null;
        }

    };

    SourceFeatureState.prototype.getState = function getState(sourceLayer, featureId) {
        var feature = String(featureId);
        var base = this.state[sourceLayer] || {};
        var changes = this.stateChanges[sourceLayer] || {};

        var reconciledState = utils.extend({}, base[feature], changes[feature]);

        //return empty object if the whole source layer is awaiting deletion
        if (this.deletedStates[sourceLayer] === null) {
            return {};
        } else if (this.deletedStates[sourceLayer]) {
            var featureDeletions = this.deletedStates[sourceLayer][featureId];
            if (featureDeletions === null) {
                return {};
            }
            for (var prop in featureDeletions) {
                delete reconciledState[prop];
            }
        }
        return reconciledState;
    };

    SourceFeatureState.prototype.initializeTileState = function initializeTileState(tile, painter) {
        tile.setFeatureState(this.state, painter);
    };

    SourceFeatureState.prototype.coalesceChanges = function coalesceChanges(tiles, painter) {
        //track changes with full state objects, but only for features that got modified
        var featuresChanged = {};

        for (var sourceLayer in this.stateChanges) {
            this.state[sourceLayer] = this.state[sourceLayer] || {};
            var layerStates = {};
            for (var feature in this.stateChanges[sourceLayer]) {
                if (!this.state[sourceLayer][feature]) {
                    this.state[sourceLayer][feature] = {};
                }
                utils.extend(this.state[sourceLayer][feature], this.stateChanges[sourceLayer][feature]);
                layerStates[feature] = this.state[sourceLayer][feature];
            }
            featuresChanged[sourceLayer] = layerStates;
        }

        for (var sourceLayer$1 in this.deletedStates) {
            this.state[sourceLayer$1] = this.state[sourceLayer$1] || {};
            var layerStates$1 = {};

            if (this.deletedStates[sourceLayer$1] === null) {
                for (var ft in this.state[sourceLayer$1]) {
                    layerStates$1[ft] = {};
                    this.state[sourceLayer$1][ft] = {};
                }
            } else {
                for (var feature$1 in this.deletedStates[sourceLayer$1]) {
                    var deleteWholeFeatureState = this.deletedStates[sourceLayer$1][feature$1] === null;
                    if (deleteWholeFeatureState) {
                        this.state[sourceLayer$1][feature$1] = {};
                    } else {
                        for (var i = 0, list = Object.keys(this.deletedStates[sourceLayer$1][feature$1]); i < list.length; i += 1) {
                            var key = list[i];

                            delete this.state[sourceLayer$1][feature$1][key];
                        }
                    }
                    layerStates$1[feature$1] = this.state[sourceLayer$1][feature$1];
                }
            }

            featuresChanged[sourceLayer$1] = featuresChanged[sourceLayer$1] || {};
            utils.extend(featuresChanged[sourceLayer$1], layerStates$1);
        }

        this.stateChanges = {};
        this.deletedStates = {};

        if (Object.keys(featuresChanged).length === 0) {
            return;
        }

        for (var id in tiles) {
            var tile = tiles[id];
            tile.setFeatureState(featuresChanged, painter);
        }
    };

    return SourceFeatureState;
});
},
'com/huayun/webgis/gl/members':function(){
define([
    "exports",
    "../utils/Constant",
    "../utils/utils"
], function (exports, Constant, utils) {
    function createLayout(members, alignment) {
        if (alignment === void 0) alignment = 1;
        var offset = 0;
        var maxSize = 0;
        var layoutMembers = members.map(function (member) {
            var typeSize = Constant.viewTypes[member.type].BYTES_PER_ELEMENT;
            var memberOffset = offset = utils.align(offset, Math.max(alignment, typeSize));
            var components = member.components || 1;
            maxSize = Math.max(maxSize, typeSize);
            offset += typeSize * components;
            return {
                name: member.name,
                type: member.type,
                components: components,
                offset: memberOffset
            };
        });
        var size = utils.align(offset, Math.max(maxSize, alignment));
        return {
            members: layoutMembers,
            size: size,
            alignment: alignment
        };
    }

    var layout$2 = createLayout([
        {name: 'a_pos', components: 2, type: 'Int16'}
    ], 4);

    var lineLayoutAttributes = createLayout([
        {name: 'a_pos_normal', components: 2, type: 'Int16'},
        {name: 'a_data', components: 4, type: 'Uint8'}
    ], 4);

    var layout$3 = createLayout([
        {name: 'a_pos', components: 2, type: 'Int16'},
        {name: 'a_normal_ed', components: 4, type: 'Int16'}], 4);

    var layout$1 = createLayout([
        {name: 'a_pos', components: 2, type: 'Int16'}
    ], 4);

    var layout$4 = createLayout([
        {name: 'a_pos', components: 3, type: 'Int16'}
    ]);

    exports.members = layout$1.members;
    exports.members$1 = layout$2.members;
    exports.members$2 = layout$3.members;
    exports.members$3 = lineLayoutAttributes.members;
    exports.members$4 = layout$4.members;

    exports.symbolLayoutAttributes = createLayout([
        {name: 'a_pos_offset', components: 4, type: 'Int16'},
        {name: 'a_data', components: 4, type: 'Uint16'}
    ]);

    exports.dynamicLayoutAttributes = createLayout([
        {name: 'a_projected_pos', components: 3, type: 'Float32'}
    ], 4);

    exports.posAttributes = createLayout([
        {name: 'a_pos', type: 'Int16', components: 2}
    ]);

    exports.shaderOpacityAttributes = [
        {name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0}
    ];

    exports.rasterBoundsAttributes = createLayout([
        {name: 'a_pos', type: 'Int16', components: 2},
        {name: 'a_texture_pos', type: 'Int16', components: 2}
    ]);

    exports.imageBoundsAttributes = createLayout([
        {name: 'a_pos', type: 'Int16', components: 2},
        {name: 'a_texture_pos', type: 'Int16', components: 2}
    ]);
});
},
'com/huayun/webgis/gl/draw/drawRaster':function(){
define([
    "exports",
    "../mode",
    "../../geometry/Point",
    "../Texture",
    "../../utils/utils",
    "custom/gl-matrix-min"
], function (exports, mode, Point, Texture, utils, glMatrix) {

    var rasterUniformValues = function (matrix, parentTL, parentScaleBy, fade, layer) {
        return ({
            'u_matrix': matrix,
            'u_tl_parent': parentTL,
            'u_scale_parent': parentScaleBy,
            'u_buffer_scale': 1,
            'u_fade_t': fade.mix,
            'u_opacity': fade.opacity,
            'u_image0': 0,
            'u_image1': 1,
            'u_brightness_low': 0,
            'u_brightness_high': 1,
            'u_saturation_factor': -0,
            'u_contrast_factor': 1,
            'u_spin_weights': [1, 0, 0]
        });
    };

    /**
     * 
     * @param tile
     * @param parentTile
     * @param sourceCache
     * @param transform
     */
    function getFadeValues(tile, parentTile, sourceCache, transform) {
        var fadeDuration = 300;
        if (fadeDuration > 0) {
            var now = utils.now();
            var sinceTile = (now - tile.timeAdded) / fadeDuration;
            var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

            var source = sourceCache.getSource();
            var idealZ = transform.coveringZoomLevel({
                tileSize: source.tileSize,
                roundZoom: source.roundZoom
            });
            var fadeIn = !parentTile || Math.abs(parentTile.tileID.overscaledZ - idealZ) > Math.abs(tile.tileID.overscaledZ - idealZ);
            var childOpacity = (fadeIn && tile.refreshedUponExpiration) ? 1 : utils.clamp(fadeIn ? sinceTile : 1 - sinceParent, 0, 1);
            /*if (tile.refreshedUponExpiration && sinceTile >= 1) {
                tile.refreshedUponExpiration = false;
            }*/

            if (parentTile) {
                return {
                    opacity: 1,
                    mix: 1 - childOpacity
                };
            } else {
                return {
                    opacity: childOpacity,
                    mix: 0
                };
            }
        } else {
            return {
                opacity: 1,
                mix: 0
            };
        }
    }

    return function (painter, sourceCache, layer, coords) {
        var context = painter.view.context;
        var gl = context.gl;
        var source = sourceCache.getSource();
        var program = painter.view.useProgram('raster');

        var stencilMode = mode.StencilMode.disabled;
        var colorMode = mode.ColorMode.alphaBlended;
        var minTileZ = coords.length && coords[0].overscaledZ;
        var align = true;//!painter.options.moving;
        for (var i = 0, list = coords; i < list.length; i += 1) {
            var coord = list[i];
            var depthMode = painter.depthModeForSublayer(coord.overscaledZ - minTileZ, mode.DepthMode.ReadWrite, gl.LESS);
            var tile = sourceCache.getTile(coord);
            var posMatrix = coord.posMatrix;
            tile.registerFadeDuration(300);

            var parentTile = sourceCache.findLoadedParent(coord, 0),
                fade = getFadeValues(tile, parentTile, sourceCache, painter.transform);
            if (fade.opacity < 1) {
                painter._fadeDirty = true;
            }
            var parentScaleBy = (void 0), parentTL = (void 0);

            var textureFilter = gl.LINEAR;

            context.activeTexture.set(gl.TEXTURE0);
            tile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);

            context.activeTexture.set(gl.TEXTURE1);

            if (parentTile) {
                parentTile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
                parentScaleBy = Math.pow(2, parentTile.tileID.overscaledZ - tile.tileID.overscaledZ);
                parentTL = [tile.tileID.canonical.x * parentScaleBy % 1, tile.tileID.canonical.y * parentScaleBy % 1];

            } else {
                tile.texture.bind(textureFilter, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);
            }

            var uniformValues = rasterUniformValues(posMatrix, parentTL || [0, 0], parentScaleBy || 1, fade, layer);
            program.draw2(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, mode.CullFaceMode.disabled,
                uniformValues, "tile", painter.rasterBoundsBuffer,
                painter.quadTriangleIndexBuffer, painter.rasterBoundsSegments);
        }
    };
});
},
'com/huayun/webgis/utils/Resource':function(){
define(["exports", "dojo/Deferred"], function (exports, Deferred) {
    var fetch = self ? self.fetch : window.fetch;
    var Request = self ? self.Request : window.Request;
    var AbortController = self ? self.AbortController : window.AbortController;

    function loadImg(url, callback) {
        var img = new Image();
        img.setAttribute("crossorigin", 'anonymous');
        img.onload = function () {
            callback(null, img);
        };
        img.onerror = function () {
            return callback(new Error(", : " + url));
        };
        img.src = url;
    }

    function getBlob(requestParameters, callback) {
        requestParameters.type = "blob";
        return makeRequest(requestParameters, callback);
    }

    function makeRequest(requestParameters, callback) {
        if (!/^file:/.test(requestParameters.url)) {
            if (fetch && Request && AbortController && Request.prototype.hasOwnProperty('signal')) {
                return makeFetchRequest(requestParameters, callback);
            }
        }
        return makeXMLHttpRequest(requestParameters, callback);
    }

    function makeFetchRequest(requestParameters, callback) {
        var controller = new AbortController();
        var request = new Request(requestParameters.url, {
            method: requestParameters.method || 'GET',
            body: requestParameters.body,
            credentials: requestParameters.credentials,
            headers: requestParameters.headers,
            signal: controller.signal
        });
        var complete = false;
        if (requestParameters.type === 'json') {
            request.headers.set('Accept', 'application/json');
        }

        fetch(request).then(function (response) {
            if (response.ok) {
                return (requestParameters.type === 'blob' ? response.blob() :
                        requestParameters.type === 'arrayBuffer' ? response.arrayBuffer() :
                            requestParameters.type === 'json' ? response.json() : response.text()
                ).then(function (result) {
                    complete = true;
                    callback(null, result);
                }).catch(function (err) {
                    return callback(new Error(err.message));
                })
            } else {
                return callback(new Error(response.statusText + response.status + requestParameters.url));
            }
        }).catch(function (error) {
            callback(new Error(error.message));
        });
        return {
            cancel: function () {
                if (!complete) {
                    controller.abort();
                }
            }
        };
    }

    function makeXMLHttpRequest(requestParameters, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open(requestParameters.method || 'GET', requestParameters.url, true);
        if (requestParameters.type === 'arrayBuffer') {
            xhr.responseType = 'arraybuffer';
        }
        if (requestParameters.type === 'blob') {
            xhr.responseType = 'blob';
        }

        for (var k in requestParameters.headers) {
            xhr.setRequestHeader(k, requestParameters.headers[k]);
        }
        if (requestParameters.type === 'json') {
            xhr.setRequestHeader('Accept', 'application/json');
        }
        xhr.withCredentials = requestParameters.credentials === 'include';
        xhr.onerror = function () {
            callback(new Error(xhr.statusText));
        };
        xhr.onload = function () {
            if (((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) && xhr.response !== null) {
                var data = xhr.response;
                if (requestParameters.type === 'json') {
                    try {
                        data = JSON.parse(xhr.response);
                    } catch (err) {
                        return callback(err);
                    }
                }
                callback(null, data);
            } else {
                callback(new Error(xhr.statusText + xhr.status + requestParameters.url));
            }
        };
        xhr.send(requestParameters.body);
        return {
            cancel: function () {
                return xhr.abort();
            }
        };
    }

    exports.loadImage = function (url, options, callback) {
        if (typeof options === "function") {
            return loadImg(url, options);
        }
        if (options && (options.headers || options.method === "POST")) {
            options.url = url;
            return getBlob(options, function (err, data) {
                if (err) {
                    callback(err);
                } else if (data) {
                    var img = new Image();
                    var URL = URL || webkitURL;
                    img.onload = function () {
                        callback(null, img);
                        URL.revokeObjectURL(img.src);
                    };
                    img.onerror = function () {
                        return callback(new Error(", : " + url));
                    };
                    img.src = URL.createObjectURL(data);
                }
            })
        }
        return loadImg(url, callback);
    }

    exports.loadImagePromise = function (url, options) {
        var deferred = new Deferred();
        if (options && (options.headers || options.method === "POST")) {
            options.url = url;
            getBlob(options, function (err, data) {
                if (err) {
                    deferred.reject(err);
                } else if (data) {
                    var img = new Image();
                    var URL = URL || webkitURL;
                    img.onload = function () {
                        deferred.resolve(img);
                        URL.revokeObjectURL(img.src);
                    };
                    img.onerror = function () {
                        return deferred.reject(new Error(", : " + url));
                    };
                    img.src = URL.createObjectURL(data);
                }
            });
            return deferred;
        }
        loadImg(url, function (err, data) {
            if (err) {
                deferred.reject(err);
            } else if (data) {
                deferred.resolve(data);
            }
        });
        return deferred;
    }

    exports.loadJson = function (url, options, callback) {
        if (typeof options === "function") {
            return makeRequest({
                url: url,
                type: 'json'
            }, options);
        }
        if (!options) {
            options = {};
        }
        options.url = url;
        options.type = 'json';
        return makeRequest(options, callback);
    }

    exports.loadArrayBuffer = function (url, options, callback) {
        if (typeof options === "function") {
            return makeRequest({
                url: url,
                type: 'arrayBuffer'
            }, options);
        }
        if (!options) {
            options = {};
        }
        options.url = url;
        options.type = 'arrayBuffer';
        return makeRequest(options, callback);
    }
});
},
'com/huayun/webgis/symbols/ImageSymbol':function(){
define([
  "dojo/topic",
  "custom/gl-matrix-min",
  "./BaseSymbol"
], function (topic, glMatrix, BaseSymbol) {
  var ImageSymbol = function (params) {
    BaseSymbol.call(this, params);
    this.type = "image";
    var opacity = params.opacity || 1;
    var size = params.size || 1;
    var isRotate = params.isRotate === undefined?false:params.isRotate;
    var rotateRadian = params.rotateRadian === undefined?0:params.rotateRadian;
    this.loaded = false;
    this.used = false;
    this.width = params.width;
    this.height = params.height;
    this.angle = params.angle || 0;
    this.dx = params.dx || 0;
    this.dy = params.dy || 0;

    this.offset = params.offset === undefined ? [0, 0] : params.offset;

    var matrix = glMatrix.mat4.create();
    // glMatrix.mat4.rotateX(matrix, matrix, 45/180*Math.PI);

    this.uniforms = {
      "u_size": size,
      "u_pitch_with_map": 0,
      "u_opacity": opacity,
      "u_texture": 0,
      "u_rotate_symbol": isRotate,
      "u_radian": rotateRadian,
      "u_modelMatrix": matrix
    };

    var image = new Image();
    image.setAttribute("crossorigin", 'anonymous');
    image.onload = function (e) {
      this.loaded = true;
      this.image = image;
      this.uniforms.u_texsize = [this.width, this.height];
      if (this.used) {
        topic.publish("threeRender");
      }
    }.bind(this);
    image.src = params.url;
  };
  if (BaseSymbol) ImageSymbol.__proto__ = BaseSymbol;
  ImageSymbol.prototype = Object.create(BaseSymbol && BaseSymbol.prototype);
  ImageSymbol.prototype.constructor = ImageSymbol;

  return ImageSymbol;
});

},
'com/huayun/webgis/geometry/MapPoint':function(){
define(["dojo/_base/declare","./Geometry"],function (declare,Geometry) {
  return declare("com.huayun.webgis.geometry.MapPoint",[Geometry],{

    constructor: function (x,y,z) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.type = "point";
    },

    toString: function () {
      return "x: "+this.x+" y: " + this.y + "z: "+this.z;
    }
  })
});
},
'com/huayun/webgis/geometry/Point':function(){
/**
 * 
 * @module com/huayun/webgis/geometry
 * @see com.huayun.webgis.geometry.Point
 */
define([
  "./Geometry",
  "./Extent"
], function (Geometry, Extent) {
  /**
   * 
   * @constructor
   * @alias com.huayun.webgis.geometry.Point
   * @extends {Geometry}
   * @property {string} type 
   * @property {number} x x
   * @property {number} y y
   * @property {number} z z
   * @param {number} x x
   * @param {number} y y
   * @param {number} z z
   */
  var Point = function (x, y, z, spatialReference) {
    Geometry.call(this);
    if (Array.isArray(x)) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2];
    } else {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    this.hasZ = this.z === undefined;
    this.type = "point";
    this.spatialReference = spatialReference;
  };

  if (Geometry) Point.__proto__ = Geometry;

  Point.prototype = Object.create(Geometry && Geometry.prototype);
  Point.prototype.constructor = Point;
  
  Point.prototype = {
    clone: function () {
      return new Point(this.x, this.y, this.z);
    },
    add: function (p) {
      return this.clone()._add(p);
    },
    sub: function (p) {
      return this.clone()._sub(p);
    },

    multByPoint: function (p) {
      return this.clone()._multByPoint(p);
    },

    divByPoint: function (p) {
      return this.clone()._divByPoint(p);
    },

    mult: function (k) {
      return this.clone()._mult(k);
    },

    div: function (k) {
      return this.clone()._div(k);
    },

    rotate: function (a) {
      return this.clone()._rotate(a);
    },

    radianJS: function(edgePoint) {
      let dx = edgePoint.x - this.x;
      let dy = -(edgePoint.y - this.y);
      return Math.atan2(dy, dx);
    },

    rotateAround: function (a, p) {
      return this.clone()._rotateAround(a, p);
    },

    matMult: function (m) {
      return this.clone()._matMult(m);
    },

    unit: function () {
      return this.clone()._unit();
    },

    perp: function () {
      return this.clone()._perp();
    },

    round: function () {
      return this.clone()._round();
    },

    mag: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function (other) {
      return this.x === other.x &&
        this.y === other.y;
    },

    dist: function (p) {
      return Math.sqrt(this.distSqr(p));
    },

    distSqr: function (p) {
      var dx = p.x - this.x,
        dy = p.y - this.y;
      return dx * dx + dy * dy;
    },

    angle: function () {
      return Math.atan2(this.y, this.x);
    },

    angleTo: function (b) {
      return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function (b) {
      return this.angleWithSep(b.x, b.y);
    },

    angleWithSep: function (x, y) {
      return Math.atan2(
        this.x * y - this.y * x,
        this.x * x + this.y * y);
    },

    _matMult: function (m) {
      var x = m[0] * this.x + m[1] * this.y,
        y = m[2] * this.x + m[3] * this.y;
      this.x = x;
      this.y = y;
      return this;
    },

    _add: function (p) {
      this.x += p.x;
      this.y += p.y;
      return this;
    },

    _sub: function (p) {
      this.x -= p.x;
      this.y -= p.y;
      return this;
    },

    _mult: function (k) {
      this.x *= k;
      this.y *= k;
      return this;
    },

    _div: function (k) {
      this.x /= k;
      this.y /= k;
      return this;
    },

    _multByPoint: function (p) {
      this.x *= p.x;
      this.y *= p.y;
      return this;
    },

    _divByPoint: function (p) {
      this.x /= p.x;
      this.y /= p.y;
      return this;
    },

    _unit: function () {
      this._div(this.mag());
      return this;
    },

    _perp: function () {
      var y = this.y;
      this.y = this.x;
      this.x = -y;
      return this;
    },

    _rotate: function (angle) {
      var cos = Math.cos(angle),
        sin = Math.sin(angle),
        x = cos * this.x - sin * this.y,
        y = sin * this.x + cos * this.y;
      this.x = x;
      this.y = y;
      return this;
    },

    _rotateAround: function (angle, p) {
      var cos = Math.cos(angle),
        sin = Math.sin(angle),
        x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
        y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
      this.x = x;
      this.y = y;
      return this;
    },

    _round: function () {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },

    radian: function (edgePoint) {
      let dx = edgePoint.x - this.x;
      let dy = edgePoint.y - this.y;
      return Math.atan2(dy, dx);
    },
    calculateOtherPoint: function (lineLength, radian) {
      let xValue = Math.cos(radian) * lineLength + this.x;
      let yValue = Math.sin(radian) * lineLength + this.y;
      return new Point(xValue, yValue);
    },
    interpolate: function(target, ratio) {
      let x = this.x * ratio + target.x * (1 - ratio);
      let y = this.y * ratio + target.y * (1 - ratio);
      return new Point(x, y);
    },
    calculateOtherPoint2: function(point2, lineLength) {
      let radian = Math.atan2(point2.y - this.y, point2.x - this.x);
      let xValue = this.x - lineLength * Math.sin(radian);
      let yValue = this.y + lineLength * Math.cos(radian);
      return new Point(xValue, yValue);
    },
    calculateOtherPoint3: function(point2, lineLength) {
      let radian = Math.atan2(point2.y - this.y, point2.x - this.x);
      let xValue = this.x + lineLength * Math.sin(radian);
      let yValue = this.y - lineLength * Math.cos(radian);
      return new Point(xValue, yValue);
    }
  };

  Point.prototype.update = function(dx, dy, dz) {
    this.x += dx;
    this.y += dy;
    if (dz) {
      this.z += dz;
    }
  };

  Point.convert = function (a) {
    if (a instanceof Point) {
      return a;
    }
    if (Array.isArray(a)) {
      return new Point(a[0], a[1]);
    }
    return a;
  };

  var prototypeAccessors = {
    extent: {configurable: false}
  };
  prototypeAccessors.extent.get = function () {
    if (!this._extent) {
      this._extent = new Extent(this.x, this.y, this.x, this.y);
    }
    return this._extent;
  };
  Object.defineProperties(Point.prototype, prototypeAccessors);
  return Point;
});

},
'com/huayun/webgis/Map':function(){
/**
 * 
 * @see com.huayun.webgis.Map
 */
define([
    "./core/base",
    "../core/EventEmitter",
    "./utils/extendClazz",
    "./layers/Layer"
], function (base, EventEmitter, extendClazz, Layer) {
    /**
     * , 
     * @constructor
     * @alias com.huayun.webgis.Map
     * @param {Object} props 
     * @param {String} props.id id
     * @property {String} id id
     * @property {Array} allLayers 
     * @example
     * var map = new Map({
     *     id: "map"
     * });
     */
    function Map(props) {
        this.id = props && props.id ? props.id : "map";
        this.allLayers = [];
    }

    extendClazz(Map, EventEmitter);

    /**
     * 
     * @param {Layer} layer 
     */
    Map.prototype.addLayer = function (layer) {
        if (!(layer instanceof Layer)) {
            throw new Error("");
        }
        for (var i = 0, ii = this.allLayers.length; i < ii; i++) {
            if (this.allLayers[i].id === layer.id) {
                throw new Error("id.");
            }
        }
        this.allLayers.push(layer);
        this.emit("addLayers", [layer]);
    };

    /**
     * 
     * @param {Array} layers 
     */
    Map.prototype.addLayers = function (layers) {
        for (var j = 0, jj = layers.length; j < jj; j++) {
            var layer = layers[j];
            if (!(layer instanceof Layer)) {
                throw new Error("");
            }
            for (var i = 0, ii = this.allLayers.length; i < ii; i++) {
                if (this.allLayers[i].id === layer.id) {
                    throw new Error("id.");
                }
            }
            this.allLayers.push(layer);
        }
        this.emit("addLayers", layers);
    };

    /**
     * , 
     * @param {Layer} layer 
     * @param {String} beforeLayerId id
     */
    Map.prototype.addLayerBefore = function (layer, beforeLayerId) {
        if (!(layer instanceof Layer)) {
            throw new Error("");
        }
        var targetIndex = -1;
        for (var i = this.allLayers.length - 1; i > -1; i--) {
            if (this.allLayers[i].id === layer.id) {
                throw new Error("id.");
            }
            if (this.allLayers[i].id === beforeLayerId) {
                targetIndex = i;
                break;
            }
        }
        if (targetIndex > -1) {
            this.allLayers.splice(targetIndex, 0, layer);
            this.emit("addLayers", [layer], beforeLayerId, targetIndex);
        } else {
            throw new Error("layer, !");
        }
    };

    /**
     * id
     * @param {String} layerId id
     * @returns {boolean} 
     */
    Map.prototype.removeLayerById = function (layerId) {
        for (var i = this.allLayers.length - 1; i > -1; i--) {
            if (this.allLayers[i].id === layerId) {
                this.allLayers.splice(i, 1);
                this.emit("removeLayers", [layerId]);
                return true;
            }
        }
        return false;
    };
    /**
     * 
     * @returns {Array} 
     */
    Map.prototype.findAllLayers = function () {
        return this.allLayers;
    };

    /**
     * id
     * @param {String} layerId id
     * @returns {null|Layer} 
     */
    Map.prototype.findLayerById = function (layerId) {
        for (var i = this.allLayers.length - 1; i > -1; i--) {
            if (this.allLayers[i].id === layerId) {
                return this.allLayers[i];
            }
        }
        return null;
    };

    Map.prototype.refresh = function () {
    };

    /**
     * 
     */
    Map.prototype.clear = function () {
        this.allLayers.forEach(function (item) {
            item.clear();
        })
        this.allLayers = [];
    }
    return Map;
});

},
'com/huayun/webgis/symbols/CircleSymbol':function(){
/**
 * 
 * @module com/huayun/webgis/symbols
 * @see com.huayun.webgis.symbols.CircleSymbol
 */
define([
    "./Symbol",
    "../utils/Color"
], function (BaseSymbol, Color) {
    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.symbols.CircleSymbol
     * @extends {Symbol}
     * @param {Object} params 
     * @param {String} params.fill , CSS
     * @param {number} params.opacity ,01
     * @param {String} params.stroke , CSS
     * @param {number} params.stroke-width , 
     * @param {number} params.dx x
     * @param {number} params.dy y
     * @param {number} params.radius , 
     * @property {string} type - 
     * @property {Array} color 
     * @property {Array} strokeColor 
     * @property {number} strokeWidth 
     * @property {number} radius 
     * @property {number} dx x
     * @property {number} dy y
     */
    var CircleSymbol = function (params) {
        BaseSymbol.call(this, params);
        this.type = "circle";
        var color = Color.parse(params.color || params.fill || "#FF0000"),
            opacity = params.opacity || 1,
            strokeColor = Color.parse(params.strokeColor || params.stroke || "#FFFFFF"),
            strokeOpacity = params.strokeOpacity || 1;
        this.radius = Number(params.radius || params.r || 5);
        this.strokeWidth = Number(params.strokeWidth || params['stroke-width'] || 0);
        this.pitchWithMap = !!params.pitchWithMap;
        this.scaleWithPitch = !!params.scaleWithPitch;
        this.dx = Number(params.dx || 0);
        this.dy = Number(params.dy || 0);
        this.angle = Number(params.angle || 0);
        this.color = [color.r, color.g, color.b, color.a];
        this.strokeColor = [strokeColor.r, strokeColor.g, strokeColor.b, strokeColor.a];

        this.uniforms = {
            "color": this.color,
            "opacity": opacity,
            "u_device_pixel_ratio": 1,
            "u_pitch_with_map": this.pitchWithMap,
            "u_scale_with_map": this.scaleWithPitch,
            "blur": 0,
            "stroke_color": this.strokeColor,
            "stroke_width": this.strokeWidth,
            "stroke_opacity": strokeOpacity,
            "radius": this.radius,
            "u_radian": 0
        };
    };
    if (BaseSymbol) CircleSymbol.__proto__ = BaseSymbol;
    CircleSymbol.prototype = Object.create(BaseSymbol && BaseSymbol.prototype);
    CircleSymbol.prototype.constructor = CircleSymbol;

    /**
     * 
     * @param {number} radius 
     */
    CircleSymbol.prototype.setRadius = function (radius) {
        this.radius = radius;
        this.uniforms["radius"] = radius;
    };

    /**
     * 
     * @param {number} strokeWidth 
     */
    CircleSymbol.prototype.setStrokeWidth = function (strokeWidth) {
        this.uniforms["stroke_width"] = strokeWidth;
    };

    return CircleSymbol;
});

},
'com/huayun/webgis/utils/Color':function(){
define([], function () {

    var kCSSColorTable = {
        "transparent": [0, 0, 0, 0], "aliceblue": [240, 248, 255, 1],
        "antiquewhite": [250, 235, 215, 1], "aqua": [0, 255, 255, 1],
        "aquamarine": [127, 255, 212, 1], "azure": [240, 255, 255, 1],
        "beige": [245, 245, 220, 1], "bisque": [255, 228, 196, 1],
        "black": [0, 0, 0, 1], "blanchedalmond": [255, 235, 205, 1],
        "blue": [0, 0, 255, 1], "blueviolet": [138, 43, 226, 1],
        "brown": [165, 42, 42, 1], "burlywood": [222, 184, 135, 1],
        "cadetblue": [95, 158, 160, 1], "chartreuse": [127, 255, 0, 1],
        "chocolate": [210, 105, 30, 1], "coral": [255, 127, 80, 1],
        "cornflowerblue": [100, 149, 237, 1], "cornsilk": [255, 248, 220, 1],
        "crimson": [220, 20, 60, 1], "cyan": [0, 255, 255, 1],
        "darkblue": [0, 0, 139, 1], "darkcyan": [0, 139, 139, 1],
        "darkgoldenrod": [184, 134, 11, 1], "darkgray": [169, 169, 169, 1],
        "darkgreen": [0, 100, 0, 1], "darkgrey": [169, 169, 169, 1],
        "darkkhaki": [189, 183, 107, 1], "darkmagenta": [139, 0, 139, 1],
        "darkolivegreen": [85, 107, 47, 1], "darkorange": [255, 140, 0, 1],
        "darkorchid": [153, 50, 204, 1], "darkred": [139, 0, 0, 1],
        "darksalmon": [233, 150, 122, 1], "darkseagreen": [143, 188, 143, 1],
        "darkslateblue": [72, 61, 139, 1], "darkslategray": [47, 79, 79, 1],
        "darkslategrey": [47, 79, 79, 1], "darkturquoise": [0, 206, 209, 1],
        "darkviolet": [148, 0, 211, 1], "deeppink": [255, 20, 147, 1],
        "deepskyblue": [0, 191, 255, 1], "dimgray": [105, 105, 105, 1],
        "dimgrey": [105, 105, 105, 1], "dodgerblue": [30, 144, 255, 1],
        "firebrick": [178, 34, 34, 1], "floralwhite": [255, 250, 240, 1],
        "forestgreen": [34, 139, 34, 1], "fuchsia": [255, 0, 255, 1],
        "gainsboro": [220, 220, 220, 1], "ghostwhite": [248, 248, 255, 1],
        "gold": [255, 215, 0, 1], "goldenrod": [218, 165, 32, 1],
        "gray": [128, 128, 128, 1], "green": [0, 128, 0, 1],
        "greenyellow": [173, 255, 47, 1], "grey": [128, 128, 128, 1],
        "honeydew": [240, 255, 240, 1], "hotpink": [255, 105, 180, 1],
        "indianred": [205, 92, 92, 1], "indigo": [75, 0, 130, 1],
        "ivory": [255, 255, 240, 1], "khaki": [240, 230, 140, 1],
        "lavender": [230, 230, 250, 1], "lavenderblush": [255, 240, 245, 1],
        "lawngreen": [124, 252, 0, 1], "lemonchiffon": [255, 250, 205, 1],
        "lightblue": [173, 216, 230, 1], "lightcoral": [240, 128, 128, 1],
        "lightcyan": [224, 255, 255, 1], "lightgoldenrodyellow": [250, 250, 210, 1],
        "lightgray": [211, 211, 211, 1], "lightgreen": [144, 238, 144, 1],
        "lightgrey": [211, 211, 211, 1], "lightpink": [255, 182, 193, 1],
        "lightsalmon": [255, 160, 122, 1], "lightseagreen": [32, 178, 170, 1],
        "lightskyblue": [135, 206, 250, 1], "lightslategray": [119, 136, 153, 1],
        "lightslategrey": [119, 136, 153, 1], "lightsteelblue": [176, 196, 222, 1],
        "lightyellow": [255, 255, 224, 1], "lime": [0, 255, 0, 1],
        "limegreen": [50, 205, 50, 1], "linen": [250, 240, 230, 1],
        "magenta": [255, 0, 255, 1], "maroon": [128, 0, 0, 1],
        "mediumaquamarine": [102, 205, 170, 1], "mediumblue": [0, 0, 205, 1],
        "mediumorchid": [186, 85, 211, 1], "mediumpurple": [147, 112, 219, 1],
        "mediumseagreen": [60, 179, 113, 1], "mediumslateblue": [123, 104, 238, 1],
        "mediumspringgreen": [0, 250, 154, 1], "mediumturquoise": [72, 209, 204, 1],
        "mediumvioletred": [199, 21, 133, 1], "midnightblue": [25, 25, 112, 1],
        "mintcream": [245, 255, 250, 1], "mistyrose": [255, 228, 225, 1],
        "moccasin": [255, 228, 181, 1], "navajowhite": [255, 222, 173, 1],
        "navy": [0, 0, 128, 1], "oldlace": [253, 245, 230, 1],
        "olive": [128, 128, 0, 1], "olivedrab": [107, 142, 35, 1],
        "orange": [255, 165, 0, 1], "orangered": [255, 69, 0, 1],
        "orchid": [218, 112, 214, 1], "palegoldenrod": [238, 232, 170, 1],
        "palegreen": [152, 251, 152, 1], "paleturquoise": [175, 238, 238, 1],
        "palevioletred": [219, 112, 147, 1], "papayawhip": [255, 239, 213, 1],
        "peachpuff": [255, 218, 185, 1], "peru": [205, 133, 63, 1],
        "pink": [255, 192, 203, 1], "plum": [221, 160, 221, 1],
        "powderblue": [176, 224, 230, 1], "purple": [128, 0, 128, 1],
        "rebeccapurple": [102, 51, 153, 1],
        "red": [255, 0, 0, 1], "rosybrown": [188, 143, 143, 1],
        "royalblue": [65, 105, 225, 1], "saddlebrown": [139, 69, 19, 1],
        "salmon": [250, 128, 114, 1], "sandybrown": [244, 164, 96, 1],
        "seagreen": [46, 139, 87, 1], "seashell": [255, 245, 238, 1],
        "sienna": [160, 82, 45, 1], "silver": [192, 192, 192, 1],
        "skyblue": [135, 206, 235, 1], "slateblue": [106, 90, 205, 1],
        "slategray": [112, 128, 144, 1], "slategrey": [112, 128, 144, 1],
        "snow": [255, 250, 250, 1], "springgreen": [0, 255, 127, 1],
        "steelblue": [70, 130, 180, 1], "tan": [210, 180, 140, 1],
        "teal": [0, 128, 128, 1], "thistle": [216, 191, 216, 1],
        "tomato": [255, 99, 71, 1], "turquoise": [64, 224, 208, 1],
        "violet": [238, 130, 238, 1], "wheat": [245, 222, 179, 1],
        "white": [255, 255, 255, 1], "whitesmoke": [245, 245, 245, 1],
        "yellow": [255, 255, 0, 1], "yellowgreen": [154, 205, 50, 1]
    };

    function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
        i = Math.round(i);
        return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
        return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parse_css_int(str) {  // int or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_byte(parseFloat(str) / 100 * 255);
        }
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {  // float or percentage.
        if (str[str.length - 1] === '%') {
            return clamp_css_float(parseFloat(str) / 100);
        }
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }

        if (h * 6 < 1) {
            return m1 + (m2 - m1) * h * 6;
        }
        if (h * 2 < 1) {
            return m2;
        }
        if (h * 3 < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }

    function parseCSSColor(css_str) {
        var str = css_str.replace(/ /g, '').toLowerCase();

        if (str in kCSSColorTable) { return kCSSColorTable[str].slice(); }  // dup.
        // #
        if (str[0] === '#') {
            if (str.length === 4) { //  #FFF
                var iv = parseInt(str.substr(1), 16);
                if (!(iv >= 0 && iv <= 0xfff)) {
                    return null;
                }
                return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
                    (iv & 0xf) | ((iv & 0xf) << 4),
                    1];
            } else if (str.length === 7) { //  #FFFFFF
                var iv = parseInt(str.substr(1), 16);
                if (!(iv >= 0 && iv <= 0xffffff)) {
                    return null;
                }
                return [(iv & 0xff0000) >> 16,
                    (iv & 0xff00) >> 8,
                    iv & 0xff,
                    1];
            }
            return null;
        }
        // 0xff0000
        if(str.substr(0,2) === '0x'){
            if (str.length === 5) { //  #FFF
                var iv = parseInt(str.substr(2), 16);
                if (!(iv >= 0 && iv <= 0xfff)) {
                    return null;
                }
                return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
                    (iv & 0xf) | ((iv & 0xf) << 4),
                    1];
            } else if (str.length === 8) { //  #FFFFFF
                var iv = parseInt(str.substr(2), 16);
                if (!(iv >= 0 && iv <= 0xffffff)) {
                    return null;
                }
                return [(iv & 0xff0000) >> 16,
                    (iv & 0xff00) >> 8,
                    iv & 0xff,
                    1];
            }
            return null;
        }
        var op = str.indexOf('('), ep = str.indexOf(')');
        if (op !== -1 && ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op + 1, ep - (op + 1)).split(',');
            var alpha = 1;  // To allow case fallthrough.
            switch (fname) {
                case 'rgba':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'rgb':
                    if (params.length !== 3) {
                        return null;
                    }
                    return [parse_css_int(params[0]),
                        parse_css_int(params[1]),
                        parse_css_int(params[2]),
                        alpha];
                case 'hsla':
                    if (params.length !== 4) {
                        return null;
                    }
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case 'hsl':
                    if (params.length !== 3) {
                        return null;
                    }
                    var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                        clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                        clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                        alpha];
                default:
                    return null;
            }
        }
        var rgb = str.split(",");
        if (rgb.length === 3) {
            return [parse_css_int(rgb[0]),
                parse_css_int(rgb[1]),
                parse_css_int(rgb[2]),
                1];
        }else if (rgb.length === 4) {
            return [parse_css_int(rgb[0]),
                parse_css_int(rgb[1]),
                parse_css_int(rgb[2]),
                parse_css_float(rgb[3])
                ];
        }
        return null;
    }

    var Color = function Color(r, g, b, a) {
        if (a === void 0) a = 1;
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    };

    Color.parse = function parse(input) {
        if (!input) {
            return undefined;
        }

        if (input instanceof Color) {
            return input;
        }

        if(input instanceof Array) {
            return new Color(input[0], input[1], input[2], input[3]);
        }

        if (typeof input !== 'string') {
            return undefined;
        }

        var rgba = parseCSSColor(input);
        if (!rgba) {
            return undefined;
        }

        return new Color(
            rgba[0] / 255 * rgba[3],
            rgba[1] / 255 * rgba[3],
            rgba[2] / 255 * rgba[3],
            rgba[3]
        );
    };

    Color.prototype.toString = function toString() {
        var ref = this.toArray();
        var r = ref[0];
        var g = ref[1];
        var b = ref[2];
        var a = ref[3];
        return ("rgba(" + (Math.round(r)) + "," + (Math.round(g)) + "," + (Math.round(b)) + "," + a + ")");
    };

    Color.prototype.toArray = function toArray() {
        var ref = this;
        var r = ref.r;
        var g = ref.g;
        var b = ref.b;
        var a = ref.a;
        return a === 0 ? [0, 0, 0, 0] : [
            r * 255 / a,
            g * 255 / a,
            b * 255 / a,
            a
        ];
    };
    Color.black = new Color(0, 0, 0, 1);
    Color.white = new Color(1, 1, 1, 1);
    Color.transparent = new Color(0, 0, 0, 0);
    Color.red = new Color(1, 0, 0, 1);

    return Color;
});

},
'com/huayun/webgis/layers/support/UnitBezier':function(){
define([], function () {
  /**
   * 
   * @private
   * @ignore
   * @param p1x
   * @param p1y
   * @param p2x
   * @param p2y
   * @constructor
   */
  function UnitBezier(p1x, p1y, p2x, p2y) {
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
  }

  UnitBezier.prototype.sampleCurveX = function (t) {
    return ((this.ax * t + this.bx) * t + this.cx) * t;
  };

  UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
  };

  UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
  };

  UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined') {
      epsilon = 1e-6;
    }

    var t0, t1, t2, x2, i;

    for (t2 = x, i = 0; i < 8; i++) {
      x2 = this.sampleCurveX(t2) - x;
      if (Math.abs(x2) < epsilon) {
        return t2;
      }

      var d2 = this.sampleCurveDerivativeX(t2);
      if (Math.abs(d2) < 1e-6) {
        break;
      }
      t2 = t2 - x2 / d2;
    }

    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) {
      return t0;
    }
    if (t2 > t1) {
      return t1;
    }

    while (t0 < t1) {
      x2 = this.sampleCurveX(t2);
      if (Math.abs(x2 - x) < epsilon) {
        return t2;
      }

      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }

      t2 = (t1 - t0) * 0.5 + t0;
    }

    return t2;
  };

  UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
  };

  return UnitBezier;
});
},
'com/huayun/webgis/layers/support/LOD':function(){
/**
 * LOD
 */
define([], function () {
    /**
     * @ignore
     * @param params
     * @alias com.huayun.webgis.layer.support.LOD
     * @constructor
     */
    function LOD(params) {
        this.level = params.level;
        this.scale = params.scale;
        this.resolution = params.resolution;
    }

    LOD.prototype.toString = function () {
        return "level: " + this.level + " scale: " + this.scale + " resolution: " + this.resolution;
    }

    return LOD;
});
},
'com/huayun/webgis/renderer/LineRenderer':function(){
define([
    "./Renderer",
    "../geometry/Point",
    "../data/bucket/LineBucketSimplify",
    "../gl/mode",
    "../gl/programAttributes",
    "../gl/programCache"
], function (Renderer, Point, LineBucket, mode, programAttributes, programCache) {

    function LineRenderer() {

    }

    if (Renderer) LineRenderer.__proto__ = Renderer;
    LineRenderer.prototype = Object.create(Renderer && Renderer.prototype);
    LineRenderer.prototype.constructor = LineRenderer;

    var lineUniformValues = function (view, graphic, symbol) {
        var uniform = symbol.uniforms;
        var position = graphic.position;
        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0], position[1], false, false, position[2] || 0);
        uniform["u_units_to_pixels"] = [view.viewpoint.width / 2, -view.viewpoint.height / 2];
        uniform["u_ratio"] = 1 / view.viewpoint.resolution;
        return uniform;
    };

    var lineSDFUniformValues = function (view, graphic, symbol, dasharray) {
        var r = 1 / view.resolution;
        var uniform = symbol.uniforms;
        var position = graphic.position;
        var round = symbol.cap === "round";
        var posA = view.lineAtlas.getDash(dasharray.from, round);
        var posB = view.lineAtlas.getDash(dasharray.to, round);
        var widthA = posA.width * 2;
        var widthB = posB.width * 1;

        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0], position[1], false, false, position[2] || 0);
        uniform["u_units_to_pixels"] = [view.viewpoint.width / 2, -view.viewpoint.height / 2];
        uniform["u_ratio"] = r;
        uniform["u_image"] = 0;
        uniform["u_patternscale_a"] = [r / widthA, -posA.height / 2];
        uniform["u_patternscale_b"] = [r / widthB, -posB.height / 2];
        uniform["u_sdfgamma"] = view.lineAtlas.width / (Math.min(widthA, widthB) * 256) / 2;
        uniform["u_tex_y_a"] = posA.y;
        uniform["u_tex_y_b"] = posB.y;
        return uniform;
    };

    LineRenderer.prototype.add = function (view, graphic, geometry, symbol) {
        if (view.ground) {
            var ps = geometry.path[0];
            for (var j = 0; j < ps.length; j++) {
                var p = ps[j];
                /*if (p.base && !p.base.posMidified) {
                    graphic.needAdd = true;
                    return;
                } else {
                    p.z += p.base.position.z;
                    p.base = null;
                }*/
                if (p.base) {
                    if (p.base.posMidified) {
                        p.z += p.base.z;
                        p.base = null;
                    } else {
                        graphic.needAdd = true;
                        view.threeRender();
                        return;
                    }
                }
            }
        }
        graphic.needAdd = false;
        var center = graphic.position || view.viewpoint.center || [0, 0],
            cx = center[0],
            cy = center[1];
        if (geometry.type === 'multipolygon') {
            var buckets = [];
            for (var i = 0; i < geometry.polygons.length; i++) {
                var polygon = geometry.polygons[i];
                var bucket = this._addOnePathFeature(polygon, view, graphic, symbol, cx, cy);
                buckets.push(bucket);
            }
            graphic.buckets.push(buckets);
        } else {
            var bucket = this._addOnePathFeature(geometry, view, graphic, symbol, cx, cy);
            graphic.buckets.push(bucket);
        }
        graphic.position = [cx, cy, 0];
    };
    /**
     * 
     * @param { any } geometry
     * @param { any } view
     * @param { any } graphic
     * @param { any } symbol
     * @param cx
     * @param cy
     * @private
     */
    LineRenderer.prototype._addOnePathFeature = function (geometry, view, graphic, symbol, cx, cy) {
        var points = geometry.path;
        var g = [];
        for (var i = 0; i < points.length; i++) {
            var line = points[i];
            var l = [];
            var oldP = new Point(-1, -1);
            for (var j = 0; j < line.length; j++) {
                var p = line[j];
                if (oldP.equals(p)) {
                    continue;
                }

                l.push(new Point(p.x - cx, p.y - cy, p.z));
                oldP = p;
            }
            g.push(l);
        }
        var bucket = new LineBucket();
        bucket.addFeature(g, symbol.join, symbol.cap, 2, 1.05);
        bucket.upload(view.context);
        return bucket;
    }

    LineRenderer.prototype.draw = function (view, graphic, geometry, symbol, layerView, index, sizeRight) {
        if (graphic.needAdd || graphic.buckets.length === 0) {
            this.add(view, graphic, geometry, symbol);
            if (graphic.needAdd) return;
        }
        if (index === undefined) index = 0;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadWrite);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadWrite, [0.9, 0.9]);
        }
        var colorMode = mode.ColorMode.alphaBlended;
        var buckets = graphic.buckets;
        var dasharray = symbol.dasharray;
        if (dasharray) {
            context.activeTexture.set(gl.TEXTURE0);
            view.lineAtlas.bind(context);
        }
        var programId = dasharray ? "basicLineSDF" : "myline"; // 
        var program = programCache.useProgramSimplify(context, programId, programAttributes.basicLine);
        var uniform = dasharray ? lineSDFUniformValues(view, graphic, symbol, dasharray) : lineUniformValues(view, graphic, symbol);
        // var tempV = this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
        if (!sizeRight) {
            var w = symbol.width * this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
            uniform['u_width'] = w < 1 ? 1 : w;
        }
        uniform['u_color'] = symbol.color;
        var bucket = buckets[index];
        if (geometry.type === "multipolygon") {
            bucket.forEach(function (bck, indice) {
                program.draw(context, gl.TRIANGLES, depthMode, null, colorMode, mode.CullFaceMode.disabled, uniform,
                    graphic.id + "-line" + index + "-" + indice, bck.layoutVertexBuffer, bck.indexBuffer, bck.segments);
            });
        } else {
            program.draw(context, gl.TRIANGLES, depthMode, null, colorMode, mode.CullFaceMode.disabled, uniform,
                graphic.id + "-line" + index, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments);
        }
    }

    LineRenderer.prototype.drawGlow = function (view, graphic, geometry, symbol, layerView, index, sizeRight) {
        var glow = graphic.glow;
        if (!glow) return;
        if (index === undefined) index = 0;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadWrite);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadWrite, [0.9, 0.9]);
        }
        var colorMode = mode.ColorMode.alphaBlended;
        var buckets = graphic.buckets;
        var dasharray = symbol.dasharray;
        if (dasharray) {
            context.activeTexture.set(gl.TEXTURE0);
            view.lineAtlas.bind(context);
        }
        var programId = dasharray ? "basicLineSDF" : "basicLine"; // 
        var program = programCache.useProgramSimplify(context, programId, programAttributes.basicLine);
        var uniform = dasharray ? lineSDFUniformValues(view, graphic, symbol, dasharray) : lineUniformValues(view, graphic, symbol);
        // var tempV = this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
        if (!sizeRight) {
            var w = symbol.width * this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
            uniform['u_width'] = w < 1 ? 1 : w;
        }
        var bucket = buckets[index];
        uniform['u_color'] = glow.color;
        program.draw(context, gl.TRIANGLES, depthMode, null, colorMode, mode.CullFaceMode.disabled, uniform,
            graphic.id + "-line" + index, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments);
    }

    LineRenderer.prototype.calculateExtent = function (view, graphic, geometry, symbol, result, index) {
        var extent = geometry.extent;
        result.push({
            id: graphic.id,
            g: graphic,
            minX: extent.xmin,
            minY: extent.ymin,
            maxX: extent.xmax,
            maxY: extent.ymax,
            symbol: symbol
        });
    };

    return LineRenderer;
});

},
'com/huayun/webgis/data/captureIntersects':function(){
define(["exports", "../utils/utils", "custom/gl-matrix-min"], function (exports, utils, glMatrix) {

    function polygonContainsPoint(ring, p) {
        var c = false;
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            var p1 = ring[i];
            var p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
        return c;
    }

    function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
        return utils.isCounterClockwise(a0, b0, b1) !== utils.isCounterClockwise(a1, b0, b1) &&
            utils.isCounterClockwise(a0, a1, b0) !== utils.isCounterClockwise(a0, a1, b1);
    }

    function distToSegmentSquared(p, v, w) {
        var l2 = v.distSqr(w);
        if (l2 === 0) {
            return p.distSqr(v);
        }
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) {
            return p.distSqr(v);
        }
        if (t > 1) {
            return p.distSqr(w);
        }
        return p.distSqr(w.sub(v)._mult(t)._add(v));
    }

    function pointIntersectsBufferedLine(p, line, radius) {
        var radiusSquared = radius * radius;
        if (line.length === 1) {
            return p.distSqr(line[0]) < radiusSquared;
        }
        for (var i = 1; i < line.length; i++) {
            var v = line[i - 1], w = line[i];
            if (distToSegmentSquared(p, v, w) < radiusSquared) {
                return true;
            }
        }
        return false;
    }

    function getPixelPosMatrix(transform, matrix) {
        var t = glMatrix.mat4.identity([]);
        glMatrix.mat4.translate(t, t, [1, 1, 0]);
        glMatrix.mat4.scale(t, t, [transform.width * 0.5, transform.height * 0.5, 1]);
        return glMatrix.mat4.multiply(t, t, matrix);
    }

    function polygonIntersectsBufferedPoint(polygon, point, radius) {
        if (polygonContainsPoint(polygon, point)) { return true; }
        if (pointIntersectsBufferedLine(point, polygon, radius)) { return true; }
        return false;
    }

    function polygonIntersectsPoint(queryGeometry, geometry, symbol, resolution, radius, viewpoint) {
        var pixelPosMatrix = getPixelPosMatrix(viewpoint, symbol.uniforms.u_matrix);
        var stroke = symbol.strokeWidth || 0;
        radius = symbol.captureRadius||15;
        var size  = radius + stroke;
        var alignWithMap = symbol.pitchWithMap;
        var transformedPolygon = alignWithMap ? queryGeometry : utils.projectQueryGeometry(queryGeometry, pixelPosMatrix);
        // var transformedSize = alignWithMap ? size * resolution : size;
        var transformedSize = (radius + stroke);// * resolution;
        var point = geometry;
        var transformedPoint = alignWithMap ? point : utils.projectPoint(point, pixelPosMatrix);

        var adjustedSize = transformedSize;
        var projectedCenter = glMatrix.vec4.transformMat4([], [point.x, point.y, 0, 1], pixelPosMatrix);
        if (!symbol.scaleWithPitch && alignWithMap) {
            adjustedSize *= projectedCenter[3] / viewpoint.cameraToCenterDistance;
        } else if (symbol.scaleWithPitch && !alignWithMap) {
            adjustedSize *= viewpoint.cameraToCenterDistance / projectedCenter[3];
        }
        if (polygonIntersectsBufferedPoint(transformedPolygon, transformedPoint, adjustedSize)) { return true; }
    }
    exports.point = polygonIntersectsPoint;


    function lineIntersectsLine(lineA, lineB) {
        if (lineA.length === 0 || lineB.length === 0) {
            return false;
        }
        for (var i = 0; i < lineA.length - 1; i++) {
            var a0 = lineA[i];
            var a1 = lineA[i + 1];
            for (var j = 0; j < lineB.length - 1; j++) {
                var b0 = lineB[j];
                var b1 = lineB[j + 1];
                if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) {
                    return true;
                }
            }
        }
        return false;
    }

    function lineIntersectsBufferedLine(lineA, lineB, radius) {
        if (lineA.length > 1) {
            if (lineIntersectsLine(lineA, lineB)) {
                return true;
            }
            for (var j = 0; j < lineB.length; j++) {
                if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) {
                    return true;
                }
            }
        }
        for (var k = 0; k < lineA.length; k++) {
            if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) {
                return true;
            }
        }
        return false;
    }

    function polygonIntersectsBufferedMultiLine(polygon, multiLine, symbol, resolution, radius, viewpoint, captureWidth) {
        multiLine = multiLine.path;
        var radius = (symbol.width + captureWidth||4) * resolution / 2;
        for (var i = 0; i < multiLine.length; i++) {
            var line = multiLine[i];

            if (polygon.length >= 3) {
                for (var k = 0; k < line.length; k++) {
                    if (polygonContainsPoint(polygon, line[k])) {
                        return true;
                    }
                }
            }

            if (lineIntersectsBufferedLine(polygon, line, radius)) {
                return true;
            }
        }
        return false;
    }

    exports.line = polygonIntersectsBufferedMultiLine;

});
},
'com/huayun/webgis/Graphic':function(){
/**
 * 
 * @module com/huayun/webgis
 * @see com.huayun.webgis.Graphic
 */
define([
    "./utils/Color"
], function (Color) {
    var u = 0;

    /**
     * , 
     * @constructor
     * @alias com.huayun.webgis.Graphic
     * @param {Object} params 
     * @param {Feature} params.feature 
     * @param {Symbol} params.symbol 
     * @param {Boolean} params.visible 
     * @param {Boolean} params.selectEnabled 
     * @property {number} id id
     * @property {Feature} feature 
     * @property {Layer} layer 
     * @property {Symbol} symbol 
     * @property {Boolean} visible 
     * @property {Boolean} selectEnabled 
     * @property {Object} glow 
     */
    function Graphic(params) {
        this.id = params.id === undefined ? u++ : params.id;
        this.feature = params.feature;
        this.layer = params.layer;
        this.symbol = params.symbol;
        this.position = null;
        this.visible = params.visible === undefined ? true : params.visible;
        this.selectEnabled = params.selectEnabled === undefined ? true : params.selectEnabled;
        this._glow = null;
        this.buckets = [];
        this.isChangeSymbol = true;

        this.renderer = params.renderer?params.renderer:null;
    }

    /**
     * 
     * @params {Boolean} visible  - 
     */
    Graphic.prototype.setVisible = function (visible) {
        this.visible = value;
    };
    /**
     * 
     * @params {number} dx 
     * @params {number} dy 
     * @params {number} dz 
     */
    Graphic.prototype.updatePosition = function (dx, dy, dz) {
        this.position[0] += dx;
        this.position[1] += dy;
        if (dz) {
            this.position[2] += dz;
        }
    };

    Graphic.prototype.updateGeometry = function (dx, dy) {
        this.layer.indexNeedUpdate = true;
        this.feature.geometry.update(dx, dy);
    };

    Graphic.prototype.getAttribute = function (name) {
        return this.feature.attributes.find(function (item) {
            return item.name && item.name.toLowerCase() === name.toLowerCase();
        });
    };

    Graphic.prototype.updateSymbol = function (symbol) {
        this.symbol = symbol;
        this.layer.layerView.view.threeRender();
    };

    Graphic.prototype.reset = function () {
        var buckets = this.buckets;
        if (buckets) {
            buckets.forEach(function (bucket) {
                bucket.destroy();
            });
        }
        this.buckets = [];
    }

    Graphic.prototype.destroy = function () {
        this.buckets.forEach(function (item) {
            item.destroy();
        });
        this.buckets = [];
    }

    var prototypeAccessors = {
        glow: {configurable: true}
    };
    prototypeAccessors.glow.set = function (prop) {
        if (prop && prop.color) {
            this._glow = prop;
            var color = Color.parse(prop.color);
            this._glow.color = [color.r, color.g, color.b, color.a]
        } else {
            this._glow = null;
        }
    };
    prototypeAccessors.glow.get = function () {
        return this._glow;
    };

    Object.defineProperties(Graphic.prototype, prototypeAccessors);
    return Graphic;
});

},
'com/huayun/webgis/geometry/Anchor':function(){
define([
    "../geometry/Point"
], function (Point) {
    return (function (Point) {
        function Anchor(x, y, angle, segment) {
            Point.call(this, x, y);
            this.angle = angle;
            if (segment !== undefined) {
                this.segment = segment;
            }
        }

        if (Point) Anchor.__proto__ = Point;
        Anchor.prototype = Object.create(Point && Point.prototype);
        Anchor.prototype.constructor = Anchor;
        /**
         * 
         */
        Anchor.prototype.clone = function clone() {
            return new Anchor(this.x, this.y, this.angle, this.segment);
        };

        return Anchor;
    }(Point));
});
},
'com/huayun/webgis/data/bucket/SymbolBucket':function(){
/**
 *  @author :   wushengfei
 *  @date   :   2019/7/24
 *  @description : OK
 */
define([
    "../ArrayType",
    "../../gl/SegmentVector",
    "../../gl/programConfig",
    "../../gl/dataTransfer",
    "../../gl/members",
    "../../geometry/Point2D",
    "../../layers/support/EvaluationParameters",
    "../../layers/support/expression/Formatted",
    "../../utils/utils",
    "../../utils/Constant"
], function (ArrayType, SegmentVector, programConfig, dataTransfer, members,Point,
             EvaluationParameters, Formatted, utils, Constant) {

    var SymbolBuffers = function SymbolBuffers(programConfigurations) {
        this.layoutVertexArray = new ArrayType.StructArrayLayout4i4ui16();
        this.indexArray = new ArrayType.StructArrayLayout3ui6();
        this.programConfigurations = programConfigurations;
        this.segments = new SegmentVector();
        this.dynamicLayoutVertexArray = new ArrayType.StructArrayLayout3f12();
        this.opacityVertexArray = new ArrayType.StructArrayLayout1ul4();
        this.placedSymbolArray = new ArrayType.PlacedSymbolArray();
    };

    SymbolBuffers.prototype.upload = function upload(context, dynamicIndexBuffer, upload$1, update) {
        if (upload$1) {
            this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, members.symbolLayoutAttributes.members);
            this.indexBuffer = context.createIndexBuffer(this.indexArray, dynamicIndexBuffer);
            this.dynamicLayoutVertexBuffer = context.createVertexBuffer(this.dynamicLayoutVertexArray, members.dynamicLayoutAttributes.members, true);
            this.opacityVertexBuffer = context.createVertexBuffer(this.opacityVertexArray, members.shaderOpacityAttributes, true);
            this.opacityVertexBuffer.itemSize = 1;
        }
        if (upload$1 || update) {
            this.programConfigurations.upload(context);
        }
    };

    SymbolBuffers.prototype.destroy = function destroy() {
        if (!this.layoutVertexBuffer) {
            return;
        }
        this.layoutVertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.programConfigurations.destroy();
        this.segments.destroy();
        this.dynamicLayoutVertexBuffer.destroy();
        this.opacityVertexBuffer.destroy();
    };


    var CollisionBuffers = function CollisionBuffers(LayoutArray, layoutAttributes, IndexArray) {
        this.layoutVertexArray = new LayoutArray();
        this.layoutAttributes = layoutAttributes;
        this.indexArray = new IndexArray();
        this.segments = new SegmentVector();
        this.collisionVertexArray = new ArrayType.StructArrayLayout2ub2f12();
    };

    CollisionBuffers.prototype.upload = function upload(context) {
        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes);
        this.indexBuffer = context.createIndexBuffer(this.indexArray);
        this.collisionVertexBuffer = context.createVertexBuffer(this.collisionVertexArray, [
            {name: 'a_placed', components: 2, type: 'Uint8', offset: 0},
            {name: 'a_shift', components: 2, type: 'Float32', offset: 4}
        ], true);
    };

    CollisionBuffers.prototype.destroy = function destroy() {
        if (!this.layoutVertexBuffer) {
            return;
        }
        this.layoutVertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.segments.destroy();
        this.collisionVertexBuffer.destroy();
    };

    console.log("SymbolBuffers");
    dataTransfer.register('SymbolBuffers', SymbolBuffers);
    dataTransfer.register('CollisionBuffers', CollisionBuffers);

    function transformText(text, layer, feature) {
        text.sections.forEach(function (section) {

            var transform = layer.layout.get('text-transform').evaluate(feature, {});
            if (transform === 'uppercase') {
                section.text = section.text.toLocaleUpperCase();
            } else if (transform === 'lowercase') {
                section.text = section.text.toLocaleLowerCase();
            }
        });
        return text;
    }

    function getSizeData(tileZoom, value) {
        var expression = value.expression;

        if (expression.kind === 'constant') {
            var layoutSize = expression.evaluate(new EvaluationParameters(tileZoom + 1));
            return {kind: 'constant', layoutSize: layoutSize};

        } else if (expression.kind === 'source') {
            return {kind: 'source'};

        } else {
            var zoomStops = expression.zoomStops;
            var interpolationType = expression.interpolationType;

            var lower = 0;
            while (lower < zoomStops.length && zoomStops[lower] <= tileZoom) {
                lower++;
            }
            lower = Math.max(0, lower - 1);
            var upper = lower;
            while (upper < zoomStops.length && zoomStops[upper] < tileZoom + 1) {
                upper++;
            }
            upper = Math.min(zoomStops.length - 1, upper);

            var minZoom = zoomStops[lower];
            var maxZoom = zoomStops[upper];

            if (expression.kind === 'composite') {
                return {kind: 'composite', minZoom: minZoom, maxZoom: maxZoom, interpolationType: interpolationType};
            }

            var minSize = expression.evaluate(new EvaluationParameters(minZoom));
            var maxSize = expression.evaluate(new EvaluationParameters(maxZoom));

            return {
                kind: 'camera',
                minZoom: minZoom,
                maxZoom: maxZoom,
                minSize: minSize,
                maxSize: maxSize,
                interpolationType: interpolationType
            };
        }
    }

    function addVertex(array, anchorX, anchorY, ox, oy, tx, ty, sizeVertex) {
        array.emplaceBack(anchorX, anchorY,// a_pos_offset
            Math.round(ox * 32), Math.round(oy * 32),
            tx, ty, // x, y coordinate of symbol on glyph atlas texture
            sizeVertex ? sizeVertex[0] : 0,
            sizeVertex ? sizeVertex[1] : 0
        );
    }

    function addDynamicAttributes(dynamicLayoutVertexArray, p, angle) {
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
        dynamicLayoutVertexArray.emplaceBack(p.x, p.y, angle);
    }

    function mergeLines(features) {
        var leftIndex = {};
        var rightIndex = {};
        var mergedFeatures = [];
        var mergedIndex = 0;

        function add(k) {
            mergedFeatures.push(features[k]);
            mergedIndex++;
        }

        function mergeFromRight(leftKey, rightKey, geom) {
            var i = rightIndex[leftKey];
            delete rightIndex[leftKey];
            rightIndex[rightKey] = i;

            mergedFeatures[i].geometry[0].pop();
            mergedFeatures[i].geometry[0] = mergedFeatures[i].geometry[0].concat(geom[0]);
            return i;
        }

        function mergeFromLeft(leftKey, rightKey, geom) {
            var i = leftIndex[rightKey];
            delete leftIndex[rightKey];
            leftIndex[leftKey] = i;

            mergedFeatures[i].geometry[0].shift();
            mergedFeatures[i].geometry[0] = geom[0].concat(mergedFeatures[i].geometry[0]);
            return i;
        }

        function getKey(text, geom, onRight) {
            var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
            return (text + ":" + (point.x) + ":" + (point.y));
        }

        for (var k = 0; k < features.length; k++) {
            var feature = features[k];
            var geom = feature.geometry;
            var text = feature.text ? feature.text.toString() : null;

            if (!text) {
                add(k);
                continue;
            }

            var leftKey = getKey(text, geom),
                rightKey = getKey(text, geom, true);

            if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
                // found lines with the same text adjacent to both ends of the current line, merge all three
                var j = mergeFromLeft(leftKey, rightKey, geom);
                var i = mergeFromRight(leftKey, rightKey, mergedFeatures[j].geometry);

                delete leftIndex[leftKey];
                delete rightIndex[rightKey];

                rightIndex[getKey(text, mergedFeatures[i].geometry, true)] = i;
                mergedFeatures[j].geometry = (null);

            } else if (leftKey in rightIndex) {
                // found mergeable line adjacent to the start of the current line, merge
                mergeFromRight(leftKey, rightKey, geom);

            } else if (rightKey in leftIndex) {
                // found mergeable line adjacent to the end of the current line, merge
                mergeFromLeft(leftKey, rightKey, geom);

            } else {
                // no adjacent lines, add as a new item
                add(k);
                leftIndex[leftKey] = mergedIndex - 1;
                rightIndex[rightKey] = mergedIndex - 1;
            }
        }
        return mergedFeatures.filter(function (f) {
            return f.geometry;
        });
    }

    var SymbolBucket = function SymbolBucket(options) {
        this.collisionBoxArray = options.collisionBoxArray;
        this.zoom = options.zoom;
        this.overscaling = options.overscaling;
        this.layers = options.layers;
        this.layerIds = this.layers.map(function (layer) {
            return layer.id;
        });
        this.index = options.index;
        this.pixelRatio = options.pixelRatio;
        this.sourceLayerIndex = options.sourceLayerIndex;
        this.hasPattern = false;

        var layer = this.layers[0];
        var unevaluatedLayoutValues = layer._unevaluatedLayout._values;

        this.textSizeData = getSizeData(this.zoom, unevaluatedLayoutValues['text-size']);
        this.iconSizeData = getSizeData(this.zoom, unevaluatedLayoutValues['icon-size']);

        var layout = this.layers[0].layout;
        var sortKey = layout.get('symbol-sort-key');
        var zOrder = layout.get('symbol-z-order');
        this.sortFeaturesByKey = zOrder !== 'viewport-y' && sortKey.constantOr(1) !== undefined;
        var zOrderByViewportY = zOrder === 'viewport-y' || (zOrder === 'auto' && !this.sortFeaturesByKey);
        this.sortFeaturesByY = zOrderByViewportY && (layout.get('text-allow-overlap') || layout.get('icon-allow-overlap') ||
            layout.get('text-ignore-placement') || layout.get('icon-ignore-placement'));

        this.stateDependentLayerIds = this.layers.filter(function (l) {
            return l.isStateDependent();
        }).map(function (l) {
            return l.id;
        });

        this.sourceID = options.sourceID;
    };

    SymbolBucket.prototype.createArrays = function createArrays() {
        this.text = new SymbolBuffers(new programConfig.ProgramConfigurationSet(members.symbolLayoutAttributes.members, this.layers, this.zoom, function (property) {
            return /^text/.test(property);
        }));
        this.icon = new SymbolBuffers(new programConfig.ProgramConfigurationSet(members.symbolLayoutAttributes.members, this.layers, this.zoom, function (property) {
            return /^icon/.test(property);
        }));

        this.collisionBox = new CollisionBuffers(ArrayType.StructArrayLayout2i2i2i12, Constant.collisionBoxLayout, ArrayType.StructArrayLayout2ui4);
        this.collisionCircle = new CollisionBuffers(ArrayType.StructArrayLayout2i2i2i12, Constant.collisionCircleLayout, ArrayType.StructArrayLayout3ui6);

        this.glyphOffsetArray = new ArrayType.GlyphOffsetArray();
        this.lineVertexArray = new ArrayType.SymbolLineVertexArray();
        this.symbolInstances = new ArrayType.SymbolInstanceArray();
    };

    SymbolBucket.prototype.calculateGlyphDependencies = function calculateGlyphDependencies(text, stack, textAlongLine, doesAllowVerticalWritingMode) {
        for (var i = 0; i < text.length; i++) {
            stack[text.charCodeAt(i)] = true;
            if (textAlongLine && doesAllowVerticalWritingMode) {
                var verticalChar = Constant.verticalizedCharacterMap[text.charAt(i)];
                if (verticalChar) {
                    stack[verticalChar.charCodeAt(0)] = true;
                }
            }
        }
    };

    SymbolBucket.prototype.populate = function populate(features, options) {
        var layer = this.layers[0];
        var layout = layer.layout;

        var textFont = layout.get('text-font');
        var textField = layout.get('text-field');
        var iconImage = layout.get('icon-image');
        var hasText =
            (textField.value.kind !== 'constant' || textField.value.value.toString().length > 0) &&
            (textFont.value.kind !== 'constant' || textFont.value.value.length > 0)&& !(textField.value.value.toString().startsWith("##"));
        var hasIcon = (iconImage.value.kind !== 'constant' || iconImage.value.value && iconImage.value.value.length > 0)&& !(iconImage.value.value.startsWith("##"));
        var symbolSortKey = layout.get('symbol-sort-key');

        this.features = [];

        if (!hasText && !hasIcon) {
            return;
        }

        var icons = options.iconDependencies;
        var stacks = options.glyphDependencies;
        var globalProperties = new EvaluationParameters(this.zoom);

        for (var i$1 = 0, list$1 = features; i$1 < list$1.length; i$1 += 1) {
            var ref = list$1[i$1];
            var feature = ref.feature;
            var index = ref.index;
            var sourceLayerIndex = ref.sourceLayerIndex;

            if (!layer._featureFilter(globalProperties, feature)) {
                continue;
            }

            var text = (void 0);
            if (hasText) {
                // Expression evaluation will automatically coerce to Formatted
                // but plain string token evaluation skips that pathway so do the
                // conversion here.
                var resolvedTokens = layer.getValueAndResolveTokens('text-field', feature);
                text = transformText(resolvedTokens instanceof Formatted ?
                    resolvedTokens :
                    Formatted.fromString(resolvedTokens),
                    layer, feature);
            }

            var icon = (void 0);
            if (hasIcon) {
                icon = layer.getValueAndResolveTokens('icon-image', feature);
            }

            if (!text && !icon) {
                continue;
            }

            var sortKey = this.sortFeaturesByKey ?
                symbolSortKey.evaluate(feature, {}) :
                undefined;

            var symbolFeature = {
                text: text,
                icon: icon,
                index: index,
                sourceLayerIndex: sourceLayerIndex,
                geometry: utils.loadGeometry(feature),
                properties: feature.properties,
                type: Constant.geometryTypes[feature.type],
                sortKey: sortKey
            };

            if (typeof feature.id !== 'undefined') {
                symbolFeature.id = feature.id;
            }
            this.features.push(symbolFeature);

            if (icon) {
                icons[icon] = true;
            }

            if (text) {
                var fontStack = textFont.evaluate(feature, {}).join(',');
                var textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';
                for (var i = 0, list = text.sections; i < list.length; i += 1) {
                    var section = list[i];

                    var doesAllowVerticalWritingMode = utils.allowsVerticalWritingMode(text.toString());
                    var sectionFont = section.fontStack || fontStack;
                    var sectionStack = stacks[sectionFont] = stacks[sectionFont] || {};
                    this.calculateGlyphDependencies(section.text, sectionStack, textAlongLine, doesAllowVerticalWritingMode);
                }
            }
        }

        if (layout.get('symbol-placement') === 'line') {
            this.features = mergeLines(this.features);
        }

        if (this.sortFeaturesByKey) {
            this.features.sort(function (a, b) {
                return ((a.sortKey)) - ((b.sortKey));
            });
        }
    };

    SymbolBucket.prototype.update = function update(states, vtLayer, imagePositions) {
        if (!this.stateDependentLayers.length) {
            return;
        }
        this.text.programConfigurations.updatePaintArrays(states, vtLayer, this.layers, imagePositions);
        this.icon.programConfigurations.updatePaintArrays(states, vtLayer, this.layers, imagePositions);
    };

    SymbolBucket.prototype.isEmpty = function isEmpty() {
        return this.symbolInstances.length === 0;
    };

    SymbolBucket.prototype.uploadPending = function uploadPending() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
    };

    SymbolBucket.prototype.upload = function upload(context) {
        if (!this.uploaded) {
            this.collisionBox.upload(context);
            this.collisionCircle.upload(context);
        }
        this.text.upload(context, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload);
        this.icon.upload(context, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload);
        this.uploaded = true;
    };

    SymbolBucket.prototype.destroy = function destroy() {
        this.text.destroy();
        this.icon.destroy();
        this.collisionBox.destroy();
        this.collisionCircle.destroy();
    };

    SymbolBucket.prototype.addToLineVertexArray = function addToLineVertexArray(anchor, line) {
        var lineStartIndex = this.lineVertexArray.length;
        if (anchor.segment !== undefined) {
            var sumForwardLength = anchor.dist(line[anchor.segment + 1]);
            var sumBackwardLength = anchor.dist(line[anchor.segment]);
            var vertices = {};
            for (var i = anchor.segment + 1; i < line.length; i++) {
                vertices[i] = {x: line[i].x, y: line[i].y, tileUnitDistanceFromAnchor: sumForwardLength};
                if (i < line.length - 1) {
                    sumForwardLength += line[i + 1].dist(line[i]);
                }
            }
            for (var i$1 = anchor.segment || 0; i$1 >= 0; i$1--) {
                vertices[i$1] = {x: line[i$1].x, y: line[i$1].y, tileUnitDistanceFromAnchor: sumBackwardLength};
                if (i$1 > 0) {
                    sumBackwardLength += line[i$1 - 1].dist(line[i$1]);
                }
            }
            for (var i$2 = 0; i$2 < line.length; i$2++) {
                var vertex = vertices[i$2];
                this.lineVertexArray.emplaceBack(vertex.x, vertex.y, vertex.tileUnitDistanceFromAnchor);
            }
        }
        return {
            lineStartIndex: lineStartIndex,
            lineLength: this.lineVertexArray.length - lineStartIndex
        };
    };

    SymbolBucket.prototype.addSymbols = function addSymbols(arrays, quads, sizeVertex, lineOffset, alongLine,
                                                            feature, writingMode, labelAnchor, lineStartIndex, lineLength) {
        var indexArray = arrays.indexArray;
        var layoutVertexArray = arrays.layoutVertexArray;
        var dynamicLayoutVertexArray = arrays.dynamicLayoutVertexArray;

        var segment = arrays.segments.prepareSegment(4 * quads.length, arrays.layoutVertexArray, arrays.indexArray, feature.sortKey);
        var glyphOffsetArrayStart = this.glyphOffsetArray.length;
        var vertexStartIndex = segment.vertexLength;

        for (var i = 0, list = quads; i < list.length; i += 1) {

            var symbol = list[i];

            var tl = symbol.tl,
                tr = symbol.tr,
                bl = symbol.bl,
                br = symbol.br,
                tex = symbol.tex;

            var index = segment.vertexLength;

            var y = symbol.glyphOffset[1];
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, tl.x, y + tl.y, tex.x, tex.y, sizeVertex);
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, tr.x, y + tr.y, tex.x + tex.w, tex.y, sizeVertex);
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, bl.x, y + bl.y, tex.x, tex.y + tex.h, sizeVertex);
            addVertex(layoutVertexArray, labelAnchor.x, labelAnchor.y, br.x, y + br.y, tex.x + tex.w, tex.y + tex.h, sizeVertex);

            addDynamicAttributes(dynamicLayoutVertexArray, labelAnchor, 0);

            indexArray.emplaceBack(index, index + 1, index + 2);
            indexArray.emplaceBack(index + 1, index + 2, index + 3);

            segment.vertexLength += 4;
            segment.primitiveLength += 2;

            this.glyphOffsetArray.emplaceBack(symbol.glyphOffset[0]);
        }

        // debugger;
        arrays.placedSymbolArray.emplaceBack(labelAnchor.x, labelAnchor.y,
            glyphOffsetArrayStart, this.glyphOffsetArray.length - glyphOffsetArrayStart, vertexStartIndex,
            lineStartIndex, lineLength, (labelAnchor.segment),
            sizeVertex ? sizeVertex[0] : 0, sizeVertex ? sizeVertex[1] : 0,
            lineOffset[0], lineOffset[1],
            writingMode, (false),
            // The crossTileID is only filled/used on the foreground for dynamic text anchors
            0);

        arrays.programConfigurations.populatePaintArrays(arrays.layoutVertexArray.length, feature, feature.index, {});
    };

    SymbolBucket.prototype._addCollisionDebugVertex = function _addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, point, anchorX, anchorY, extrude) {
        collisionVertexArray.emplaceBack(0, 0);
        return layoutVertexArray.emplaceBack(
            // pos
            point.x,
            point.y,
            // a_anchor_pos
            anchorX,
            anchorY,
            // extrude
            Math.round(extrude.x),
            Math.round(extrude.y));
    };


    SymbolBucket.prototype.addCollisionDebugVertices = function addCollisionDebugVertices(x1, y1, x2, y2, arrays, boxAnchorPoint, symbolInstance, isCircle) {
        var segment = arrays.segments.prepareSegment(4, arrays.layoutVertexArray, arrays.indexArray);
        var index = segment.vertexLength;

        var layoutVertexArray = arrays.layoutVertexArray;
        var collisionVertexArray = arrays.collisionVertexArray;

        var anchorX = symbolInstance.anchorX;
        var anchorY = symbolInstance.anchorY;

        this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x1, y1));
        this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x2, y1));
        this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x2, y2));
        this._addCollisionDebugVertex(layoutVertexArray, collisionVertexArray, boxAnchorPoint, anchorX, anchorY, new pointGeometry(x1, y2));

        segment.vertexLength += 4;
        if (isCircle) {
            var indexArray = (arrays.indexArray);
            indexArray.emplaceBack(index, index + 1, index + 2);
            indexArray.emplaceBack(index, index + 2, index + 3);

            segment.primitiveLength += 2;
        } else {
            var indexArray$1 = (arrays.indexArray);
            indexArray$1.emplaceBack(index, index + 1);
            indexArray$1.emplaceBack(index + 1, index + 2);
            indexArray$1.emplaceBack(index + 2, index + 3);
            indexArray$1.emplaceBack(index + 3, index);

            segment.primitiveLength += 4;
        }
    };

    SymbolBucket.prototype.addDebugCollisionBoxes = function addDebugCollisionBoxes(startIndex, endIndex, symbolInstance) {
        for (var b = startIndex; b < endIndex; b++) {
            var box = (this.collisionBoxArray.get(b));
            var x1 = box.x1;
            var y1 = box.y1;
            var x2 = box.x2;
            var y2 = box.y2;

            // If the radius > 0, this collision box is actually a circle
            // The data we add to the buffers is exactly the same, but we'll render with a different shader.
            var isCircle = box.radius > 0;
            this.addCollisionDebugVertices(x1, y1, x2, y2, isCircle ? this.collisionCircle : this.collisionBox, box.anchorPoint, symbolInstance, isCircle);
        }
    };

    SymbolBucket.prototype.generateCollisionDebugBuffers = function generateCollisionDebugBuffers() {
        for (var i = 0; i < this.symbolInstances.length; i++) {
            var symbolInstance = this.symbolInstances.get(i);
            this.addDebugCollisionBoxes(symbolInstance.textBoxStartIndex, symbolInstance.textBoxEndIndex, symbolInstance);
            this.addDebugCollisionBoxes(symbolInstance.iconBoxStartIndex, symbolInstance.iconBoxEndIndex, symbolInstance);
        }
    };

    // These flat arrays are meant to be quicker to iterate over than the source
    // CollisionBoxArray
    SymbolBucket.prototype._deserializeCollisionBoxesForSymbol = function _deserializeCollisionBoxesForSymbol(collisionBoxArray, textStartIndex, textEndIndex, iconStartIndex, iconEndIndex) {
        var collisionArrays = {};
        for (var k = textStartIndex; k < textEndIndex; k++) {
            var box = (collisionBoxArray.get(k));
            if (box.radius === 0) {
                collisionArrays.textBox = {
                    x1: box.x1,
                    y1: box.y1,
                    x2: box.x2,
                    y2: box.y2,
                    anchorPointX: box.anchorPointX,
                    anchorPointY: box.anchorPointY
                };
                collisionArrays.textFeatureIndex = box.featureIndex;
                break; // Only one box allowed per instance
            } else {
                if (!collisionArrays.textCircles) {
                    collisionArrays.textCircles = [];
                    collisionArrays.textFeatureIndex = box.featureIndex;
                }
                var used = 1; // May be updated at collision detection time
                collisionArrays.textCircles.push(box.anchorPointX, box.anchorPointY, box.radius, box.signedDistanceFromAnchor, used);
            }
        }
        for (var k$1 = iconStartIndex; k$1 < iconEndIndex; k$1++) {
            // An icon can only have one box now, so this indexing is a bit vestigial...
            var box$1 = (collisionBoxArray.get(k$1));
            if (box$1.radius === 0) {
                collisionArrays.iconBox = {
                    x1: box$1.x1,
                    y1: box$1.y1,
                    x2: box$1.x2,
                    y2: box$1.y2,
                    anchorPointX: box$1.anchorPointX,
                    anchorPointY: box$1.anchorPointY
                };
                collisionArrays.iconFeatureIndex = box$1.featureIndex;
                break; // Only one box allowed per instance
            }
        }
        return collisionArrays;
    };

    SymbolBucket.prototype.deserializeCollisionBoxes = function deserializeCollisionBoxes(collisionBoxArray) {
        this.collisionArrays = [];
        for (var i = 0; i < this.symbolInstances.length; i++) {
            var symbolInstance = this.symbolInstances.get(i);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(
                collisionBoxArray,
                symbolInstance.textBoxStartIndex,
                symbolInstance.textBoxEndIndex,
                symbolInstance.iconBoxStartIndex,
                symbolInstance.iconBoxEndIndex
            ));
        }
    };

    SymbolBucket.prototype.hasTextData = function hasTextData() {
        return this.text.segments.get().length > 0;
    };

    SymbolBucket.prototype.hasIconData = function hasIconData() {
        return this.icon.segments.get().length > 0;
    };

    SymbolBucket.prototype.hasCollisionBoxData = function hasCollisionBoxData() {
        return this.collisionBox.segments.get().length > 0;
    };

    SymbolBucket.prototype.hasCollisionCircleData = function hasCollisionCircleData() {
        return this.collisionCircle.segments.get().length > 0;
    };

    SymbolBucket.prototype.addIndicesForPlacedTextSymbol = function addIndicesForPlacedTextSymbol(placedTextSymbolIndex) {
        var placedSymbol = this.text.placedSymbolArray.get(placedTextSymbolIndex);

        var endIndex = placedSymbol.vertexStartIndex + placedSymbol.numGlyphs * 4;
        for (var vertexIndex = placedSymbol.vertexStartIndex; vertexIndex < endIndex; vertexIndex += 4) {
            this.text.indexArray.emplaceBack(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            this.text.indexArray.emplaceBack(vertexIndex + 1, vertexIndex + 2, vertexIndex + 3);
        }
    };

    SymbolBucket.prototype.getSortedSymbolIndexes = function getSortedSymbolIndexes(angle) {
        if (this.sortedAngle === angle && this.symbolInstanceIndexes !== undefined) {
            return this.symbolInstanceIndexes;
        }
        var sin = Math.sin(angle);
        var cos = Math.cos(angle);
        var rotatedYs = [];
        var featureIndexes = [];
        var result = [];

        for (var i = 0; i < this.symbolInstances.length; ++i) {
            result.push(i);
            var symbolInstance = this.symbolInstances.get(i);
            rotatedYs.push(Math.round(sin * symbolInstance.anchorX + cos * symbolInstance.anchorY) | 0);
            featureIndexes.push(symbolInstance.featureIndex);
        }

        result.sort(function (aIndex, bIndex) {
            return (rotatedYs[aIndex] - rotatedYs[bIndex]) ||
                (featureIndexes[bIndex] - featureIndexes[aIndex]);
        });

        return result;
    };

    SymbolBucket.prototype.sortFeatures = function sortFeatures(angle) {
        var this$1 = this;

        if (!this.sortFeaturesByY) {
            return;
        }
        if (this.sortedAngle === angle) {
            return;
        }

        // The current approach to sorting doesn't sort across segments so don't try.
        // Sorting within segments separately seemed not to be worth the complexity.
        if (this.text.segments.get().length > 1 || this.icon.segments.get().length > 1) {
            return;
        }

        // If the symbols are allowed to overlap sort them by their vertical screen position.
        // The index array buffer is rewritten to reference the (unchanged) vertices in the
        // sorted order.

        // To avoid sorting the actual symbolInstance array we sort an array of indexes.
        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(angle);
        this.sortedAngle = angle;

        this.text.indexArray.clear();
        this.icon.indexArray.clear();

        this.featureSortOrder = [];

        for (var i$1 = 0, list = this.symbolInstanceIndexes; i$1 < list.length; i$1 += 1) {
            var i = list[i$1];

            var symbolInstance = this.symbolInstances.get(i);
            this.featureSortOrder.push(symbolInstance.featureIndex);

            [
                symbolInstance.rightJustifiedTextSymbolIndex,
                symbolInstance.centerJustifiedTextSymbolIndex,
                symbolInstance.leftJustifiedTextSymbolIndex
            ].forEach(function (index, i, array) {
                // Only add a given index the first time it shows up,
                // to avoid duplicate opacity entries when multiple justifications
                // share the same glyphs.
                if (index >= 0 && array.indexOf(index) === i) {
                    this$1.addIndicesForPlacedTextSymbol(index);
                }
            });

            if (symbolInstance.verticalPlacedTextSymbolIndex >= 0) {
                this.addIndicesForPlacedTextSymbol(symbolInstance.verticalPlacedTextSymbolIndex);
            }

            var placedIcon = this.icon.placedSymbolArray.get(i);
            if (placedIcon.numGlyphs) {
                var vertexIndex = placedIcon.vertexStartIndex;
                this.icon.indexArray.emplaceBack(vertexIndex, vertexIndex + 1, vertexIndex + 2);
                this.icon.indexArray.emplaceBack(vertexIndex + 1, vertexIndex + 2, vertexIndex + 3);
            }
        }

        if (this.text.indexBuffer) {
            this.text.indexBuffer.updateData(this.text.indexArray);
        }
        if (this.icon.indexBuffer) {
            this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
    };

    SymbolBucket.MAX_GLYPHS = 65535;
    SymbolBucket.addDynamicAttributes = addDynamicAttributes;
    dataTransfer.register('SymbolBucket', SymbolBucket, {
        omit: ['layers', 'collisionBoxArray', 'features', 'compareText']
    });
    return SymbolBucket;
});
},
'com/huayun/webgis/gl/programAttributes':function(){
define([
    "exports",
    "../utils/Constant",
    "../utils/utils"
], function (exports, Constant, utils) {
    function createLayout(members, alignment) {
        if (alignment === void 0) alignment = 1;
        var offset = 0;
        var maxSize = 0;
        var layoutMembers = members.map(function (member) {
            var typeSize = Constant.viewTypes[member.type].BYTES_PER_ELEMENT;
            var memberOffset = offset = utils.align(offset, Math.max(alignment, typeSize));
            var components = member.components || 1;
            maxSize = Math.max(maxSize, typeSize);
            offset += typeSize * components;
            return {
                name: member.name,
                type: member.type,
                components: components,
                offset: memberOffset
            };
        });
        var size = utils.align(offset, Math.max(maxSize, alignment));
        return {
            members: layoutMembers,
            size: size,
            alignment: alignment
        };
    }

    /**
     * attrs, , , typeFloat32, type,
     * @type {{size, members, alignment}}
     */
    exports.basicLine = createLayout([
        {name: "a_pos", type: "Float32", components: 3},
        {name: "a_data", type: "Float32", components: 4},
        {name: "a_normal", type: "Int16", components: 2}
    ], 4);
});
},
'com/huayun/webgis/symbols/TextSymbol':function(){
/**
 * Symbol
 * @module com/huayun/webgis/symbols
 * @see com.huayun.webgis.symbols.TextSymbol
 */
define([
    "./Symbol",
    "../utils/Color",
    "./support/glyphManager",
    "./support/CustomGlyphAtlas"
], function (BaseSymbol, Color, glyphManager, GlyphAtlas) {
    /**
     * Symbol
     * @constructor
     * @alias com.huayun.webgis.symbols.TextSymbol
     * @extends {Symbol}
     * @param {Object} params 
     * @param {String} params.color 
     * @param {Number} params.opacity 
     * @param {Number} params.size 
     * @param {String} params.text 
     * @property {String} color 
     * @property {Number} opacity 
     * @property {Number} fontSize 
     * @property {String} text 
     */
    var TextSymbol = function (params) {
        BaseSymbol.call(this, params);

        var color = Color.parse(params.color || "#FF0000"),
            opacity = params.opacity === undefined ? 1 : params.opacity,
            size = Number(params.size || params['font-size']);
        this.fontSize = size;//size < 12 ? 12 : size;
        var isRotate = params.isRotate === undefined ? false : params.isRotate;
        var rotateRadian = params.rotateRadian === undefined ? 0 : params.rotateRadian;

        var offset = params.offset || [Number(params.dx), Number(params.dy)];
        this.offset = offset.map(function (item) {
            return item / size;
        });

        this.hasHalo = params["stroke"] || !!params.halo;
        var haloBlur, haloColor, haloWidth;

        if (this.hasHalo) {
            if (params.halo) {
                haloBlur = params.halo.blur || 0;
                haloColor = Color.parse(params.halo.color || "#FF0000");
                haloWidth = params.halo.width || Number(params["stroke-width"]);
            } else {
                haloBlur = 0;
                haloColor = Color.parse(params.stroke || "#FF0000");
                haloWidth = Number(params["stroke-width"]);
            }
        } else {
            haloBlur = 0;
            haloColor = Color.parse("#FFF");
            haloWidth = 0;
        }
        this.type = "text";
        this.uniforms = {
            "u_size": this.fontSize,
            "u_pitch_with_map": 0,
            "u_opacity": opacity,
            "u_texture": 0,
            "u_fill_color": [color.r, color.g, color.b, color.a],
            "u_gamma_scale": 1,
            "u_rotate_symbol": isRotate,
            "u_radian": rotateRadian,
            "u_halo_color": [haloColor.r, haloColor.g, haloColor.b, haloColor.a],
            "u_halo_width": haloWidth,
            "u_halo_blur": haloBlur,
            "u_is_halo": this.hasHalo ? 1 : 0
        };

        var text = params.text;
        var font = params.font || params["font-family"] || "sans-serif";
        this.font = font;
        if (text) {
            this.text = text;

            var stacks = {};
            stacks[font] = [];
            for (var i = 0, len = text.length; i < len; i++) {
                stacks[font].push(text.charCodeAt(i));
            }
            this.glyphMap = glyphManager.getGlyphs(stacks);
            this.glyphAtlas = new GlyphAtlas(this.glyphMap);

            var image = this.glyphAtlas.image;
            this.width = image.width;
            this.height = image.height;
            this.textWidth = this.glyphAtlas.textWidth;
        }
    };

    if (BaseSymbol) TextSymbol.__proto__ = BaseSymbol;
    TextSymbol.prototype = Object.create(BaseSymbol && BaseSymbol.prototype);
    TextSymbol.prototype.constructor = TextSymbol;

    TextSymbol.prototype.setText = function (text, font) {
        if (text === undefined || text.length === 0) return;
        // text = 'aaaa' +  '\n' + 'bbbb';
        this.text = text;
        if (!font) {
            font = this.font;
        }
        var stacks = {};
        stacks[font] = [];
        for (var i = 0, len = text.length; i < len; i++) {
            stacks[font].push(text.charCodeAt(i));
        }
        this.glyphMap = glyphManager.getGlyphs(stacks);
        this.glyphAtlas = new GlyphAtlas(this.glyphMap);
        var image = this.glyphAtlas.image;
        this.width = image.width;
        this.height = image.height;
        this.textWidth = 24 * text.length;
    };

    TextSymbol.prototype.setOffset = function (offset) {
        var size = this.uniforms.u_size;
        this.offset = offset.map(function (item) {
            return item / size;
        });
    };

    return TextSymbol;
});

},
'com/huayun/webgis/layers/support/EvaluationParameters':function(){
define([
  "./ZoomHistory"
], function (ZoomHistory) {
  var EvaluationParameters = function EvaluationParameters(zoom, options) {
    this.zoom = zoom;
    if (options) {
      this.now = options.now;
      this.fadeDuration = options.fadeDuration;
      this.zoomHistory = options.zoomHistory;
      this.transition = options.transition;
    } else {
      this.now = 0;
      this.fadeDuration = 0;
      this.zoomHistory = new ZoomHistory();
      this.transition = {};
    }
  };

  EvaluationParameters.prototype.crossFadingFactor = function () {
    if (this.fadeDuration === 0) {
      return 1;
    } else {
      return Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
    }
  };

  EvaluationParameters.prototype.getCrossfadeParameters = function () {
    var z = this.zoom;
    var fraction = z - Math.floor(z);
    var t = this.crossFadingFactor();

    return z > this.zoomHistory.lastIntegerZoom ?
      {fromScale: 2, toScale: 1, t: fraction + (1 - fraction) * t} :
      {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};
  };

  return EvaluationParameters;
});
},
'com/huayun/webgis/layers/support/expression/Var':function(){
define([], function () {
    /**
     * var
     * @private
     * @ignore
     * @param name
     * @param boundExpression
     * @constructor
     */
    var Var = function Var(name, boundExpression) {
        this.type = boundExpression.type;
        this.name = name;
        this.boundExpression = boundExpression;
    };

    Var.parse = function (args, context) {
        if (args.length !== 2 || typeof args[1] !== 'string') {
            return context.error("'var' expression requires exactly one string literal argument.");
        }

        var name = args[1];
        if (!context.scope.has(name)) {
            return context.error(("Unknown variable \"" + name + "\". Make sure \"" + name + "\" has been bound in an enclosing \"let\" expression before using it."), 1);
        }

        return new Var(name, context.scope.get(name));
    };

    Var.prototype.evaluate = function (ctx) {
        return this.boundExpression.evaluate(ctx);
    };

    Var.prototype.eachChild = function () {
    };

    Var.prototype.possibleOutputs = function () {
        return [undefined];
    };

    Var.prototype.serialize = function () {
        return ["var", this.name];
    };
    return Var;
});
},
'com/huayun/webgis/layers/GraphicLayer':function(){
/**
 * 
 * @see com.huayun.webgis.layers.GraphicLayer
 */
define([
    "dojo/_base/declare",
    "./Layer",
    "../views/3d/layers/GraphicLayerView3D",
    "../data/GraphicIndex",
    "com/huayun/webgis/symbols/PointSymbol",
    "com/huayun/webgis/symbols/CircleSymbol",
    "com/huayun/webgis/symbols/PolygonSymbol",
    "com/huayun/webgis/symbols/LineSymbol",
    "../renderer/SimpleRenderer"
], function (declare, Layer, LayerView, GraphicIndex, PointSymbol, CircleSymbol, PolygonSymbol, LineSymbol, SimpleRenderer) {
    /**
     * 
     * @constructor
     * @alias com.huayun.webgis.layers.GraphicLayer
     * @extends {Layer}
     * @param {Object} params 
     * @param {string}  params.id  - id
     * @param {number}  params.maxLevel  - 
     * @param {number}  params.minLevel  - 
     * @property {string}  type  - 
     * @property {Array}  graphics  - 
     * @property {string}  id  - id
     * @property {number}  maxLevel  - 
     * @property {number}  minLevel  - 
     */
    return declare("com.huayun.webgis.layers.GraphicLayer", [Layer], {

        constructor: function (params) {
            params = params || {};
            this.type = "graphic";
            this.graphics = [];
            this.id = "graphic";
            this.maxLevel = params.maxLevel;
            this.minLevel = params.minLevel;
            this.opacity = 1;
            declare.safeMixin(this, params);
            this.graphicIndex = new GraphicIndex();
            this.queryPadding = 20;
            this.indexNeedUpdate = true;
            this.selectEnabled = true;
            this.highlightGraphics = [];
            this.renderer = params && params.renderer || new SimpleRenderer();
            if (params) {
                this.glowRatio = params.glowRatio === undefined ? 8 : params.glowRatio;
                if (params.graphics) {
                    params.graphics.forEach(function (item) {
                        this.addGraphic(item);
                    }.bind(this));
                }
            }
        },
        /**
         * 
         * @param {Renderer} renderer 
         */
        setRenderer: function (renderer) {
            this.renderer = renderer;
            // debugger
            if (this.layerView) {
                this.layerView.renderer = renderer;
            }
        },

        createLayerView: function (view, option) {
            var layerView = new LayerView({
                opacity: this.opacity,
                visible: this.visible,
                view: view,
                id: this.id,
                layer: this,
                glow: this.glow,
                renderer: this.renderer
            });
            this.layerView = layerView;
            layerView.transform = view.viewpoint;

            // Graphic
            this.graphics.forEach(function (item) {
                this.layerView.addGraphic(item);
            }.bind(this));
            return layerView;
        },
        /**
         * 
         * @param {Graphic} graphic 
         */
        addGraphic: function (graphic, position) {
            if (position) {
                switch (position) {
                    case "first":
                        this.graphics.splice(0, 0, graphic);
                        break;
                    case "end":
                        this.graphics.push(graphic);
                        break;
                }
            } else {
                this.graphics.push(graphic);
            }
            graphic.layer = this;
            if (this.layerView) {
                this.layerView.addGraphic(graphic);
            }
            this.indexNeedUpdate = true;
        },

        updateGraphic: function (graphic) {
            this.layerView.addGraphic(graphic);
        },

        addGraphicBefore: function (graphic, id) {
            graphic.layer = this;
            var ii = this.graphics.length;
            var flag = false;
            for (var i = 0; i < ii; i++) {
                if (id === this.graphics[i].id) {
                    this.graphics.splice(i, 0, graphic);
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                this.graphics.push(graphic);
            }
            if (this.layerView) {
                this.layerView.addGraphic(graphic);
            }
            this.indexNeedUpdate = true;
        },
        /**
         * 
         * @param {Graphic} graphic 
         */
        removeGraphic: function (graphic) {
            if (!graphic) return;
            var ii = this.graphics.length;
            for (var i = 0; i < ii; i++) {
                if (graphic.id === this.graphics[i].id) {
                    // graphic.bucket.destroy();
                    graphic.buckets.forEach(function (item) {
                        item.destroy();
                    });
                    graphic.buckets = [];
                    this.graphics.splice(i, 1);
                    break;
                }
            }
            this.layerView.view.threeRender();
        },
        addMultiPoint: function (graphic) {
            this.graphics.push(graphic);
            this.layerView.addMultiPoint(graphic);
        },
        /**
         * 
         * @param {Array} list  
         */
        removeGraphics: function (list) {
            for (var i = 0; i < list.length; i++) {
                this.removeGraphic(list[i]);
            }
        },
        /**
         * 
         * @param {boolean} visible  - 
         */
        setVisible: function (visible) {
            this.visible = visible;
            this.layerView.setVisible(visible);
        },
        /**
         * 
         */
        refresh: function () {
            // this.layerViews.forEach(function (item) {
            //     item.refresh();
            // });
            // this.layerView.clear();
            this.layerView.view.threeRender();
        },

        /**
         * 
         */
        clear: function () {
            /*this.layerViews.forEach(function (item) {
                item.clear();
            });*/
            // debugger
            this.graphics.forEach(function (item) {
                if (item.bucket) {
                    item.bucket.destroy();
                }
            });
            this.graphics = [];
            this.layerView.view.threeRender();
        },

        queryFeaturesByGeometry: function (geometry, queryPadding) {
            if (this.indexNeedUpdate) {
                this.graphicIndex.clear();
                this.graphics.forEach(function (item) {
                    if (item.selectEnabled) {
                        var geometry;
                        switch (item.feature.geometry.type) {
                            case "point":
                                geometry = [[item.feature.geometry]];
                                break;
                            case "circle":
                                geometry = [[item.feature.geometry.center]];
                                break;
                            case "multipoint":
                                geometry = [item.feature.geometry.points];
                                break;
                            case "line":
                            case "polygon":
                                geometry = item.feature.geometry.path;
                                break;
                            default:
                                geometry = [[]];
                            /*case "point":
                                geometry = [[item.feature.geometry]];
                                break;
                            case "circle":
                                geometry = [[item.feature.geometry.center]];
                                break;
                            case "text":
                                return;
                            case "image":
                                geometry = [[item.feature.geometry]];
                                break;
                            default:
                                */
                        }
                        this.graphicIndex.insert(geometry, item.id);
                    }
                }.bind(this));
                this.indexNeedUpdate = false;
            }
            queryPadding = queryPadding || this.queryPadding;
            switch (geometry.type) {
                case "point":
                    geometry = [geometry];
                    break;
            }
            return this.graphicIndex.query(geometry, queryPadding, this.graphics, this.layerView.view.resolution, this.layerView.view.viewpoint);
        },
        captureFeaturesByGeometry: function (geometry, queryPadding) {
            if (this.indexNeedUpdate) {
                this.graphicIndex.clear();
                this.graphics.forEach(function (item) {
                    if (item.selectEnabled) {
                        var geometry;
                        switch (item.symbol.type) {
                            case "point":
                                geometry = [[item.feature.geometry]];
                                break;
                            case "circle":
                                geometry = [[item.feature.geometry.center]];
                                break;
                            case "text":
                                return;
                            case "image":
                                geometry = [[item.feature.geometry]];
                                break;
                            default:
                                geometry = item.feature.geometry.path;
                        }
                        this.graphicIndex.insert(geometry, item.id);
                    }
                }.bind(this));
                this.indexNeedUpdate = false;
            }
            queryPadding = queryPadding || this.queryPadding;
            switch (geometry.type) {
                case "point":
                    geometry = [geometry];
                    break;
            }
            return this.graphicIndex.captureQuery(geometry, queryPadding, this.graphics, this.layerView.view.resolution, this.layerView.view.viewpoint);
        },

        queryRenderFeaturesByGeometry: function (geometry, queryPadding) {
            if (this.indexNeedUpdate) {
                this.graphicIndex.clear();
                this.graphics.forEach(function (item) {
                    if (item.selectEnabled) {
                        var geometry;
                        switch (item.symbol.type) {
                            case "point":
                                geometry = [[item.feature.geometry]];
                                break;
                            case "circle":
                                geometry = [[item.feature.geometry.center]];
                                break;
                            case "text":
                                return;
                            case "image":
                                geometry = [[item.feature.geometry]];
                                break;
                            default:
                                geometry = item.feature.geometry.path;
                        }
                        this.graphicIndex.insert(geometry, item.id);
                    }
                }.bind(this));
                this.indexNeedUpdate = false;
            }
            queryPadding = queryPadding || this.queryPadding;
            switch (geometry.type) {
                case "point":
                    geometry = [geometry];
                    break;
            }
            return this.graphicIndex.queryRender(geometry, queryPadding, this.graphics, this.layerView.view.resolution, this.layerView.view.viewpoint);
        },
        highlightGraphic: function (graphics) {
            if (!this.highlightSymbol) {
                this.highlightSymbol = {
                    point: new PointSymbol({
                        color: "#FFFF00",
                        radius: 16
                    }),
                    line: new LineSymbol({
                        color: "#BF2BFF",
                        width: 4,
                        join: "round",
                        cap: "round"
                    }),
                    polygon: new PolygonSymbol({
                        color: "#FF4B37"
                    })
                };
            }
            var needRender = false;
            this.highlightGraphics.forEach(function (item) {
                delete item.highLightSymbol;
                needRender = true;
            }.bind(this));
            this.highlightGraphics = [];
            graphics.forEach(function (item) {
                item.highLightSymbol = this.highlightSymbol[item.symbol.type];
                needRender = true;
            }.bind(this));
            this.highlightGraphics = graphics;
            if (needRender) {
                this.layerView.view.threeRender();
            }
        }
    });
});

},
'com/huayun/webgis/layers/support/tileCover':function(){
define([
    "./OverscaledTileID"
], function (OverscaledTileID) {
    function edge(a, b) {
        if (a.y > b.y) {
            var t = a;
            a = b;
            b = t;
        }
        return {
            x0: a.x,
            y0: a.y,
            x1: b.x,
            y1: b.y,
            dx: b.x - a.x,
            dy: b.y - a.y
        }
    }

    function scanSpans(e0, e1, ymin, ymax, scanLine) {
        var y0 = Math.max(ymin, Math.floor(e1.y0));
        var y1 = Math.min(ymax, Math.ceil(e1.y1));

        if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy/e0.dy*e0.dx < e1.x1) :
            (e0.x1 - e1.dy/e0.dy*e0.dx < e1.x0)) {
            var t = e0;
            e0 = e1;
            e1 = t;
        }

        var m0 = e0.dx/e0.dy;
        var m1 = e1.dx/e1.dy;
        var d0 = e0.dx > 0;
        var d1 = e1.dx < 0;
        for (var y = y0 - 1; y < y1 + 1; y++) {
            var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
            var x1 = m1 * Math.max(0, Math.min(e1.dy, y+d1-e1.y0)) + e1.x0;
            scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
    }

    function scanTriangle(a, b, c, ymin, ymax, scanLine) {
        var ab = edge(a, b),
            bc = edge(b, c),
            ca = edge(c, a);
        var t;
        if (ab.dy > bc.dy) {
            t = ab;
            ab = bc;
            bc = t;
        }
        if (ab.dy > ca.dy) {
            t = ab;
            ab = ca;
            ca = t;
        }
        if (bc.dy > ca.dy) {
            t = bc;
            bc = ca;
            ca = t;
        }

        if (ab.dy) {
            scanSpans(ca, ab, ymin, ymax, scanLine);
        }
        if (bc.dy) {
            scanSpans(ca, bc, ymin, ymax, scanLine);
        }
    }

    function tileCover(z, bounds, tileRange) {
        var t = {};
        function scanLine(x0, x1, y) {
            var x, w, coord;
            /*if (y >= tileRange[0] && y <= tileRange[1]) {
                for (x = x0 - 1; x < x1 + 1; x++) {
                    w = Math.floor(x);
                    coord = new OverscaledTileID(z, 0, z, w, y);
                    t[z+"/"+w+"/"+y] = coord;
                }
            }*/
            for (x = x0 - 1; x < x1 + 1; x++) {
                w = Math.floor(x);
                coord = new OverscaledTileID(z, 0, z, w, y);
                t[z+"/"+w+"/"+y] = coord;
            }
        }
        scanTriangle(bounds[0], bounds[1], bounds[2], 0, Infinity, scanLine);
        scanTriangle(bounds[2], bounds[3], bounds[0], 0, Infinity, scanLine);
        return Object.keys(t).map(function (id) {
            return t[id];
        });
    }

    return tileCover;
});
},
'com/huayun/webgis/views/layers/LayerView':function(){
/**
 * 
 * @see com.huayun.webgis.views.layers.LayerView
 */
define([], function () {
    /**
     * , 
     * * @constructor
     * @alias com.huayun.webgis.views.layers.LayerView
     * @param {Object} props 
     * @param {String} props.id id
     * @param {Layer} props.layer 
     * @param {View} props.view 
     */
    function LayerView(props) {
        this.id = props && props.id ? props.id : "layerView";
        this.layer = props.layer;
        this.view = props.view;
    }

    /**
     * 
     */
    LayerView.prototype.refresh = function () {}

    return LayerView;
});
},
'com/huayun/webgis/renderer/ImageRenderer':function(){
define([
    "custom/gl-matrix-min",
    "./Renderer",
    "../data/bucket/ImageBucketSimplify",
    "../geometry/Point",
    "../gl/mode",
    "../gl/Texture",
    "../gl/programCache"
], function (glMatrix, Renderer, ImageBucket, Point, mode, Texture, programCache) {

    function getLabelPlaneMatrix(posMatrix, pitchWithMap, rotateWithMap, labelPlaneMatrix, pixelsToTileUnits) {
        var m = glMatrix.mat4.create();
        if (pitchWithMap) {
            glMatrix.mat4.scale(m, m, [1 / pixelsToTileUnits, 1 / pixelsToTileUnits, 1]);
            if (!rotateWithMap) {
                glMatrix.mat4.rotateZ(m, m, transform.angle);
            }
        } else {
            glMatrix.mat4.multiply(m, labelPlaneMatrix, posMatrix);
        }
        return m;
    }

    function getGlCoordMatrix(posMatrix, pitchWithMap, rotateWithMap, glCoordMatrix, pixelsToTileUnits) {
        if (pitchWithMap) {
            var m = __chunk_1.clone(posMatrix);
            __chunk_1.scale(m, m, [pixelsToTileUnits, pixelsToTileUnits, 1]);
            if (!rotateWithMap) {
                __chunk_1.rotateZ(m, m, -transform.angle);
            }
            return m;
        } else {
            return glCoordMatrix;
        }
    }

    function ImageRenderer() {}

    if (Renderer) ImageRenderer.__proto__ = Renderer;
    ImageRenderer.prototype = Object.create(Renderer && Renderer.prototype);
    ImageRenderer.prototype.constructor = ImageRenderer;

    ImageRenderer.prototype.add = function (view, graphic, geometry, symbol) {
        debugger;
        var bucket = new ImageBucket();
        var center = graphic.position || view.viewpoint.center || [0, 0],
            cx = center[0],
            cy = center[1];
        if (geometry.type === "multipoint") {
            var p = [];
            for (var i = 0; i < geometry.points.length; i++) {
                p.push(new Point(geometry.points[i].x - cx, geometry.points[i].y - cy, 0));
            }
            bucket.addFeature([p], symbol.width, symbol.height, symbol.offset);
        } else if (geometry.type === "point") {
            bucket.addFeature([[new Point(geometry.x - cx, geometry.y - cy, 0)]], symbol.width, symbol.height, symbol.offset); // 
        }
        bucket.upload(view.context); // Buffer, WebGL
        graphic.buckets.push(bucket);
        graphic.position = [cx, cy];
    };


    ImageRenderer.prototype.draw = function (view, graphic, geometry, symbol, layerView, index) {
        if (!symbol.loaded) {
            symbol.used = true;
            return;
        }
        if (index === undefined) index = 0;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadOnly);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadOnly, [0.9, 0.9]);
        }
        var stencilMode = mode.StencilMode.disabled;
        var colorMode = mode.ColorMode.alphaBlended;
        var program = programCache.useProgramSimplify(context, 'images', {
            layoutAttributes: [
                {name: "a_pos", type: "Float32", components: 2, offset: 0},
                {name: "a_data", type: "Int16", components: 4, offset: 8}
            ]
        });

        var uniform = symbol.uniforms;
        var position = graphic.position;
        var realScale = this.getRealScale(symbol.fixed, view.scale, symbol.minScale);
        var tempW = undefined;
        var resolution = view.resolution;
        // debugger;
        if (symbol.markerSize) {    // 
            realScale = realScale * (graphic.markerScaleFactor || 1);
            tempW = symbol.markerSize / symbol.radius;
            realScale = realScale * tempW;
        } else if (graphic.symbol.size && graphic.symbol.tempW === undefined) {   //
            graphic.scaleFactor = graphic.scaleFactor || 1;
            realScale = realScale * graphic.scaleFactor;
            tempW = graphic.symbol.size / symbol.radius;
            graphic.symbol.tempW = tempW;
            realScale = realScale * tempW;
        } else if (graphic.symbol.size && graphic.symbol.tempW !== undefined) {
            realScale = realScale * graphic.symbol.tempW;
        } else {
            graphic.scaleFactor = graphic.scaleFactor || 1;
            realScale = realScale * graphic.scaleFactor;
        }

        if (graphic.rotation) {
            uniform.u_radian = symbol.angle + graphic.rotation;
        } else {
            uniform.u_radian = symbol.angle
        }

        var dx = symbol.dx * realScale * resolution,
            dy = symbol.dy * realScale * resolution;
        var sina = Math.sin(uniform.u_radian),
            cosa = Math.cos(uniform.u_radian);
        var offsetx = dx * cosa - dy * sina,
            offsety = dy * cosa + dx * sina;
        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0] + offsetx, position[1] + offsety);

        var texsize = [symbol.width, symbol.height];
        uniform.u_camera_to_center_distance = view.viewpoint.cameraToCenterDistance;
        uniform.u_label_plane_matrix = getLabelPlaneMatrix(uniform["u_matrix"], false, false, view.viewpoint.labelPlaneMatrix, 1);
        uniform.u_coord_matrix = getGlCoordMatrix(uniform["u_matrix"], false, false, view.viewpoint.glCoordMatrix, 1);
        uniform.u_texsize = texsize;

        context.activeTexture.set(gl.TEXTURE0);
        var texture = symbol.texture;
        if (!texture) {
            texture = symbol.texture = new Texture(context, symbol.image, gl.RGBA, {useMipmap: true});
        }
        texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
        graphic["_imageOffset" + index] = {
            dx: offsetx,
            dy: offsety,
            size: texsize
        };

        var buckets = graphic.buckets;
        var bucket = buckets[index];
        program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, mode.CullFaceMode.disabled,
            uniform, graphic.id + "-image" + index,
            bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,
            null);
    };

    ImageRenderer.prototype.drawGlow = function (view, graphic, geometry, symbol, layerView, index, sizeRight) {
        this.draw(view, graphic, geometry, symbol, layerView, index, sizeRight)
    };

    ImageRenderer.prototype.calculateExtent = function (view, graphic, geometry, symbol, result, index) {
        if (!index) index = 0;
        if (!symbol.loaded) {
            return;
        }
        var resolution = view.resolution;
        var dxdy = graphic["_imageOffset" + index];
        var size = dxdy.size;
        var x = geometry.x,
            y = geometry.y;
        // 

        var dx = dxdy.dx,
            dy = dxdy.dy;
        x = x + dx;
        y = y + dy;

        result.push({
            id: graphic.id,
            g: graphic,
            minX: x - size[0] * resolution / 2,
            minY: y - size[1] * resolution / 2,
            maxX: x + size[0] * resolution / 2,
            maxY: y + size[1] * resolution / 2
        });
    };

    return ImageRenderer;
})
},
'com/huayun/webgis/gl/potpack':function(){
define([], function () {
    return function (boxes) {
        var area = 0;
        var maxWidth = 0;

        for (var i$1 = 0, list = boxes; i$1 < list.length; i$1 += 1) {
            var box = list[i$1];
            area += box.w * box.h;
            maxWidth = Math.max(maxWidth, box.w);
        }

        boxes.sort(function (a, b) {
            return b.h - a.h;
        });

        var startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
        var spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];

        var width = 0;
        var height = 0;

        for (var i$2 = 0, list$1 = boxes; i$2 < list$1.length; i$2 += 1) {
            var box$1 = list$1[i$2];
            for (var i = spaces.length - 1; i >= 0; i--) {
                var space = spaces[i];
                if (box$1.w > space.w || box$1.h > space.h) {
                    continue;
                }
                // found the space; add the box to its top-left corner
                // |-------|-------|
                // |  box  |       |
                // |_______|       |
                // |         space |
                // |_______________|
                box$1.x = space.x;
                box$1.y = space.y;
                height = Math.max(height, box$1.y + box$1.h);
                width = Math.max(width, box$1.x + box$1.w);

                if (box$1.w === space.w && box$1.h === space.h) {
                    var last = spaces.pop();
                    if (i < spaces.length) {
                        spaces[i] = last;
                    }
                } else if (box$1.h === space.h) {
                    // space matches the box height; update it accordingly
                    // |-------|---------------|
                    // |  box  | updated space |
                    // |_______|_______________|
                    space.x += box$1.w;
                    space.w -= box$1.w;
                } else if (box$1.w === space.w) {
                    // space matches the box width; update it accordingly
                    // |---------------|
                    // |      box      |
                    // |_______________|
                    // | updated space |
                    // |_______________|
                    space.y += box$1.h;
                    space.h -= box$1.h;
                } else {
                    // otherwise the box splits the space into two spaces
                    // |-------|-----------|
                    // |  box  | new space |
                    // |_______|___________|
                    // | updated space     |
                    // |___________________|
                    spaces.push({
                        x: space.x + box$1.w,
                        y: space.y,
                        w: space.w - box$1.w,
                        h: box$1.h
                    });
                    space.y += box$1.h;
                    space.h -= box$1.h;
                }
                break;
            }
        }

        return {
            w: width, // container width
            h: height, // container height
            fill: (area / (width * height)) || 0 // space utilization
        };
    }
});
},
'com/huayun/webgis/utils/colorSpaces':function(){
/**
 * , labhcl
 */
define([
    "./utils",
    "./Color"
], function (utils, Color) {

    var Xn = 0.950470, // D65 standard referent
        Yn = 1,
        Zn = 1.088830,
        t0 = 4 / 29,
        t1 = 6 / 29,
        t2 = 3 * t1 * t1,
        t3 = t1 * t1 * t1,
        deg2rad = Math.PI / 180,
        rad2deg = 180 / Math.PI;

    function xyz2lab(t) {
        return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function xyz2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2xyz(x) {
        x /= 255;
        return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    /**
     * RGBLab, , XYZ
     * @private
     * @ignore
     * @param rgbColor
     * @return {{a: number, b: number, alpha: *, l: number}}
     */
    function rgbToLab(rgbColor) {
        var b = rgb2xyz(rgbColor.r),
            a = rgb2xyz(rgbColor.g),
            l = rgb2xyz(rgbColor.b),
            x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
            y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
            z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);

        return {
            l: 116 * y - 16,
            a: 500 * (x - y),
            b: 200 * (y - z),
            alpha: rgbColor.a
        };
    }

    /**
     * labrgb
     * @private
     * @ignore
     * @param labColor
     * @return {*}
     */
    function labToRgb(labColor) {
        var y = (labColor.l + 16) / 116,
            x = isNaN(labColor.a) ? y : y + labColor.a / 500,
            z = isNaN(labColor.b) ? y : y - labColor.b / 200;
        y = Yn * lab2xyz(y);
        x = Xn * lab2xyz(x);
        z = Zn * lab2xyz(z);
        return new Color(
            xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
            xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
            xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
            labColor.alpha
        );
    }

    /**
     * lab
     * @private
     * @ignore
     * @param from
     * @param to
     * @param t
     * @return {{a: number, b: number, alpha: number, l: number}}
     */
    function interpolateLab(from, to, t) {
        return {
            l: utils.number(from.l, to.l, t),
            a: utils.number(from.a, to.a, t),
            b: utils.number(from.b, to.b, t),
            alpha: utils.number(from.alpha, to.alpha, t)
        };
    }

    /**
     * rgbhcl
     * @private
     * @ignore
     * @param rgbColor
     * @return {{c: number, alpha: *, h: number, l: number}}
     */
    function rgbToHcl(rgbColor) {
        var ref = rgbToLab(rgbColor);
        var l = ref.l;
        var a = ref.a;
        var b = ref.b;
        var h = Math.atan2(b, a) * rad2deg;
        return {
            h: h < 0 ? h + 360 : h,
            c: Math.sqrt(a * a + b * b),
            l: l,
            alpha: rgbColor.a
        };
    }

    /**
     * hclrgb
     * @private
     * @ignore
     * @param hclColor
     * @return {*}
     */
    function hclToRgb(hclColor) {
        var h = hclColor.h * deg2rad,
            c = hclColor.c,
            l = hclColor.l;
        return labToRgb({
            l: l,
            a: Math.cos(h) * c,
            b: Math.sin(h) * c,
            alpha: hclColor.alpha
        });
    }

    function interpolateHue(a, b, t) {
        var d = b - a;
        return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
    }

    /**
     * Hcl
     * @private
     * @ignore
     * @param from
     * @param to
     * @param t
     * @return {{c: number, alpha: number, h: *, l: number}}
     */
    function interpolateHcl(from, to, t) {
        return {
            h: interpolateHue(from.h, to.h, t),
            c: utils.number(from.c, to.c, t),
            l: utils.number(from.l, to.l, t),
            alpha: utils.number(from.alpha, to.alpha, t)
        };
    }

    var lab = {
        forward: rgbToLab,
        reverse: labToRgb,
        interpolate: interpolateLab
    };

    var hcl = {
        forward: rgbToHcl,
        reverse: hclToRgb,
        interpolate: interpolateHcl
    };

    return Object.freeze({
        lab: lab,
        hcl: hcl
    });
});
},
'com/huayun/webgis/symbols/BaseSymbol':function(){
define([], function () {
    function BaseSymbol(params) {
        this.minScale = 0;
        this.maxScale = 0;
        this.fixedSize = params.fixedSize || params.isFixed || true;
        this.fixed = {
            isFixed: this.fixedSize,
            addratio: 0
        }
    }

    return BaseSymbol;
});

},
'com/huayun/webgis/facade/TileFacade':function(){
define(["exports", "../utils/Resource"], function (exports, Resource) {
    exports.getTileInfoData = function (url, callback) {
        var token = dojoConfig.token;
        var headers = token ? {
            headers: {"access-key": token}
        } : undefined;
        Resource.loadJson(url, headers, callback)
    }

    exports.loadTile = function (url, callback) {
        var token = dojoConfig.token;
        var options = token ? {
            headers: {"access-key": token}
        } : undefined;
        return Resource.loadImage(url, options, callback);
    }
})
},
'com/huayun/webgis/gl/programConfig':function(){
define([
    "exports",
    "../data/FeaturePositionMap",
    "../layers/support/style/PossiblyEvaluatedPropertyValue",
    "./constantBinder",
    "./dataTransfer",
    "../utils/utils"
], function (exports, FeaturePositionMap, PossiblyEvaluatedPropertyValue, constantBinder, dataTransfer, utils) {
    var ProgramConfiguration = function ProgramConfiguration() {
        this.binders = {};
        this.cacheKey = '';
        this._buffers = [];
        this._featureMap = new FeaturePositionMap();
        this._bufferOffset = 0;
    };

    ProgramConfiguration.createDynamic = function createDynamic(layer, zoom, filterProperties) {
        var self = new ProgramConfiguration();
        var keys = [];

        for (var property in layer.paint._values) {
            if (!filterProperties(property)) {
                continue;
            }
            var value = layer.paint.get(property);
            if (!(value instanceof PossiblyEvaluatedPropertyValue) || !utils.supportsPropertyExpression(value.property.specification)) {
                continue;
            }
            var names = utils.paintAttributeNames(property, layer.type);
            var type = value.property.specification.type;
            var useIntegerZoom = value.property.useIntegerZoom;
            var isCrossFaded = value.property.specification['property-type'] === 'cross-faded' ||
                value.property.specification['property-type'] === 'cross-faded-data-driven';

            if (isCrossFaded) {
                if (value.value.kind === 'constant') {
                    self.binders[property] = new constantBinder.CrossFadedConstantBinder(value.value.value, names, type);
                    keys.push(("/u_" + property));
                } else {
                    var StructArrayLayout = utils.layoutType(property, type, 'source');
                    self.binders[property] = new constantBinder.CrossFadedCompositeBinder(value.value, names, type, useIntegerZoom, zoom, StructArrayLayout, layer.id);
                    keys.push(("/a_" + property));
                }
            } else if (value.value.kind === 'constant') {
                self.binders[property] = new constantBinder.ConstantBinder(value.value.value, names, type);
                keys.push(("/u_" + property));
            } else if (value.value.kind === 'source') {
                var StructArrayLayout$1 = utils.layoutType(property, type, 'source');
                self.binders[property] = new constantBinder.SourceExpressionBinder(value.value, names, type, StructArrayLayout$1);
                keys.push(("/a_" + property));
            } else {
                var StructArrayLayout$2 = utils.layoutType(property, type, 'composite');
                self.binders[property] = new constantBinder.CompositeExpressionBinder(value.value, names, type, useIntegerZoom, zoom, StructArrayLayout$2);
                keys.push(("/z_" + property));
            }
        }
        self.cacheKey = keys.sort().join('');
        return self;
    };

    ProgramConfiguration.prototype.populatePaintArrays = function populatePaintArrays(newLength, feature, index, imagePositions) {
        for (var property in this.binders) {
            var binder = this.binders[property];
            binder.populatePaintArray(newLength, feature, imagePositions);
        }
        if (feature.id !== undefined) {
            this._featureMap.add(+feature.id, index, this._bufferOffset, newLength);
        }
        this._bufferOffset = newLength;
    };
    ProgramConfiguration.prototype.setConstantPatternPositions = function setConstantPatternPositions(posTo, posFrom) {
        for (var property in this.binders) {
            var binder = this.binders[property];
            binder.setConstantPatternPositions(posTo, posFrom);
        }
    };

    ProgramConfiguration.prototype.updatePaintArrays = function updatePaintArrays(featureStates, vtLayer, layer, imagePositions) {
        var dirty = false;
        for (var id in featureStates) {
            var positions = this._featureMap.getPositions(+id);
            for (var i = 0, list = positions; i < list.length; i += 1) {
                var pos = list[i];
                var feature = vtLayer.feature(pos.index);
                for (var property in this.binders) {
                    var binder = this.binders[property];
                    if (binder instanceof constantBinder.ConstantBinder || binder instanceof constantBinder.CrossFadedConstantBinder) {
                        continue;
                    }
                    if ((binder).expression.isStateDependent === true) {
                        var value = layer.paint.get(property);
                        (binder).expression = value.value;
                        binder.updatePaintArray(pos.start, pos.end, feature, featureStates[id], imagePositions);
                        dirty = true;
                    }
                }
            }
        }
        return dirty;
    };

    ProgramConfiguration.prototype.defines = function defines() {
        var result = [];
        for (var property in this.binders) {
            result.push.apply(result, this.binders[property].defines());
        }
        return result;
    };

    ProgramConfiguration.prototype.getPaintVertexBuffers = function getPaintVertexBuffers() {
        return this._buffers;
    };

    ProgramConfiguration.prototype.getUniforms = function getUniforms(context, locations) {
        var uniforms = [];
        for (var property in this.binders) {
            var binder = this.binders[property];
            for (var i = 0, list = binder.uniformNames; i < list.length; i += 1) {
                var name = list[i];
                if (locations[name]) {
                    var binding = binder.getBinding(context, locations[name]);
                    uniforms.push({name: name, property: property, binding: binding});
                }
            }
        }
        return uniforms;
    };

    ProgramConfiguration.prototype.setUniforms = function setUniforms(context, binderUniforms, properties, globals) {
        for (var i = 0, list = binderUniforms; i < list.length; i += 1) {
            var ref = list[i];
            var name = ref.name;
            var property = ref.property;
            var binding = ref.binding;
            this.binders[property].setUniforms(context, binding, globals, properties.get(property), name);
        }
    };

    ProgramConfiguration.prototype.setUniform = function setUniforms(context, property, binding, value) {
        this.binders[property].setUniform(context, binding, value);
    };

    ProgramConfiguration.prototype.updatePatternPaintBuffers = function updatePatternPaintBuffers(crossfade) {
        var buffers = [];
        for (var property in this.binders) {
            var binder = this.binders[property];
            if (binder instanceof constantBinder.CrossFadedCompositeBinder) {
                var patternVertexBuffer = crossfade.fromScale === 2 ? binder.zoomInPaintVertexBuffer : binder.zoomOutPaintVertexBuffer;
                if (patternVertexBuffer) {
                    buffers.push(patternVertexBuffer);
                }
            } else if ((binder instanceof constantBinder.SourceExpressionBinder ||
                binder instanceof constantBinder.CompositeExpressionBinder) &&
                binder.paintVertexBuffer
            ) {
                buffers.push(binder.paintVertexBuffer);
            }
        }

        this._buffers = buffers;
    };

    ProgramConfiguration.prototype.upload = function upload(context) {
        for (var property in this.binders) {
            this.binders[property].upload(context);
        }
        var buffers = [];
        for (var property$1 in this.binders) {
            var binder = this.binders[property$1];
            if ((binder instanceof constantBinder.SourceExpressionBinder ||
                binder instanceof constantBinder.CompositeExpressionBinder) &&
                binder.paintVertexBuffer
            ) {
                buffers.push(binder.paintVertexBuffer);
            }
        }
        this._buffers = buffers;
    };

    ProgramConfiguration.prototype.destroy = function destroy() {
        for (var property in this.binders) {
            this.binders[property].destroy();
        }
    };

    var ProgramConfigurationSet = function ProgramConfigurationSet(layoutAttributes, layers, zoom, filterProperties) {
        if (filterProperties === void 0) filterProperties = function () {
            return true;
        };
        this.programConfigurations = {};
        for (var i = 0, list = layers; i < list.length; i += 1) {
            var layer = list[i];
            this.programConfigurations[layer.id] = ProgramConfiguration.createDynamic(layer, zoom, filterProperties);
            this.programConfigurations[layer.id].layoutAttributes = layoutAttributes;
        }
        this.needsUpload = false;
    };

    ProgramConfigurationSet.prototype.populatePaintArrays = function populatePaintArrays(length, feature, index, imagePositions) {
        for (var key in this.programConfigurations) {
            this.programConfigurations[key].populatePaintArrays(length, feature, index, imagePositions);
        }
        this.needsUpload = true;
    };

    ProgramConfigurationSet.prototype.updatePaintArrays = function updatePaintArrays(featureStates, vtLayer, layers, imagePositions) {
        for (var i = 0, list = layers; i < list.length; i += 1) {
            var layer = list[i];
            this.needsUpload = this.programConfigurations[layer.id].updatePaintArrays(featureStates, vtLayer, layer, imagePositions) || this.needsUpload;
        }
    };

    ProgramConfigurationSet.prototype.get = function get(layerId) {
        return this.programConfigurations[layerId];
    };

    ProgramConfigurationSet.prototype.upload = function upload(context) {
        if (!this.needsUpload) {
            return;
        }
        for (var layerId in this.programConfigurations) {
            this.programConfigurations[layerId].upload(context);
        }
        this.needsUpload = false;
    };

    ProgramConfigurationSet.prototype.destroy = function destroy() {
        for (var layerId in this.programConfigurations) {
            this.programConfigurations[layerId].destroy();
        }
    };

    exports.ProgramConfiguration = ProgramConfiguration;
    exports.ProgramConfigurationSet = ProgramConfigurationSet;

    console.log('FeaturePositionMap');
    dataTransfer.register('FeaturePositionMap', FeaturePositionMap);
    dataTransfer.register('ProgramConfiguration', ProgramConfiguration, {omit: ['_buffers']});
    dataTransfer.register('ProgramConfigurationSet', ProgramConfigurationSet);

});
},
'com/huayun/webgis/symbols/PolygonSymbol':function(){
/**
 * symbol, 
 * @module com/huayun/webgis/symbols
 * @see com.huayun.webgis.symbols.PolygonSymbol
 */
define([
    "./Symbol",
    "../utils/Color"
], function (BaseSymbol, Color) {
    /**
     * symbol, 
     * @constructor
     * @alias com.huayun.webgis.symbols.PolygonSymbol
     * @extends {Symbol}
     * @param {Object} params 
     * @param {String} params.color 
     * @param {number} params.opacity 
     * @property {String} color 
     * @property {number} opacity 
     */
    var PolygonSymbol = function (params) {
        if (params === undefined) return;
        BaseSymbol.call(this, params);
        this.type = "polygon";
        var color = Color.parse(params.color || "#FF0000"),
            opacity = params.opacity === undefined ? 1 : params.opacity;
        this._color = [color.r, color.g, color.b, color.a];
        this._opacity = opacity;
        this.uniforms = {
            "u_color": this.color,
            "u_opacity": this.opacity
        };
    };

    if (BaseSymbol) PolygonSymbol.__proto__ = BaseSymbol;
    PolygonSymbol.prototype = Object.create(BaseSymbol && BaseSymbol.prototype);
    PolygonSymbol.prototype.constructor = PolygonSymbol;

    PolygonSymbol.prototype.clone = function () {
        var result = new PolygonSymbol();
        result.minScale = this.minScale;
        result.maxScale = this.maxScale;
        result.uniforms = this.uniforms;
        result.color = this.color;
        result.opacity = this.opacity;
        return result;
    }

    var prototypeAccessors = {
        color: {configurable: true},
        opacity: {configurable: true}
    };

    prototypeAccessors.color.set = function (value) {
        var color = Color.parse(value || "#FF0000");
        this._color = [color.r, color.g, color.b, color.a];
        this.uniforms["u_color"] = this._color;
    };

    prototypeAccessors.opacity.set = function (value) {
        this._opacity = value;
        this.uniforms["u_opacity"] = value;
    };

    prototypeAccessors.color.get = function () {
        return this._color;
    };

    prototypeAccessors.opacity.get = function () {
        return this._opacity;
    };

    Object.defineProperties(PolygonSymbol.prototype, prototypeAccessors);

    return PolygonSymbol;
});

},
'com/huayun/webgis/renderer/FillRenderer':function(){
define([
    "../geometry/Point",
    "../data/bucket/FillBucketSimplify",
    "../gl/mode",
    "../gl/programCache"
], function (Point, FillBucket, mode, programCache) {
    function FillRenderer() {

    }

    FillRenderer.prototype.add = function (view, graphic, geometry, symbol) {
        var center = graphic.position || view.viewpoint.center || [0, 0],
            cx = center[0],
            cy = center[1];
        if (geometry.type === "multipolygon") {
            var buckets = [];
            for (var i = 0; i < geometry.polygons.length; i++) {
                var polygon = geometry.polygons[i];
                var bucket = this._addOnePathFeature(polygon, view, cx, cy);
                buckets.push(bucket);
            }
            graphic.buckets.push(buckets);
        } else {
            var bucket = this._addOnePathFeature(geometry, view, cx, cy);
            graphic.buckets.push(bucket);
        }
        graphic.position = [cx, cy];
    };
    /**
     *
     * @param { any } geometry
     * @param { any } view
     * @param cx
     * @param cy
     * @private
     */
    FillRenderer.prototype._addOnePathFeature = function (geometry, view, cx, cy) {
        var points = geometry.path;
        var g = [];
        for (var i = 0; i < points.length; i++) {
            var line = points[i];
            var l = [];
            for (var j = 0; j < line.length; j++) {
                var p = line[j];
                l.push(new Point(p.x - cx, p.y - cy, 0));
            }
            g.push(l);
        }
        var bucket = new FillBucket();
        bucket.addFeature(g);
        bucket.upload(view.context);
        return bucket;
    }

    FillRenderer.prototype.draw = function (view, graphic, geometry, symbol, layerView, index) {
        if (index === undefined) index = 0;
        var colorMode = mode.ColorMode.alphaBlended;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadOnly);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadOnly, [0.9, 0.9]);
        }
        var program = programCache.useProgramSimplify(context, 'basicFill', {
            layoutAttributes: [
                {name: "a_pos", type: "Float32", components: 2, offset: 0}
            ]
        });
        var uniform = symbol.uniforms;
        var position = graphic.position;
        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0], position[1]);
        uniform['u_color'] = symbol.color;
        var bucket = graphic.buckets[index];
        if (geometry.type === "multipolygon") {
            bucket.forEach(function (bck, indice) {
                program.draw(context, gl.TRIANGLES, depthMode, null, colorMode, mode.CullFaceMode.disabled,
                    uniform, graphic.id + "-fill" + index + "-" + indice, bck.layoutVertexBuffer, bck.indexBuffer, bck.segments);
            });
        } else {
            program.draw(context, gl.TRIANGLES, depthMode, null, colorMode, mode.CullFaceMode.disabled,
                uniform, graphic.id + "-fill" + index, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments);
        }
    };

    FillRenderer.prototype.drawGlow = function (view, graphic, geometry, symbol, layerView, index) {
        var glow = graphic.glow;
        if (!glow) return;
        if (index === undefined) index = 0;
        var colorMode = mode.ColorMode.alphaBlended;
        var context = view.context;
        var gl = context.gl;
        var depthMode;
        if (layerView) {
            depthMode = layerView.depthModeForSublayer(0, mode.DepthMode.ReadOnly);
        } else {
            depthMode = new mode.DepthMode(gl.LEQUAL, mode.DepthMode.ReadOnly, [0.9, 0.9]);
        }
        var program = programCache.useProgramSimplify(context, 'basicFill', {
            layoutAttributes: [
                {name: "a_pos", type: "Float32", components: 2, offset: 0}
            ]
        });
        var uniform = symbol.uniforms;
        var position = graphic.position;
        uniform["u_matrix"] = view.viewpoint.getMatrixForPoint(position[0], position[1]);
        uniform['u_color'] = glow.color;
        var bucket = graphic.buckets[index];
        program.draw(context, gl.TRIANGLES, depthMode, null, colorMode, mode.CullFaceMode.disabled,
            uniform, graphic.id + "-fill" + index, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments);
    };

    FillRenderer.prototype.calculateExtent = function (view, graphic, geometry, symbol, result) {
        var extent = geometry.extent;
        result.push({
            id: graphic.id,
            g: graphic,
            minX: extent.xmin,
            minY: extent.ymin,
            maxX: extent.xmax,
            maxY: extent.ymax,
            symbol: symbol
        });
    };

    return FillRenderer;
})

},
'com/huayun/webgis/data/uniform':function(){
define([
    "exports",
    "../utils/Color"
], function (exports, Color) {

    var Uniform = function Uniform(context, location) {
        this.gl = context.gl;
        this.location = location;
    };

    var Uniform1i = (function (Uniform) {
        function Uniform1i(context, location) {
            Uniform.call(this, context, location);
            this.current = 0;
        }

        if (Uniform) Uniform1i.__proto__ = Uniform;
        Uniform1i.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform1i.prototype.constructor = Uniform1i;

        Uniform1i.prototype.set = function set(v) {
            if (this.current !== v) {
                this.current = v;
                this.gl.uniform1i(this.location, v);
            }
        };

        return Uniform1i;
    }(Uniform));

    var Uniform1f = (function (Uniform) {
        function Uniform1f(context, location) {
            Uniform.call(this, context, location);
            this.current = 0;
        }

        if (Uniform) Uniform1f.__proto__ = Uniform;
        Uniform1f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform1f.prototype.constructor = Uniform1f;

        Uniform1f.prototype.set = function set(v) {
            if (this.current !== v) {
                this.current = v;
                this.gl.uniform1f(this.location, v);
            }
        };

        return Uniform1f;
    }(Uniform));

    var Uniform1fv = (function (Uniform) {
        function Uniform1fv(context, location) {
            Uniform.call(this, context, location);
            this.current = 0;
        }

        if (Uniform) Uniform1fv.__proto__ = Uniform;
        Uniform1fv.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform1fv.prototype.constructor = Uniform1fv;

        Uniform1fv.prototype.set = function set(v) {
            if (this.current !== v) {
                this.current = v;
                this.gl.uniform1fv(this.location, v);
            }
        };

        return Uniform1fv;
    }(Uniform));

    var Uniform2f = (function (Uniform) {
        function Uniform2f(context, location) {
            Uniform.call(this, context, location);
            this.current = [0, 0];
        }

        if (Uniform) Uniform2f.__proto__ = Uniform;
        Uniform2f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform2f.prototype.constructor = Uniform2f;

        Uniform2f.prototype.set = function set(v) {
            if (v[0] !== this.current[0] || v[1] !== this.current[1]) {
                this.current = v;
                this.gl.uniform2f(this.location, v[0], v[1]);
            }
        };

        return Uniform2f;
    }(Uniform));

    var Uniform3f = (function (Uniform) {
        function Uniform3f(context, location) {
            Uniform.call(this, context, location);
            this.current = [0, 0, 0];
        }

        if (Uniform) Uniform3f.__proto__ = Uniform;
        Uniform3f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform3f.prototype.constructor = Uniform3f;

        Uniform3f.prototype.set = function set(v) {
            if (v[0] !== this.current[0] || v[1] !== this.current[1] || v[2] !== this.current[2]) {
                this.current = v;
                this.gl.uniform3f(this.location, v[0], v[1], v[2]);
            }
        };

        return Uniform3f;
    }(Uniform));

    var Uniform4f = (function (Uniform) {
        function Uniform4f(context, location) {
            Uniform.call(this, context, location);
            this.current = [0, 0, 0, 0];
        }

        if (Uniform) Uniform4f.__proto__ = Uniform;
        Uniform4f.prototype = Object.create(Uniform && Uniform.prototype);
        Uniform4f.prototype.constructor = Uniform4f;

        Uniform4f.prototype.set = function set(v) {
            if (v[0] !== this.current[0] || v[1] !== this.current[1] ||
                v[2] !== this.current[2] || v[3] !== this.current[3]) {
                this.current = v;
                this.gl.uniform4f(this.location, v[0], v[1], v[2], v[3]);
            }
        };

        return Uniform4f;
    }(Uniform));

    var UniformColor = (function (Uniform) {
        function UniformColor(context, location) {
            Uniform.call(this, context, location);
            this.current = Color.transparent;
        }

        if (Uniform) UniformColor.__proto__ = Uniform;
        UniformColor.prototype = Object.create(Uniform && Uniform.prototype);
        UniformColor.prototype.constructor = UniformColor;

        UniformColor.prototype.set = function set(v) {
            if (v.r !== this.current.r || v.g !== this.current.g ||
                v.b !== this.current.b || v.a !== this.current.a) {
                this.current = v;
                this.gl.uniform4f(this.location, v.r, v.g, v.b, v.a);
            }
        };

        return UniformColor;
    }(Uniform));

    var UniformMatrix4f = (function (Uniform) {
        function UniformMatrix4f(context, location) {
            Uniform.call(this, context, location);
            this.current = new Float32Array(16);
        }

        if (Uniform) UniformMatrix4f.__proto__ = Uniform;
        UniformMatrix4f.prototype = Object.create(Uniform && Uniform.prototype);
        UniformMatrix4f.prototype.constructor = UniformMatrix4f;

        UniformMatrix4f.prototype.set = function set(v) {
            // 120, 
            if (v[12] !== this.current[12] || v[0] !== this.current[0]) {
                this.current = v;
                this.gl.uniformMatrix4fv(this.location, false, v);
                return;
            }
            for (var i = 1; i < 16; i++) {
                if (v[i] !== this.current[i]) {
                    this.current = v;
                    this.gl.uniformMatrix4fv(this.location, false, v);
                    break;
                }
            }
        };
        return UniformMatrix4f;
    }(Uniform));

    exports.Uniform1f = Uniform1f;
    exports.Uniform1fv = Uniform1fv;
    exports.Uniform1i = Uniform1i;
    exports.Uniform2f = Uniform2f;
    exports.Uniform3f = Uniform3f;
    exports.Uniform4f = Uniform4f;
    exports.UniformMatrix4f = UniformMatrix4f;
    exports.UniformColor = UniformColor;
});
},
'com/huayun/webgis/data/bucket/CircleBucketSimplify':function(){
/**
 *  @author :   wushengfei
 *  @date   :   2019/7/24
 *  @description : OK
 */
define([
    "../ArrayType",
    "../../gl/SegmentVector"
], function (ArrayType, SegmentVector) {

    function addCircleVertex(layoutVertexArray, x, y, extrudeX, extrudeY) {
        // layoutVertexArray.emplaceBack((x * 2) + ((extrudeX + 1) / 2), (y * 2) + ((extrudeY + 1) / 2));
        layoutVertexArray.emplaceBack(x, y, extrudeX, extrudeY);
    }

    var CircleBucket = function CircleBucket(options) {
        this.layoutVertexArray = new ArrayType.StructArrayLayout2f2ib12();
        this.indexArray = new ArrayType.StructArrayLayout3ui6();
        this.segments = new SegmentVector();
    };

    CircleBucket.prototype.destroy = function destroy() {
        if (!this.layoutVertexBuffer) {
            return;
        }
        this.layoutVertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.segments.destroy();
    };

    CircleBucket.prototype.addFeature = function addFeature(geometry) {
        for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
            var ring = list$1[i$1];
            for (var i = 0, list = ring; i < list.length; i += 1) {
                var point = list[i];
                var x = point.x;
                var y = point.y;
                var segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                var index$1 = segment.vertexLength;
                addCircleVertex(this.layoutVertexArray, x, y, -1, -1);
                addCircleVertex(this.layoutVertexArray, x, y, 1, -1);
                addCircleVertex(this.layoutVertexArray, x, y, 1, 1);
                addCircleVertex(this.layoutVertexArray, x, y, -1, 1);
                this.indexArray.emplaceBack(index$1, index$1 + 1, index$1 + 2);
                this.indexArray.emplaceBack(index$1, index$1 + 3, index$1 + 2);
                segment.vertexLength += 4;
                segment.primitiveLength += 2;
            }
        }
    };

    CircleBucket.prototype.upload = function upload(context) {
        this.layoutVertexBuffer = context.createVertexBuffer(this.layoutVertexArray, [
            {name: "a_pos", type: "Float32", components: 2, offset: 0},
            {name: "a_data", type: "Int16", components: 2, offset: 8}
        ]);
        this.indexBuffer = context.createIndexBuffer(this.indexArray);
    };
    return CircleBucket;
});
},
'url:com/huayun/webgis/gl/shaders/fill_extrusion.vertex.glsl':"#ifdef GL_ES\r\nprecision mediump float;\r\n#else\r\n\r\n#if !defined(lowp)\r\n#define lowp\r\n#endif\r\n\r\n#if !defined(mediump)\r\n#define mediump\r\n#endif\r\n\r\n#if !defined(highp)\r\n#define highp\r\n#endif\r\n\r\n#endif\r\n\r\nuniform mat4 u_matrix;\r\nuniform vec3 u_lightcolor;\r\nuniform lowp vec3 u_lightpos;\r\nuniform lowp float u_lightintensity;\r\nuniform float u_vertical_gradient;\r\nuniform lowp float u_opacity;\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_normal_ed;\r\n\r\nvarying vec4 v_color;\r\n\r\n// \r\n// \r\n#ifndef HAS_UNIFORM_u_color\r\nuniform lowp float u_color_t;\r\nattribute highp vec4 a_color;\r\n#else\r\nuniform highp vec4 u_color;\r\n#endif\r\n\r\n// \r\n#ifndef HAS_UNIFORM_u_height\r\nuniform lowp float u_height_t;\r\nattribute highp vec2 a_height;\r\n#else\r\nuniform highp float u_height;\r\n#endif\r\n\r\n// \r\n#ifdef HAS_TERRAIN\r\nuniform sampler2D u_height_image;\r\nuniform highp float u_min_height;\r\nuniform highp float u_delta_height;\r\n#else\r\n// \r\n#ifndef HAS_UNIFORM_u_base\r\nuniform lowp float u_base_t;\r\nattribute highp vec2 a_base;\r\n#else\r\nuniform highp float u_base;\r\n#endif\r\n#endif\r\n\r\n// \r\nvec2 unpack_float(const float packedValue) {\r\n    int packedIntValue = int(packedValue);\r\n    int v0 = packedIntValue/256;\r\n    return vec2(v0, packedIntValue - v0 * 256);\r\n}\r\n\r\nfloat unpack_mix_vec2(const vec2 packedValue, const float t) {\r\n    return mix(packedValue[0], packedValue[1], t);\r\n}\r\n\r\nvec4 decode_color(const vec2 encodedColor) {\r\n    return vec4(\r\n    unpack_float(encodedColor[0]) / 255.0,\r\n    unpack_float(encodedColor[1]) / 255.0\r\n    );\r\n}\r\n\r\nvec4 unpack_mix_color(const vec4 packedColors, const float t) {\r\n    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\r\n    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\r\n    return mix(minColor, maxColor, t);\r\n}\r\n\r\nvoid main() {\r\n\r\n    #ifndef HAS_UNIFORM_u_height\r\n    highp float height = unpack_mix_vec2(a_height, u_height_t);\r\n    #else\r\n    highp float height = u_height;\r\n    #endif\r\n\r\n    #ifndef HAS_UNIFORM_u_color\r\n    highp vec4 color = unpack_mix_color(a_color, u_color_t);\r\n    #else\r\n    highp vec4 color = u_color;\r\n    #endif\r\n\r\n    #ifdef HAS_TERRAIN\r\n    vec3 rgb = texture2D(u_height_image, a_pos/8192.0).rgb;\r\n    highp float base = rgb.r * u_delta_height + u_min_height;\r\n    #else\r\n    #ifndef HAS_UNIFORM_u_base\r\n    highp float base = unpack_mix_vec2(a_base, u_base_t);\r\n    #else\r\n    highp float base = u_base;\r\n    #endif\r\n    #endif\r\n\r\n    vec3 normal = a_normal_ed.xyz;\r\n    float t = mod(normal.x, 2.0);\r\n    gl_Position = u_matrix * vec4(a_pos, t > 0.0 ? height + base : base, 1);\r\n    float colorvalue = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\r\n    v_color = vec4(0.0, 0.0, 0.0, 1.0);\r\n    vec4 ambientlight = vec4(0.03, 0.03, 0.03, 1.0);\r\n    color += ambientlight;\r\n    float directional = clamp(dot(normal / 16384.0, u_lightpos), 0.0, 1.0);\r\n    directional = mix((1.0 - u_lightintensity), max((1.0 - colorvalue + u_lightintensity), 1.0), directional);\r\n    if (normal.y != 0.0) {\r\n        directional *= (\r\n        (1.0 - u_vertical_gradient) +\r\n        (u_vertical_gradient * clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0)));\r\n    }\r\n    v_color.r += clamp(color.r * directional * u_lightcolor.r, mix(0.0, 0.3, 1.0 - u_lightcolor.r), 1.0);\r\n    v_color.g += clamp(color.g * directional * u_lightcolor.g, mix(0.0, 0.3, 1.0 - u_lightcolor.g), 1.0);\r\n    v_color.b += clamp(color.b * directional * u_lightcolor.b, mix(0.0, 0.3, 1.0 - u_lightcolor.b), 1.0);\r\n    v_color *= u_opacity;\r\n}\r\n",
'url:com/huayun/webgis/gl/shaders/fill_extrusion.fragment.glsl':"precision mediump float;\r\nvarying vec4 v_color;\r\n\r\nvoid main() {\r\n    gl_FragColor = v_color;\r\n}\r\n",
'url:com/huayun/webgis/gl/shaders/cylinder.fragment.glsl':"precision mediump float;\r\nuniform float u_opacity;\r\n\r\n#ifdef HAS_PATTERN\r\nvarying vec2 v_uv;\r\nuniform sampler2D u_texture;\r\n#else\r\nuniform vec4 u_color;\r\n#endif\r\n\r\nvoid main() {\r\n    #ifdef HAS_PATTERN\r\n    gl_FragColor = texture2D(u_texture, v_uv) * u_opacity;\r\n    #else\r\n    gl_FragColor = u_color * u_opacity;\r\n    #endif\r\n}",
'url:com/huayun/webgis/gl/shaders/mesh.fragment.glsl':"precision mediump float;\r\nuniform vec3 u_color;\r\nvoid main() {\r\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n}",
'url:com/huayun/webgis/gl/shaders/terrain.vertex.glsl':"const float m2d = 111194.872221777 / 2.0;\r\n\r\nattribute vec4 position3DAndHeight;\r\nattribute vec3 textureCoordAndEncodedNormals;\r\n\r\nuniform mat4 u_matrix;\r\nuniform vec4 u_tileRectangle;\r\nuniform float u_resolution;\r\nvarying vec2 v_texture;\r\n//varying float color;\r\n\r\nfloat get2DGeographicYPositionFraction(vec2 textureCoordinates){\r\n    return 1.0 - textureCoordinates.y;\r\n}\r\n\r\nfloat get2DYPositionFraction(vec2 textureCoordinates) {\r\n    return get2DGeographicYPositionFraction(textureCoordinates);\r\n}\r\n\r\nvec4 getPositionPlanarEarth(vec3 position, float height, vec2 textureCoordinates){\r\n    float yPositionFraction = get2DYPositionFraction(textureCoordinates);\r\n    vec4 rtcPosition2D = vec4(mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), height/  111194.872221777, 1.0);\r\n    return u_matrix * rtcPosition2D;\r\n}\r\n\r\nvec4 getPositionColumbusViewMode(vec3 position, float height, vec2 textureCoordinates){\r\n    return getPositionPlanarEarth(position, height, textureCoordinates);\r\n}\r\n\r\nvec4 getPosition(vec3 position, float height, vec2 textureCoordinates) {\r\n    return getPositionColumbusViewMode(position, height, textureCoordinates);\r\n}\r\n\r\nvoid main() {\r\n    //    gl_Position = u_matrix * vec4(a_pos, 0, 1);\r\n    vec3 position = position3DAndHeight.xyz;\r\n    float height = position3DAndHeight.w;\r\n    vec2 textureCoordinates = textureCoordAndEncodedNormals.xy;\r\n    gl_Position = getPosition(position, height, textureCoordinates);\r\n    v_texture = textureCoordinates;\r\n    /*float ratio = height / 200.0;\r\n    if (ratio > 1.0) {\r\n        color = 1.0;\r\n    } else {\r\n        color = ratio;\r\n    }*/\r\n    /*if (height > 20.0) {\r\n        color = 1.0;\r\n    } else {\r\n        color = 0.0;\r\n    }*/\r\n}",
'url:com/huayun/webgis/gl/shaders/cone.fragment.glsl':"precision mediump float;\r\nvarying vec4 v_color;\r\n\r\nvoid main() {\r\n    gl_FragColor = v_color;\r\n}",
'url:com/huayun/webgis/gl/shaders/tifTerrain.fragment.glsl':"precision mediump float;\r\n\r\nuniform sampler2D u_image;\r\nvarying vec2 v_texture;\r\n\r\nvoid main() {\r\n//    vec2 tex_location = vec2(v_texture.x, 1.0 - v_texture.y);\r\n    if(v_texture.x < 0.0 || v_texture.x > 1.0 || v_texture.y < 0.0 || v_texture.y > 1.0) {\r\n        discard;\r\n    }\r\n    gl_FragColor = texture2D(u_image, v_texture);\r\n}",
'url:com/huayun/webgis/gl/shaders/line.fragment.glsl':"precision mediump float;\r\n\r\nvarying vec2 v_width2;\r\nvarying vec2 v_normal;\r\nvarying float v_gamma_scale;\r\nuniform highp vec4 u_color;\r\nuniform lowp float u_opacity;\r\n\r\nvoid main() {\r\n\r\n\r\n    highp vec4 color = u_color;\r\n    lowp float blur = 0.0;\r\n    lowp float opacity = u_opacity;\r\n    lowp float u_device_pixel_ratio = 1.0;\r\n\r\n    float dist = length(v_normal) * v_width2.s;\r\n\r\n    float blur2 = (blur + 1.0 / u_device_pixel_ratio) * v_gamma_scale;\r\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\r\n    gl_FragColor = color * (alpha * opacity);\r\n}",
'url:com/huayun/webgis/gl/shaders/line.vertex.glsl':"precision highp float;\r\n\r\n#define scale 0.01587301\r\n// #define scale 0.007936508\r\n\r\nattribute vec3 a_pos;\r\nattribute vec4 a_data;\r\nattribute vec2 a_normal;\r\n\r\nuniform mat4 u_matrix;\r\nuniform mediump float u_ratio;\r\nuniform vec2 u_units_to_pixels;\r\n\r\nvarying vec2 v_normal;\r\nvarying vec2 v_width2;\r\nvarying float v_gamma_scale;\r\nvarying highp float v_linesofar;\r\n\r\nuniform highp vec4 u_color;\r\nuniform lowp float u_blur;\r\nuniform lowp float u_opacity;\r\nuniform mediump float u_gapwidth;\r\nuniform lowp float u_offset;\r\nuniform mediump float u_width;\r\n\r\nvoid main() {\r\n    highp vec4 color = u_color;\r\n    lowp float blur = u_blur;\r\n    lowp float opacity = u_opacity;\r\n    mediump float gapwidth = u_gapwidth;\r\n    lowp float offset = u_offset;\r\n    mediump float width = u_width;\r\n\r\n    // the distance over which the line edge fades out.\r\n    // Retina devices need a smaller distance to avoid aliasing.\r\n    float ANTIALIASING = 0.5;\r\n\r\n    vec2 a_extrude = a_data.xy - 128.0;\r\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\r\n\r\n    v_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0;\r\n\r\n    vec2 pos = a_pos.xy;\r\n\r\n    mediump vec2 normal = a_normal;\r\n    normal.y = normal.y * 2.0 - 1.0;\r\n    v_normal = normal;\r\n\r\n    // these transformations used to be applied in the JS and native code bases.\r\n    // moved them into the shader for clarity and simplicity.\r\n    gapwidth = gapwidth / 2.0;\r\n    float halfwidth = width / 2.0;\r\n    offset = -1.0 * offset;\r\n\r\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\r\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\r\n\r\n    // Scale the extrusion vector down to a normal and then up by the line width\r\n    // of this vertex.\r\n    mediump vec2 dist = outset * a_extrude * scale;\r\n\r\n    // Calculate the offset when drawing a line that is to the side of the actual line.\r\n    // We do this by creating a vector that points towards the extrude, but rotate\r\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\r\n    // extrude vector points in another direction.\r\n    mediump float u = 0.5 * a_direction;\r\n    mediump float t = 1.0 - abs(u);\r\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\r\n\r\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\r\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, a_pos.z, 1.0) + projected_extrude;\r\n\r\n    // calculate how much the perspective view squishes or stretches the extrude\r\n    float extrude_length_without_perspective = length(dist);\r\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);\r\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\r\n\r\n    v_width2 = vec2(outset, inset);\r\n}",
'url:com/huayun/webgis/gl/shaders/rect.fragment.glsl':"precision mediump float;\r\nuniform vec4 u_color;\r\n\r\nvoid main() {\r\n    gl_FragColor = u_color;\r\n}",
'url:com/huayun/webgis/gl/shaders/height_map.fragment.glsl':"precision mediump float;\r\nvarying float v_color;\r\n\r\nvoid main() {\r\n//    gl_FragColor = vec4(v_color, v_color, v_color, 1.0);\r\n    gl_FragColor = vec4(v_color, v_color, v_color, 1.0);\r\n}",
'url:com/huayun/webgis/gl/shaders/rect.vertex.glsl':"attribute vec2 a_pos;\r\nattribute vec4 a_size;\r\n\r\nuniform mat4 u_matrix;\r\nuniform lowp float u_device_pixel_ratio;\r\nuniform highp float u_camera_to_center_distance;\r\nuniform mediump vec2 u_extrude_scale;\r\nuniform highp float u_radian;\r\nuniform bool u_is_stroke;\r\n\r\nuniform highp float u_size;\r\n\r\nvoid main() {\r\n    gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\r\n    highp float angle_sin = sin(u_radian);\r\n    highp float angle_cos = cos(u_radian);\r\n    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\r\n    vec2 core_size = a_size.xy / 2.0;\r\n    vec2 stroke_size = a_size.zw / 2.0;\r\n    vec2 rotated_extrude;\r\n    if (u_is_stroke) {\r\n        rotated_extrude = rotation_matrix * stroke_size * u_size;\r\n    } else {\r\n        rotated_extrude = rotation_matrix * core_size * u_size;\r\n    }\r\n    gl_Position.xy += rotated_extrude * u_extrude_scale * u_camera_to_center_distance;\r\n}",
'url:com/huayun/webgis/gl/shaders/tiffTerrain.vertex.glsl':"precision highp float;\r\n\r\nattribute vec3 a_pos;\r\nuniform mat4 u_matrix;\r\n\r\nvarying vec2 v_texture;\r\n\r\nvoid main() {\r\n    vec2 pos = a_pos.xy * 8192.0;\r\n    float height = a_pos.z;\r\n    gl_Position = u_matrix * vec4(pos, height, 1.0);\r\n    v_texture = a_pos.xy;\r\n}",
'url:com/huayun/webgis/gl/shaders/terrain.fragment.glsl':"precision mediump float;\r\nuniform vec4 u_color;\r\n//varying float color;\r\nuniform sampler2D u_image;\r\nvarying vec2 v_texture;\r\n// const float m2d = 111194.872221777 / 2.0;\r\n\r\nvoid main() {\r\n    vec2 tex_location = vec2(v_texture.x, 1.0 - v_texture.y);\r\n    vec4 color0 = texture2D(u_image, tex_location);\r\n    gl_FragColor = color0;\r\n//    gl_FragColor = vec4(color, color, color, 1.0);\r\n//    gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\r\n}",
'url:com/huayun/webgis/gl/shaders/background.fragment.glsl':"precision mediump float;\r\n\r\n/*uniform sampler2D u_image;\r\nvarying vec2 v_texture;*/\r\nvarying float y_screen;\r\n\r\nvoid main() {\r\n    //    gl_FragColor = texture2D(u_image, v_texture);\r\n    float fogFactor = 1.0 - smoothstep(0.3, 0.5, y_screen);\r\n    gl_FragColor = vec4(0.94, 0.93, 0.91, 1.0) * (1.0-fogFactor) + vec4(0.0, 0.0, 0.0, 0.0) * fogFactor;\r\n}",
'url:com/huayun/webgis/gl/shaders/mesh.vertex.glsl':"precision highp float;\r\nattribute vec3 position;\r\nuniform mat4 u_matrix;\r\nuniform mat4 u_model;\r\nvoid main() {\r\n    gl_Position = u_matrix * u_model * vec4(position, 1.0);\r\n}",
'url:com/huayun/webgis/gl/shaders/cone.vertex.glsl':"attribute vec3 a_pos;\r\nattribute vec4 a_color;\r\n\r\nvarying vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n    gl_Position = u_matrix * vec4(a_pos, 1.0);\r\n    v_color = a_color;\r\n}\r\n",
'url:com/huayun/webgis/gl/shaders/water.fragment.glsl':"precision mediump float;\r\nvoid main() {\r\n    gl_FragColor = vec4(0.3, 0.7, 0.72, 1.0);\r\n}",
'url:com/huayun/webgis/gl/shaders/water.vertex.glsl':"attribute vec3 a_pos;\r\nuniform mat4 u_matrix;\r\nuniform float u_water_depth;\r\nvoid main() {\r\n    gl_Position = u_matrix * vec4(a_pos.xy, a_pos.z > 0.0?u_water_depth:0.0, 1.0);\r\n}",
'url:com/huayun/webgis/gl/shaders/height_map.vertex.glsl':"precision highp float;\r\n\r\nattribute vec3 a_pos;\r\n\r\nuniform float u_min_height;\r\nuniform float u_delta_height;\r\nvarying float v_color;\r\n\r\nvoid main() {\r\n    float height = a_pos.z;\r\n    gl_Position = vec4(a_pos.xy * 2.0 - 1.0, 0.0, 1.0);\r\n    v_color = (height - u_min_height) / u_delta_height;\r\n}\r\n\r\n/*\r\nattribute vec4 position3DAndHeight;\r\nattribute vec3 textureCoordAndEncodedNormals;\r\n\r\nuniform float u_min_height;\r\nuniform float u_delta_height;\r\nvarying float v_color;\r\n\r\nvec4 getPosition(vec3 position, float height, vec2 textureCoordinates) {\r\n    float yPositionFraction = 1.0 - textureCoordinates.y;\r\n    return vec4(textureCoordinates.x * 2.0 -1.0, yPositionFraction* 2.0 -1.0, 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    vec3 position = position3DAndHeight.xyz;\r\n    float height = position3DAndHeight.w;\r\n    vec2 textureCoordinates = textureCoordAndEncodedNormals.xy;\r\n    gl_Position = getPosition(position, 0.0, textureCoordinates);\r\n    v_color = (height - u_min_height) / u_delta_height;\r\n}*/",
'url:com/huayun/webgis/gl/shaders/cylinder.vertex.glsl':"attribute vec3 a_pos;\r\n\r\n#ifdef HAS_PATTERN\r\nattribute vec2 a_uv;\r\nvarying vec2 v_uv;\r\n#endif\r\n\r\nuniform mat4 u_matrix;\r\nuniform float u_size;\r\n\r\nvoid main() {\r\n    gl_Position = u_matrix * vec4(u_size * a_pos.xy, a_pos.z, 1.0);\r\n    #ifdef HAS_PATTERN\r\n    v_uv = a_uv;\r\n    #endif\r\n}\r\n",
'url:com/huayun/webgis/gl/shaders/background.vertex.glsl':"attribute vec4 a_pos;\r\n\r\nvarying float y_screen;\r\n//varying vec2 v_texture;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(a_pos.xy, 0.0, 1.0);\r\n//    v_texture = a_pos.zw;\r\n    y_screen = a_pos.y;\r\n}"}});
(function(){
	// must use this.require to make this work in node.js
	var require = this.require;
	// consume the cached dojo layer
	require({cache:{}});
	!require.async && require(["dojo"]);
	require.boot && require.apply(null, require.boot);
})();
