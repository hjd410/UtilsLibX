//>>built
define("com/huayun/gl/shaders/linePattern",["exports","../../webgis/data/uniform"],function(d,a){d.linePatternVS="precision highp float;\n\n#define scale 0.01587301\n// #define scale 0.007936508\n\nattribute vec3 a_pos;\nattribute vec4 a_data;\nattribute vec2 a_uv;\nattribute vec2 a_normal;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_gamma_scale;\nvarying highp float v_linesofar;\nvarying vec2 v_uv;\n\nuniform highp vec4 u_color;\nuniform lowp float u_blur;\nuniform lowp float u_opacity;\nuniform mediump float u_gapwidth;\nuniform lowp float u_offset;\nuniform mediump float u_width;\n\nvoid main() {\n    highp vec4 color \x3d u_color;\n    lowp float blur \x3d u_blur;\n    lowp float opacity \x3d u_opacity;\n    mediump float gapwidth \x3d u_gapwidth;\n    lowp float offset \x3d u_offset;\n    mediump float width \x3d u_width;\n\n    // the distance over which the line edge fades out.\n    // Retina devices need a smaller distance to avoid aliasing.\n    float ANTIALIASING \x3d 0.5;\n\n    vec2 a_extrude \x3d a_data.xy - 128.0;\n    float a_direction \x3d mod(a_data.z, 4.0) - 1.0;\n\n    v_linesofar \x3d (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0;\n\n    vec2 pos \x3d a_pos.xy;\n\n    mediump vec2 normal \x3d a_normal;\n    normal.y \x3d normal.y * 2.0 - 1.0;\n    v_normal \x3d normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth \x3d gapwidth / 2.0;\n    float halfwidth \x3d width / 2.0;\n    offset \x3d -1.0 * offset;\n\n    float inset \x3d gapwidth + (gapwidth \x3e 0.0 ? ANTIALIASING : 0.0);\n    float outset \x3d gapwidth + halfwidth * (gapwidth \x3e 0.0 ? 2.0 : 1.0) + (halfwidth \x3d\x3d 0.0 ? 0.0 : ANTIALIASING);\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist \x3d outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction \x3d -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u \x3d 0.5 * a_direction;\n    mediump float t \x3d 1.0 - abs(u);\n    mediump vec2 offset2 \x3d offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude \x3d u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position \x3d u_matrix * vec4(pos + offset2 / u_ratio, a_pos.z, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective \x3d length(dist);\n    float extrude_length_with_perspective \x3d length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);\n    v_gamma_scale \x3d extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_width2 \x3d vec2(outset, inset);\n    v_uv \x3d a_uv;\n}";
d.linePatternFS="precision mediump float;\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\nvarying vec2 v_uv;\nuniform sampler2D u_texture;\nuniform highp vec4 u_color;\nuniform lowp float u_opacity;\n\nvoid main() {\n    gl_FragColor \x3d texture2D(u_texture, v_uv);\n//    gl_FragColor \x3d vec4(1.0, 0.0, 1.0, 1.0);\n}";d.linePatternUniforms=function(b,c){return{u_matrix:new a.UniformMatrix4f(b,c.u_matrix),u_ratio:new a.Uniform1f(b,c.u_ratio),u_units_to_pixels:new a.Uniform2f(b,
c.u_units_to_pixels),u_blur:new a.Uniform1f(b,c.u_blur),u_opacity:new a.Uniform1f(b,c.u_opacity),u_gapwidth:new a.Uniform1f(b,c.u_gapwidth),u_offset:new a.Uniform1f(b,c.u_offset),u_width:new a.Uniform1f(b,c.u_width),u_texture:new a.Uniform1i(b,c.u_texture)}}});